<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Rtspproxy-devel] r415 - in trunk: RTSPProxy-App RTSPProxy-App/src/main/java/rtspproxy RTSPProxy-App/src/main/java/rtspproxy/filter/accounting RTSPProxy-App/src/resources/conf RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress RTSPProxy-Core RTSPProxy-Core/src/main/java/gov/nist/javax/sdp RTSPProxy-Core/src/main/java/javax/sdp RTSPProxy-Core/src/main/java/rtspproxy RTSPProxy-Core/src/main/java/rtspproxy/config RTSPProxy-Core/src/main/java/rtspproxy/filter RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme RTSPProxy-Core/src/main/java/rtspproxy/filter/control RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking RTSPProxy-Core/src/main/java/rtspproxy/jmx RTSPProxy-Core/src/main/java/rtspproxy/lib RTSPProxy-Core/src/main/java/rtspproxy/lib/number RTSPProxy-Core/src/main/java/rtspproxy/proxy RTSPProxy-Core/src/main/java/rtspproxy/proxy/track RTSPProxy-! Core/src/main/java/rtspproxy/rdt RTSPProxy-Core/src/main/java/rtspproxy/rtp/range RTSPProxy-Core/src/main/java/rtspproxy/rtsp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/rtspproxy-devel/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:rtspproxy-devel%40lists.berlios.de?Subject=Re%3A%20%5BRtspproxy-devel%5D%20r415%20-%20in%20trunk%3A%20RTSPProxy-App%20RTSPProxy-App/src/main/java/rtspproxy%20RTSPProxy-App/src/main/java/rtspproxy/filter/accounting%20RTSPProxy-App/src/resources/conf%20RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress%20RTSPProxy-Core%20RTSPProxy-Core/src/main/java/gov/nist/javax/sdp%20RTSPProxy-Core/src/main/java/javax/sdp%20RTSPProxy-Core/src/main/java/rtspproxy%20RTSPProxy-Core/src/main/java/rtspproxy/config%20RTSPProxy-Core/src/main/java/rtspproxy/filter%20RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication%20RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme%20RTSPProxy-Core/src/main/java/rtspproxy/filter/control%20RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite%20RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking%20RTSPProxy-Core/src/main/java/rtspproxy/jmx%20RTSPProxy-Core/src/main/java/rtspproxy/lib%20RTSPProxy-Core/src/main/java/rtspproxy/lib/number%20RTSPProxy-Core/src/main/java/rtspproxy/proxy%20RTSPProxy-Core/src/main/java/rtspproxy/proxy/track%20RTSPProxy-%21%0A%20Core/src/main/java/rtspproxy/rdt%20RTSPProxy-Core/src/main/java/rtspproxy/rtp/range%20RTSPProxy-Core/src/main/java/rtspproxy/rtsp&In-Reply-To=%3C200604141542.k3EFgUE3025362%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000100.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Rtspproxy-devel] r415 - in trunk: RTSPProxy-App RTSPProxy-App/src/main/java/rtspproxy RTSPProxy-App/src/main/java/rtspproxy/filter/accounting RTSPProxy-App/src/resources/conf RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress RTSPProxy-Core RTSPProxy-Core/src/main/java/gov/nist/javax/sdp RTSPProxy-Core/src/main/java/javax/sdp RTSPProxy-Core/src/main/java/rtspproxy RTSPProxy-Core/src/main/java/rtspproxy/config RTSPProxy-Core/src/main/java/rtspproxy/filter RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme RTSPProxy-Core/src/main/java/rtspproxy/filter/control RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking RTSPProxy-Core/src/main/java/rtspproxy/jmx RTSPProxy-Core/src/main/java/rtspproxy/lib RTSPProxy-Core/src/main/java/rtspproxy/lib/number RTSPProxy-Core/src/main/java/rtspproxy/proxy RTSPProxy-Core/src/main/java/rtspproxy/proxy/track RTSPProxy-! Core/src/main/java/rtspproxy/rdt RTSPProxy-Core/src/main/java/rtspproxy/rtp/range RTSPProxy-Core/src/main/java/rtspproxy/rtsp</H1>
    <B>merlimat at berlios.de</B> 
    <A HREF="mailto:rtspproxy-devel%40lists.berlios.de?Subject=Re%3A%20%5BRtspproxy-devel%5D%20r415%20-%20in%20trunk%3A%20RTSPProxy-App%20RTSPProxy-App/src/main/java/rtspproxy%20RTSPProxy-App/src/main/java/rtspproxy/filter/accounting%20RTSPProxy-App/src/resources/conf%20RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress%20RTSPProxy-Core%20RTSPProxy-Core/src/main/java/gov/nist/javax/sdp%20RTSPProxy-Core/src/main/java/javax/sdp%20RTSPProxy-Core/src/main/java/rtspproxy%20RTSPProxy-Core/src/main/java/rtspproxy/config%20RTSPProxy-Core/src/main/java/rtspproxy/filter%20RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication%20RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme%20RTSPProxy-Core/src/main/java/rtspproxy/filter/control%20RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite%20RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking%20RTSPProxy-Core/src/main/java/rtspproxy/jmx%20RTSPProxy-Core/src/main/java/rtspproxy/lib%20RTSPProxy-Core/src/main/java/rtspproxy/lib/number%20RTSPProxy-Core/src/main/java/rtspproxy/proxy%20RTSPProxy-Core/src/main/java/rtspproxy/proxy/track%20RTSPProxy-%21%0A%20Core/src/main/java/rtspproxy/rdt%20RTSPProxy-Core/src/main/java/rtspproxy/rtp/range%20RTSPProxy-Core/src/main/java/rtspproxy/rtsp&In-Reply-To=%3C200604141542.k3EFgUE3025362%40sheep.berlios.de%3E"
       TITLE="[Rtspproxy-devel] r415 - in trunk: RTSPProxy-App RTSPProxy-App/src/main/java/rtspproxy RTSPProxy-App/src/main/java/rtspproxy/filter/accounting RTSPProxy-App/src/resources/conf RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress RTSPProxy-Core RTSPProxy-Core/src/main/java/gov/nist/javax/sdp RTSPProxy-Core/src/main/java/javax/sdp RTSPProxy-Core/src/main/java/rtspproxy RTSPProxy-Core/src/main/java/rtspproxy/config RTSPProxy-Core/src/main/java/rtspproxy/filter RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme RTSPProxy-Core/src/main/java/rtspproxy/filter/control RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking RTSPProxy-Core/src/main/java/rtspproxy/jmx RTSPProxy-Core/src/main/java/rtspproxy/lib RTSPProxy-Core/src/main/java/rtspproxy/lib/number RTSPProxy-Core/src/main/java/rtspproxy/proxy RTSPProxy-Core/src/main/java/rtspproxy/proxy/track RTSPProxy-! Core/src/main/java/rtspproxy/rdt RTSPProxy-Core/src/main/java/rtspproxy/rtp/range RTSPProxy-Core/src/main/java/rtspproxy/rtsp">merlimat at berlios.de
       </A><BR>
    <I>Fri Apr 14 17:42:30 CEST 2006</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000100.html">[Rtspproxy-devel] r416 - in trunk: . RTSPProxy-App RTSPProxy-App/src/main/java/rtspproxy/filter/accounting RTSPProxy-App/src/main/java/rtspproxy/filter/authentication RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite RTSPProxy-App/src/resources/conf RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress RTSPProxy-Core RTSPProxy-Core/src RTSPProxy-Core/src/main/java/gov/nist/core RTSPProxy-Core/src/main/java/gov/nist/javax/sdp RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser RTSPProxy-Core/src/main/java/javax/sdp RTSPProxy-Core/src/main/java/rtspproxy RTSPProxy-Core/src/main/java/rtspproxy/config RTSPProxy-Core/src/main/java/rtspproxy/filter RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme RTSPProxy-Core/src/main/java/rtspproxy/filte! r/control RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking RTSPProxy-Core/src/main/java/rtspproxy/jmx RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans RTSPProxy-Core/src/main/java/rtspproxy/lib RTSPProxy-Core/src/main/java/rtspproxy/lib/number RTSPProxy-Core/src/main/java/rtspproxy/proxy RTSPProxy-Core/src/main/java/rtspproxy/proxy/track RTSPProxy-Core/src/main/java/rtspproxy/rdt RTSPProxy-Core/src/main/java/rtspproxy/rtp/range RTSPProxy-Core/src/main/java/rtspproxy/rtsp RTSPProxy-Core/src/test/java/rtspproxy/lib/number RTSPProxy-Core/src/test/java/rtspproxy/rdt RTSPProxy-Core/src/test/java/rtspproxy/rtsp RTSPProxy-Core/src/test/resources/rtspproxy/rdt RTSPProxy-OSGi src/changes src/site
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#99">[ date ]</a>
              <a href="thread.html#99">[ thread ]</a>
              <a href="subject.html#99">[ subject ]</a>
              <a href="author.html#99">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: merlimat
Date: 2006-04-14 17:41:06 +0200 (Fri, 14 Apr 2006)
New Revision: 415

Added:
   trunk/RTSPProxy-App/src/resources/conf/user.properties
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java
Removed:
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerListParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringListParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/transport/
Modified:
   trunk/RTSPProxy-App/
   trunk/RTSPProxy-App/pom.xml
   trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java
   trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java
   trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml
   trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml
   trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java
   trunk/RTSPProxy-Core/
   trunk/RTSPProxy-Core/pom.xml
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java
   trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactoryException.java
   trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpParseException.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtClientService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtServerService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/Reactor.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/RtspService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/ShutdownHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/BooleanParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Parameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/Credentials.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/DigestAuthentication.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Authenticator.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/ParametersMBean.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/NetworkInterface.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Npt.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/PortManager.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Singleton.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRdtPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientSide.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxySession.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRdtPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtcpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerSide.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RdtTrack.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RtpTrack.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspCode.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspDecoder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspMessage.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspRequest.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspResponse.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspSession.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransport.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/package.html
Log:
Big code synchronization and refactoring.


Property changes on: trunk/RTSPProxy-App
___________________________________________________________________
Name: svn:ignore
   + 
target


Modified: trunk/RTSPProxy-App/pom.xml
===================================================================
--- trunk/RTSPProxy-App/pom.xml	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/pom.xml	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,13 +6,14 @@
 		$Id$
 		$URL$
 	--&gt;
-        &lt;parent&gt;
-                &lt;groupId&gt;net.merlimat&lt;/groupId&gt;
-                &lt;artifactId&gt;rtspproxy&lt;/artifactId&gt;
-                &lt;version&gt;3.0-ALPHA5-SNAPSHOT&lt;/version&gt;
-		&lt;relativePath&gt;../pom.xml&lt;/relativePath&gt;
-        &lt;/parent&gt;
 
+	&lt;parent&gt;
+		&lt;groupId&gt;net.merlimat&lt;/groupId&gt;
+		&lt;artifactId&gt;rtspproxy&lt;/artifactId&gt;
+		&lt;version&gt;3.0-ALPHA5-SNAPSHOT&lt;/version&gt;
+		&lt;!--	&lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; --&gt;
+	&lt;/parent&gt;
+
 	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
 	&lt;name&gt;RTSP Proxy standalone application&lt;/name&gt;
@@ -24,41 +25,22 @@
 
 
 	&lt;dependencies&gt;
-
-    &lt;dependency&gt;
-      &lt;groupId&gt;net.merlimat&lt;/groupId&gt;
-      &lt;artifactId&gt;RTSPProxy-Core&lt;/artifactId&gt;
-      &lt;version&gt;3.0-ALPHA5-SNAPSHOT&lt;/version&gt;
-    &lt;/dependency&gt;
-
 		&lt;dependency&gt;
-			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
-			&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
-			&lt;version&gt;1.0-rc3&lt;/version&gt;
+			&lt;groupId&gt;net.merlimat&lt;/groupId&gt;
+			&lt;artifactId&gt;RTSPProxy-Core&lt;/artifactId&gt;
+			&lt;version&gt;3.0-ALPHA5-SNAPSHOT&lt;/version&gt;
 		&lt;/dependency&gt;
-
+		
 		&lt;dependency&gt;
-			&lt;groupId&gt;log4j&lt;/groupId&gt;
-			&lt;artifactId&gt;log4j&lt;/artifactId&gt;
-			&lt;version&gt;1.2.9&lt;/version&gt;
-		&lt;/dependency&gt;
-
-		&lt;dependency&gt;
 			&lt;groupId&gt;junit&lt;/groupId&gt;
 			&lt;artifactId&gt;junit&lt;/artifactId&gt;
 			&lt;version&gt;3.8.1&lt;/version&gt;
 			&lt;scope&gt;test&lt;/scope&gt;
 		&lt;/dependency&gt;
+		
 	&lt;/dependencies&gt;
-&lt;!--
-	&lt;repositories&gt;
-		&lt;repository&gt;
-		&lt;id&gt;Apache repository&lt;/id&gt;
-		&lt;url&gt;<A HREF="http://svn.apache.org/repository/&lt;/url">http://svn.apache.org/repository/&lt;/url</A>&gt;
-		&lt;/repository&gt;
-	&lt;/repositories&gt;
---&gt;
 
+
 	&lt;build&gt;
 		&lt;defaultGoal&gt;assembly:directory&lt;/defaultGoal&gt;
 

Modified: trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -19,6 +19,7 @@
 
 import java.io.File;
 import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.log4j.BasicConfigurator;
 import org.apache.log4j.Logger;
@@ -35,88 +36,90 @@
 public class Main
 {
 
-	static Logger log = Logger.getLogger( &quot;rtspproxy&quot; );
+    static Logger log = Logger.getLogger( &quot;rtspproxy&quot; );
 
-	public static void main( String[] args )
-	{
-		// Configure the logger with default settings
-		// useful to track pre-config file errors
-		BasicConfigurator.configure();
+    public static void main( String[] args )
+    {
+        // Configure the logger with default settings
+        // useful to track pre-config file errors
+        BasicConfigurator.configure();
 
-		// Register the signal handler
-		Runtime.getRuntime().addShutdownHook( new ShutdownHandler() );
+        // Register the signal handler
+        Runtime.getRuntime().addShutdownHook( new ShutdownHandler() );
 
-		try {
-			// Read configuration files
-			new Config();
+        try {
+            // Read configuration files
+            new Config();
 
-			// Log4J configuration
-			ArrayList&lt;String&gt; log4jList = new ArrayList&lt;String&gt;();
-			
-			// system wide configuration (typical on un*x-like systems)
-			log4jList.add(&quot;/etc/rtspproxy.log4j.&quot;);
-			
-			// Per-user configuration
-			log4jList.add(System.getProperty( &quot;user.home&quot;, &quot;&quot; ) + &quot;/.rtspproxy.log4j.&quot;);
+            // Log4J configuration
+            List&lt;String&gt; log4jList = new ArrayList&lt;String&gt;();
 
-			// RtspProxy home folder
-			if(Config.getHome() != null)
-				log4jList.add(Config.getHome() + &quot;/conf/rtspproxy.log4j.&quot;);
+            // system wide configuration (typical on un*x-like systems)
+            log4jList.add( &quot;/etc/rtspproxy.log4j.&quot; );
 
-			// Current directory configuration
-			log4jList.add(&quot;rtspproxy.log4j.&quot;);
+            // Per-user configuration
+            log4jList.add( System.getProperty( &quot;user.home&quot;, &quot;&quot; ) + &quot;/.rtspproxy.log4j.&quot; );
 
-			// Used for testing purposes:
-			// checks for the configuration file
-			log4jList.add(&quot;src/resources/conf/rtspproxy.log4j.&quot;);
+            // RtspProxy home folder
+            if ( Config.getHome() != null )
+                log4jList.add( Config.getHome() + &quot;/conf/rtspproxy.log4j.&quot; );
 
-			for(String path : log4jList) {
-				File propFile = new File(path + &quot;properties&quot;);
-				File xmlFile = new File(path + &quot;xml&quot;);
-				
-				if(propFile.canRead())
-					PropertyConfigurator.configure(propFile.toURL());
-				else if(xmlFile.canRead())
-					DOMConfigurator.configure(xmlFile.toURL());
-			}
-			
-			ArrayList&lt;String&gt; pathlist = new ArrayList&lt;String&gt;();
+            // Current directory configuration
+            log4jList.add( &quot;rtspproxy.log4j.&quot; );
 
-			// System wide configuration (tipical in unix systems)
-			pathlist.add(&quot;/etc/rtspproxy.conf.xml&quot;);
-			
-			// Per user config
-			pathlist.add(System.getProperty( &quot;user.home&quot;, &quot;&quot; ) + &quot;/.rtspproxy.conf.xml&quot;);
+            // Used for testing purposes:
+            // checks for the configuration file
+            log4jList.add( &quot;src/resources/conf/rtspproxy.log4j.&quot; );
 
-			// RtspProxy home folder
-			if(Config.getHome() != null)
-				pathlist.add(Config.getHome() + &quot;/conf/rtspproxy.conf.xml&quot;);
+            for ( String path : log4jList ) {
+                File propFile = new File( path + &quot;properties&quot; );
+                File xmlFile = new File( path + &quot;xml&quot; );
 
-			// Current directory configuration
-			pathlist.add(&quot;rtspproxy.conf.xml&quot;);
+                if ( propFile.canRead() ) {
+                    PropertyConfigurator.configure( propFile.toURL() );
+                    
+                } else if ( xmlFile.canRead() ) {
+                    DOMConfigurator.configure( xmlFile.toURL() );
+                }
+            }
 
-			// Used for testing purposes:
-			// checks for the configuration file
-			pathlist.add(&quot;src/resources/conf/rtspproxy.conf.xml&quot;);
+            List&lt;String&gt; pathlist = new ArrayList&lt;String&gt;();
 
-			XMLConfigReader configReader = new XMLConfigReader();
-			
-			for ( String path : pathlist ) {
-				configReader.readConfig(path);
-			}
+            // System wide configuration (tipical in unix systems)
+            pathlist.add( &quot;/etc/rtspproxy.conf.xml&quot; );
 
-			if ( log.isDebugEnabled() ) {
-				log.debug( Config.debugParameters() );
-			}
-			
-			Reactor.setStandalone( true );
-			Reactor.start();
+            // Per user config
+            pathlist.add( System.getProperty( &quot;user.home&quot;, &quot;&quot; ) + &quot;/.rtspproxy.conf.xml&quot; );
 
-		} catch ( Exception e ) {
-			log.fatal( &quot;Exception in the reactor: &quot;, e );
-			Exceptions.logStackTrace( e );
-			System.exit( -1 );
-		}
-	}
+            // RtspProxy home folder
+            if ( Config.getHome() != null )
+                pathlist.add( Config.getHome() + &quot;/conf/rtspproxy.conf.xml&quot; );
 
+            // Current directory configuration
+            pathlist.add( &quot;rtspproxy.conf.xml&quot; );
+
+            // Used for testing purposes:
+            // checks for the configuration file
+            pathlist.add( &quot;src/resources/conf/rtspproxy.conf.xml&quot; );
+
+            XMLConfigReader configReader = new XMLConfigReader();
+
+            for ( String path : pathlist ) {
+                configReader.readConfig( path );
+            }
+
+            if ( log.isDebugEnabled() ) {
+                log.debug( Config.debugParameters() );
+            }
+
+            Reactor.setStandalone( true );
+            Reactor.start();
+
+        } catch ( Exception e ) {
+            log.fatal( &quot;Exception in the reactor: &quot;, e );
+            Exceptions.logStackTrace( e );
+            System.exit( -1 );
+        }
+    }
+
 }

Modified: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -17,69 +17,72 @@
 /**
  * @author Matteo Merli
  */
-public class SimpleAccountingProvider extends AccountingProviderAdapter 
-implements AccountingProvider,  AAAConfigurable
+public class SimpleAccountingProvider extends AccountingProviderAdapter implements
+        AccountingProvider, AAAConfigurable
 {
 
-	private static String datePattern = &quot;yyyy-MM-dd HH:mm:ss Z&quot;;
-	private static SimpleDateFormat format = new SimpleDateFormat( datePattern );
+    private static SimpleDateFormat format = new SimpleDateFormat(
+            &quot;yyyy-MM-dd HH:mm:ss Z&quot; );
 
-	// This is not static since it's a separate log
-	private Logger accessLog;
+    // This is not static since it's a separate log
+    private Logger accessLog;
 
-	public SimpleAccountingProvider()
-	{
-		accessLog = Logger.getLogger( &quot;accessLog&quot; );
-	}
+    public SimpleAccountingProvider()
+    {
+        accessLog = Logger.getLogger( &quot;accessLog&quot; );
+    }
 
-	public void messageReceived( IoSession session, RtspMessage message )
-	{
-		StringBuilder logMessage = new StringBuilder();
-		if ( message instanceof RtspRequest ) {
-			logMessage.append( ( (RtspRequest) message ).getVerb() ).append( &quot; &quot; );
-			logMessage.append( ( (RtspRequest) message ).getUrl() );
-		}
-		accessLog.info( buildLogMessage( session, message, logMessage ) );
-	}
+    @Override
+    public void messageReceived( IoSession session, RtspMessage message )
+    {
+        StringBuilder logMessage = new StringBuilder();
+        if ( message instanceof RtspRequest ) {
+            logMessage.append( ((RtspRequest) message).getVerb() ).append( &quot; &quot; );
+            logMessage.append( ((RtspRequest) message).getUrl() );
+        }
+        accessLog.info( buildLogMessage( session, message, logMessage ) );
+    }
 
-	public void messageSent( IoSession session, RtspMessage message )
-	{
-		StringBuilder logMessage = new StringBuilder();
-		accessLog.info( buildLogMessage( session, message, logMessage ) );
-	}
+    @Override
+    public void messageSent( IoSession session, RtspMessage message )
+    {
+        StringBuilder logMessage = new StringBuilder();
+        accessLog.info( buildLogMessage( session, message, logMessage ) );
+    }
 
+    private static String buildLogMessage( IoSession session, RtspMessage message,
+            StringBuilder logMessage )
+    {
+        StringBuilder sb = new StringBuilder( 150 );
+        String userName = (String) session.getAttribute( AuthenticationFilter.ATTR );
+        String userAgent = message.getHeader( &quot;User-Agent&quot; );
+        Date now = new Date();
+        String dateString = format.format( now );
 
-	private static String buildLogMessage( IoSession session, RtspMessage message,
-			StringBuilder logMessage )
-	{
-		StringBuilder sb = new StringBuilder( 150 );
-		String userName = (String) session.getAttribute( AuthenticationFilter.ATTR );
-		String userAgent = message.getHeader( &quot;User-Agent&quot; );
-		Date now = new Date();
-		String dateString = format.format( now );
+        sb.append( ((InetSocketAddress) session.getRemoteAddress()).getAddress()
+                .getHostAddress() );
+        sb.append( &quot; - &quot; );
+        sb.append( userName != null ? userName : '-' ).append( ' ' );
+        sb.append( '[' ).append( dateString ).append( &quot;] &quot; );
+        sb.append( '&quot;' ).append( logMessage ).append( &quot;\&quot; &quot; );
+        if ( userAgent != null ) {
+            sb.append( '&quot;' ).append( userAgent ).append( &quot;\&quot; &quot; );
+        }
 
-		sb.append( ( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getHostAddress() );
-		sb.append( &quot; - &quot; );
-		sb.append( userName != null ? userName : &quot;-&quot; ).append( &quot; &quot; );
-		sb.append( &quot;[&quot; ).append( dateString ).append( &quot;] &quot; );
-		sb.append( &quot;\&quot;&quot; ).append( logMessage ).append( &quot;\&quot; &quot; );
-		if ( userAgent != null ) {
-			sb.append( &quot;\&quot;&quot; ).append( userAgent ).append( &quot;\&quot; &quot; );
-		}
+        return sb.toString();
+    }
 
-		return sb.toString();
-	}
+    public void configure( List&lt;Element&gt; configElements ) throws Exception
+    {
+        for ( Element el : configElements ) {
+            if ( el.getName().equals( &quot;category&quot; ) ) {
+                String category = el.getTextTrim();
 
-	public void configure(List&lt;Element&gt; configElements) throws Exception {
-		for(Element el : configElements) {
-			if(el.getName().equals(&quot;category&quot;)) {
-				String category = el.getTextTrim();
-				
-				if(category == null || category.length() == 0) 					
-					throw new IllegalArgumentException(&quot;invalid log category given&quot;);
-				
-				accessLog = Logger.getLogger(category);
-			}
-		}
-	}
+                if ( category == null || category.length() == 0 )
+                    throw new IllegalArgumentException( &quot;invalid log category given&quot; );
+
+                accessLog = Logger.getLogger( category );
+            }
+        }
+    }
 }

Modified: trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml
===================================================================
--- trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,83 +1,178 @@
+&lt;!-- $Id$ --&gt;
+
 &lt;rtspproxy&gt;
-  &lt;threadPoolSize&gt;10&lt;/threadPoolSize&gt;
-  &lt;proxy&gt;
-    &lt;rtspPort&gt;554&lt;/rtspPort&gt;
-	&lt;server&gt;
-		&lt;rtpPort&gt;6970&lt;/rtpPort&gt;
-		&lt;rtcpPort&gt;6971&lt;/rtcpPort&gt;
-		&lt;rdtPort&gt;6972&lt;/rdtPort&gt;
-		&lt;address&gt;10.0.0.24&lt;/address&gt;
-		&lt;!-- interface&gt;eth0&lt;/interface --&gt;
-		&lt;rtpUsePortrange&gt;false&lt;/rtpUsePortrange&gt;
-		&lt;rtpPortrange&gt;
-			&lt;minPort&gt;9000&lt;/minPort&gt;
-			&lt;maxPort&gt;9100&lt;/maxPort&gt;
-			&lt;idleTimeout&gt;120&lt;/idleTimeout&gt;
-			&lt;idleScanInterval&gt;60&lt;/idleScanInterval&gt;
-			&lt;threadPoolSize&gt;10&lt;/threadPoolSize&gt;
-		&lt;/rtpPortrange&gt;
-	&lt;/server&gt;
-    &lt;client&gt;
-      &lt;rtpPort&gt;6970&lt;/rtpPort&gt;
-      &lt;rtcpPort&gt;6971&lt;/rtcpPort&gt;
-      &lt;rdtPort&gt;6972&lt;/rdtPort&gt;
-      &lt;address&gt;10.0.0.23&lt;/address&gt;
-      &lt;!-- interface&gt;eth1&lt;/interface --&gt;
-    &lt;/client&gt;
-	&lt;transport&gt;
-		&lt;rtp&gt;true&lt;/rtp&gt;
-		&lt;rdt&gt;true&lt;/rdt&gt;
-		&lt;hacks&gt;
-			&lt;lowerTransportSuppress&gt;false&lt;/lowerTransportSuppress&gt;
-			&lt;offerRemoteSsrc&gt;false&lt;/offerRemoteSsrc&gt;
-		&lt;/hacks&gt;
-	&lt;/transport&gt;
-	&lt;streaming&gt;
-		&lt;hacks&gt;
-			&lt;rtpSsrcUnreliable&gt;false&lt;/rtpSsrcUnreliable&gt;
-		&lt;/hacks&gt;
-	&lt;/streaming&gt;
-  &lt;/proxy&gt;
-  &lt;jmx&gt;
-    &lt;manageable&gt;true&lt;/manageable&gt;
-    &lt;address&gt;10.0.0.22&lt;/address&gt;
-    &lt;user&gt;admin&lt;/user&gt;
-    &lt;password&gt;admin123&lt;/password&gt;
-    &lt;web&gt;
-      &lt;manageable&gt;true&lt;/manageable&gt;
-      &lt;port&gt;8080&lt;/port&gt;
-    &lt;/web&gt;
-    &lt;connectorService&gt;
-      &lt;manageable&gt;true&lt;/manageable&gt;
-    &lt;/connectorService&gt;
-  &lt;/jmx&gt;
-  &lt;filters&gt;
-    &lt;authentication implClass=&quot;rtspproxy.filter.authentication.SimpleAuthenticationProvider&quot; scheme=&quot;Digest&quot; side=&quot;client&quot;&gt;
-      &lt;user&gt;
-	&lt;name&gt;myuser&lt;/name&gt;
-	&lt;password&gt;itspassword&lt;/password&gt;
-      &lt;/user&gt;
-    &lt;/authentication&gt;
-    &lt;ipaddress implClass=&quot;rtspproxy.filter.ipaddress.SimpleIpAddressProvider&quot; side=&quot;client&quot;&gt;
-      &lt;deny&gt;*&lt;/deny&gt;
-      &lt;allow&gt;127.0.0.1&lt;/allow&gt;
-      &lt;allow&gt;10.0.0.*&lt;/allow&gt;
-      &lt;allow&gt;*.some.domain&lt;/allow&gt;
-    &lt;/ipaddress&gt;
-    &lt;ipaddress implClass=&quot;rtspproxy.filter.ipaddress.SimpleIpAddressProvider&quot; side=&quot;server&quot;&gt;
-      &lt;deny&gt;*&lt;/deny&gt;
-      &lt;allow&gt;127.0.0.1&lt;/allow&gt;
-      &lt;allow&gt;10.0.0.*&lt;/allow&gt;
-      &lt;allow&gt;*.some.domain&lt;/allow&gt;
-    &lt;/ipaddress&gt;
-    &lt;accounting implClass=&quot;rtspproxy.filter.accounting.SimpleAccountingProvider&quot; &gt;
-      &lt;category&gt;accounting.rtspproxy&lt;/category&gt;
-    &lt;/accounting&gt;
-	&lt;rewriting implClass=&quot;rtspproxy.filter.rewrite.SimpleUrlRewritingProvider&quot; side=&quot;client&quot;&gt;
-		&lt;mapping&gt;
-			&lt;from&gt;<A HREF="rtsp://10.0.0.1:554/&lt;/from">rtsp://10.0.0.1:554/&lt;/from</A>&gt;
-			&lt;to&gt;<A HREF="rtsp://10.0.0.2:1554/foo/&lt;/to">rtsp://10.0.0.2:1554/foo/&lt;/to</A>&gt;
-		&lt;/mapping&gt;
-	&lt;/rewriting&gt;
-  &lt;/filters&gt;
+
+	&lt;debug&gt;true&lt;/debug&gt;
+
+	&lt;!-- Thread pool configuration. Number of active threads. --&gt;
+	&lt;threadPoolSize&gt;10&lt;/threadPoolSize&gt;
+
+	&lt;proxy&gt;
+
+		&lt;!-- TCP port to be used for incoming RTSP connection from clients. --&gt;
+		&lt;rtspPort&gt;5540&lt;/rtspPort&gt;
+
+		&lt;!-- Server-side configuration --&gt;
+		&lt;server&gt;
+			&lt;!-- &lt;rtpPort&gt;6970&lt;/rtpPort&gt; --&gt;
+			&lt;!-- &lt;rtcpPort&gt;6971&lt;/rtcpPort&gt; --&gt;
+			&lt;!-- &lt;rdtPort&gt;6972&lt;/rdtPort&gt; --&gt;
+			&lt;!-- &lt;address&gt;10.0.0.24&lt;/address&gt; --&gt;
+
+			&lt;!-- 
+				&lt;rtpUsePortrange&gt;false&lt;/rtpUsePortrange&gt;
+				
+				&lt;rtpPortrange&gt;
+				&lt;minPort&gt;9000&lt;/minPort&gt;
+				&lt;maxPort&gt;9100&lt;/maxPort&gt;
+				&lt;idleTimeout&gt;120&lt;/idleTimeout&gt;
+				&lt;idleScanInterval&gt;60&lt;/idleScanInterval&gt;
+				&lt;threadPoolSize&gt;10&lt;/threadPoolSize&gt;
+				&lt;/rtpPortrange&gt;
+			--&gt;
+		&lt;/server&gt;
+
+
+		&lt;client&gt;
+			&lt;!-- 
+				&lt;rtpPort&gt;6970&lt;/rtpPort&gt;
+				&lt;rtcpPort&gt;6971&lt;/rtcpPort&gt;
+				&lt;rdtPort&gt;6972&lt;/rdtPort&gt;
+				&lt;address&gt;127.0.0.1&lt;/address&gt;
+			--&gt;
+			&lt;interface&gt;lo0&lt;/interface&gt;
+		&lt;/client&gt;
+
+		&lt;!-- Proxy feature selection --&gt;
+		&lt;transport&gt;
+			&lt;!-- Enable RTP based streaming --&gt;
+			&lt;rtp&gt;true&lt;/rtp&gt;
+
+			&lt;!-- Enable Real/RDT based streaming --&gt;
+			&lt;rdt&gt;true&lt;/rdt&gt;
+
+			&lt;!-- These are some special case handling --&gt;
+			&lt;hacks&gt;
+				&lt;lowerTransportSuppress&gt;false&lt;/lowerTransportSuppress&gt;
+				&lt;offerRemoteSsrc&gt;false&lt;/offerRemoteSsrc&gt;
+				&lt;rtpSsrcUnreliable&gt;false&lt;/rtpSsrcUnreliable&gt;
+			&lt;/hacks&gt;
+
+		&lt;/transport&gt;
+
+	&lt;/proxy&gt;
+
+	&lt;!-- Management Interface --&gt;
+	&lt;jmx&gt;
+		&lt;!-- Enable or disable the JMX interface --&gt;
+		&lt;enable&gt;true&lt;/enable&gt;
+
+		&lt;!-- Bound the JMX service to a local address. --&gt;
+		&lt;address&gt;127.0.0.1&lt;/address&gt;
+
+		&lt;!-- Username and password to access the management interfaces --&gt;
+		&lt;user&gt;admin&lt;/user&gt;
+		&lt;password&gt;password&lt;/password&gt;
+
+		&lt;!-- JMX web console --&gt;
+		&lt;web&gt;
+			&lt;enable&gt;true&lt;/enable&gt;
+			&lt;port&gt;8080&lt;/port&gt;
+		&lt;/web&gt;
+
+		&lt;!-- JMX remote service --&gt;
+		&lt;connectorService&gt;
+			&lt;!-- Enable or disable the TCP connector for JMX --&gt;
+			&lt;enable&gt;true&lt;/enable&gt;
+		&lt;/connectorService&gt;
+	&lt;/jmx&gt;
+
+	&lt;!-- Filters are the mean layered functionalities such as Authentication or 
+		Tracking are implemented.
+	--&gt;
+	&lt;filters&gt;
+
+		&lt;!-- Authentication filter --&gt;
+		&lt;authentication&gt;
+
+			&lt;enable&gt;false&lt;/enable&gt;
+
+			&lt;implClass&gt;
+				rtspproxy.filter.authentication.SimpleAuthenticationProvider
+			&lt;/implClass&gt;
+
+			&lt;!-- Authentication Scheme: 
+				can be 'Basic' or 'Digest'
+			--&gt;
+			&lt;scheme&gt;Digest&lt;/scheme&gt;
+
+			&lt;usersFile&gt;conf/users.properties&lt;/usersFile&gt;
+		&lt;/authentication&gt;
+
+		&lt;!-- Filter clients using theyr IP address --&gt;
+		&lt;ipaddress
+			implClass=&quot;rtspproxy.filter.ipaddress.SimpleIpAddressProvider&quot;
+			side=&quot;client&quot;&gt;
+
+			&lt;!-- Enable or disable the ipaddress filter --&gt;
+			&lt;enabled&gt;false&lt;/enabled&gt;
+
+			&lt;rules&gt;
+				&lt;rule type=&quot;deny&quot; pattern=&quot;*&quot; /&gt;
+				&lt;allow&gt;127.0.0.1&lt;/allow&gt;
+				&lt;allow&gt;10.0.0.*&lt;/allow&gt;
+				&lt;allow&gt;*.some.domain&lt;/allow&gt;
+			&lt;/rules&gt;
+		&lt;/ipaddress&gt;
+
+		&lt;ipaddress
+			implClass=&quot;rtspproxy.filter.ipaddress.SimpleIpAddressProvider&quot;
+			side=&quot;server&quot;&gt;
+
+			&lt;!-- Enable or disable the ipaddress filter --&gt;
+			&lt;enable&gt;false&lt;/enable&gt;
+
+			&lt;rules&gt;
+				&lt;deny&gt;*&lt;/deny&gt;
+				&lt;allow&gt;127.0.0.1&lt;/allow&gt;
+				&lt;allow&gt;10.0.0.*&lt;/allow&gt;
+				&lt;allow&gt;*.some.domain&lt;/allow&gt;
+			&lt;/rules&gt;
+		&lt;/ipaddress&gt;
+
+
+		&lt;accounting&gt;
+
+			&lt;!-- Enable or disable the ipaddress filter --&gt;
+			&lt;enable&gt;false&lt;/enable&gt;
+
+			&lt;implClass&gt;
+				rtspproxy.filter.accounting.SimpleAccountingProvider
+			&lt;/implClass&gt;
+
+			&lt;category&gt;accounting.rtspproxy&lt;/category&gt;
+		&lt;/accounting&gt;
+
+
+		&lt;rewriting&gt;
+
+			&lt;!-- enable or disable the rewriting filter --&gt;
+			&lt;enable&gt;false&lt;/enable&gt;
+
+			&lt;!-- Class implementing the rewriting filter --&gt;
+			&lt;implClass&gt;
+				rtspproxy.filter.rewrite.SimpleUrlRewritingProvider
+			&lt;/implClass&gt;
+
+			&lt;!-- Rewriting rules --&gt;
+			&lt;rules&gt;
+				&lt;mapping from=&quot;<A HREF="rtsp://10.0.0.1:554/">rtsp://10.0.0.1:554/</A>&quot;
+					       to=&quot;<A HREF="rtsp://10.0.0.2:1554/foo/">rtsp://10.0.0.2:1554/foo/</A>&quot; /&gt;
+
+				&lt;mapping from=&quot;<A HREF="rtsp://127.0.0.01/">rtsp://127.0.0.01/</A>&quot; 
+					 		   to=&quot;<A HREF="rtsp://10.0.0.26:1554/foo/">rtsp://10.0.0.26:1554/foo/</A>&quot; /&gt;
+			&lt;/rules&gt;
+		&lt;/rewriting&gt;
+	&lt;/filters&gt;
+
 &lt;/rtspproxy&gt;

Modified: trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml
===================================================================
--- trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml	2006-04-14 15:41:06 UTC (rev 415)
@@ -10,69 +10,80 @@
 &lt;!-- $Id$ --&gt;
 
 &lt;!--
-   | For more configuration infromation and examples see the Jakarta Log4j
-   | owebsite: <A HREF="http://jakarta.apache.org/log4j">http://jakarta.apache.org/log4j</A>
- --&gt;
+	| For more configuration infromation and examples see the Jakarta Log4j
+	| owebsite: <A HREF="http://jakarta.apache.org/log4j">http://jakarta.apache.org/log4j</A>
+--&gt;
 
-&lt;log4j:configuration xmlns:log4j=&quot;<A HREF="http://jakarta.apache.org/log4j/">http://jakarta.apache.org/log4j/</A>&quot; debug=&quot;false&quot;&gt;
+&lt;log4j:configuration xmlns:log4j=&quot;<A HREF="http://jakarta.apache.org/log4j/">http://jakarta.apache.org/log4j/</A>&quot;
+	debug=&quot;false&quot;&gt;
 
-   &lt;!-- ================================= --&gt;
-   &lt;!-- Preserve messages in a local file --&gt;
-   &lt;!-- ================================= --&gt;
+	&lt;!-- ================================= --&gt;
+	&lt;!-- Preserve messages in a local file --&gt;
+	&lt;!-- ================================= --&gt;
 
-   &lt;!-- A time/date based rolling appender --&gt;
-   &lt;appender name=&quot;FILE&quot; class=&quot;org.apache.log4j.FileAppender&quot;&gt;
-      &lt;param name=&quot;File&quot; value=&quot;/tmp/rtspproxy.log&quot;/&gt;
-      &lt;param name=&quot;Append&quot; value=&quot;false&quot;/&gt;
+	&lt;!-- A time/date based rolling appender --&gt;
+	&lt;appender name=&quot;FILE&quot; class=&quot;org.apache.log4j.FileAppender&quot;&gt;
+		&lt;param name=&quot;File&quot; value=&quot;/tmp/rtspproxy.log&quot; /&gt;
+		&lt;param name=&quot;Append&quot; value=&quot;false&quot; /&gt;
 
-      &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
-         &lt;!-- The default pattern: Date Priority [Category] Message\n --&gt;
-         &lt;param name=&quot;ConversionPattern&quot; value=&quot;%9r %5p [%t] %c - %m%n&quot;/&gt;
+		&lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
+			&lt;!-- The default pattern: Date Priority [Category] Message\n --&gt;
+			&lt;param name=&quot;ConversionPattern&quot;
+				value=&quot;%9r %5p [%t] %c - %m%n&quot; /&gt;
 
-         &lt;!-- The full pattern: Date MS Priority [Category] (Thread:NDC) Message\n
-         &lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5r %-5p [%c] (%t:%x) %m%n&quot;/&gt;
-          --&gt;
-      &lt;/layout&gt;
-   &lt;/appender&gt;
+			&lt;!-- The full pattern: Date MS Priority [Category] (Thread:NDC) Message\n
+				&lt;param name=&quot;ConversionPattern&quot; value=&quot;%d %-5r %-5p [%c] (%t:%x) %m%n&quot;/&gt;
+			--&gt;
+		&lt;/layout&gt;
+	&lt;/appender&gt;
 
-   &lt;!-- A time/date based rolling appender --&gt;
-   &lt;appender name=&quot;ACCOUNTING&quot; class=&quot;org.apache.log4j.FileAppender&quot;&gt;
-      &lt;param name=&quot;File&quot; value=&quot;/tmp/rtspproxy-accounting.log&quot;/&gt;
-      &lt;param name=&quot;Append&quot; value=&quot;true&quot;/&gt;
+	&lt;!-- A time/date based rolling appender --&gt;
+	&lt;appender name=&quot;ACCOUNTING&quot; class=&quot;org.apache.log4j.FileAppender&quot;&gt;
+		&lt;param name=&quot;File&quot; value=&quot;/tmp/rtspproxy-accounting.log&quot; /&gt;
+		&lt;param name=&quot;Append&quot; value=&quot;true&quot; /&gt;
 
-      &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
-         &lt;!-- The default pattern: Date Priority [Category] Message\n --&gt;
-         &lt;param name=&quot;ConversionPattern&quot; value=&quot;%m%n&quot;/&gt;
-      &lt;/layout&gt;
-   &lt;/appender&gt;
+		&lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
+			&lt;!-- The default pattern: Date Priority [Category] Message\n --&gt;
+			&lt;param name=&quot;ConversionPattern&quot; value=&quot;%m%n&quot; /&gt;
+		&lt;/layout&gt;
+	&lt;/appender&gt;
 
-   &lt;!-- ============================== --&gt;
-   &lt;!-- Append messages to the console --&gt;
-   &lt;!-- ============================== --&gt;
+	&lt;!-- ============================== --&gt;
+	&lt;!-- Append messages to the console --&gt;
+	&lt;!-- ============================== --&gt;
 
-   &lt;appender name=&quot;CONSOLE&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;
-      &lt;param name=&quot;Target&quot; value=&quot;System.out&quot;/&gt;
-      &lt;param name=&quot;Threshold&quot; value=&quot;INFO&quot;/&gt;
+	&lt;appender name=&quot;CONSOLE&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;
+		&lt;param name=&quot;Target&quot; value=&quot;System.out&quot; /&gt;
 
-      &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
-         &lt;!-- The default pattern: Date Priority [Category] Message\n --&gt;
-         &lt;param name=&quot;ConversionPattern&quot; value=&quot;%9r %5p [%t] %c - %m%n&quot;/&gt;
-      &lt;/layout&gt;
-   &lt;/appender&gt;
+		&lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;
+			&lt;!-- The default pattern: Date Priority [Category] Message\n --&gt;
+			&lt;param name=&quot;ConversionPattern&quot;
+				value=&quot;%9r %5p [%t] %c - %m%n&quot; /&gt;
+		&lt;/layout&gt;
+	&lt;/appender&gt;
 
-   &lt;category name=&quot;accounting.rtspproxy&quot; &gt;
-      &lt;priority value=&quot;INFO&quot; /&gt;
-      &lt;appender-ref ref=&quot;ACCOUNTING&quot; /&gt;
-   &lt;/category&gt;
+	&lt;category name=&quot;accounting.rtspproxy&quot;&gt;
+		&lt;priority value=&quot;INFO&quot; /&gt;
+		&lt;appender-ref ref=&quot;ACCOUNTING&quot; /&gt;
+	&lt;/category&gt;
+	
+	&lt;category name=&quot;rtspproxy.rtsp.RtspDecoder&quot;&gt;
+		&lt;priority value=&quot;INFO&quot; /&gt;
+	&lt;/category&gt;
+	
+	&lt;category name=&quot;rtspproxy.ProxyService&quot;&gt;
+		&lt;priority value=&quot;INFO&quot; /&gt;
+	&lt;/category&gt;
 
-   &lt;!-- ======================= --&gt;
-   &lt;!-- Setup the Root category --&gt;
-   &lt;!-- ======================= --&gt;
+	&lt;!-- ======================= --&gt;
+	&lt;!-- Setup the Root category --&gt;
+	&lt;!-- ======================= --&gt;
 
-   &lt;root&gt;
-      &lt;priority value=&quot;DEBUG&quot;/&gt;
-      &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
-      &lt;appender-ref ref=&quot;FILE&quot;/&gt;
-   &lt;/root&gt;
+	&lt;root&gt;
+		&lt;priority value=&quot;INFO&quot; /&gt;
+		
+		&lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;
+		&lt;!-- appender-ref ref=&quot;FILE&quot; / --&gt;
+	&lt;/root&gt;
 
 &lt;/log4j:configuration&gt;

Added: trunk/RTSPProxy-App/src/resources/conf/user.properties
===================================================================
--- trunk/RTSPProxy-App/src/resources/conf/user.properties	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/resources/conf/user.properties	2006-04-14 15:41:06 UTC (rev 415)
@@ -0,0 +1,7 @@
+
+## User Databases
+# 
+# Insert users in the form: 
+
+user: password
+joe: test


Property changes on: trunk/RTSPProxy-App/src/resources/conf/user.properties
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java
===================================================================
--- trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -20,8 +20,6 @@
 import java.io.StringReader;
 import java.net.InetAddress;
 
-import rtspproxy.filter.ipaddress.SimpleIpAddressProvider;
-
 import junit.framework.TestCase;
 
 /**


Property changes on: trunk/RTSPProxy-Core
___________________________________________________________________
Name: svn:ignore
   + 
target


Modified: trunk/RTSPProxy-Core/pom.xml
===================================================================
--- trunk/RTSPProxy-Core/pom.xml	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/pom.xml	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,12 +6,13 @@
 		$Id$
 		$URL$
 	--&gt;
-        &lt;parent&gt;
-                &lt;groupId&gt;net.merlimat&lt;/groupId&gt;
-                &lt;artifactId&gt;rtspproxy&lt;/artifactId&gt;
-                &lt;version&gt;3.0-ALPHA5-SNAPSHOT&lt;/version&gt;
-        &lt;/parent&gt;
 
+	&lt;parent&gt;
+		&lt;groupId&gt;net.merlimat&lt;/groupId&gt;
+		&lt;artifactId&gt;rtspproxy&lt;/artifactId&gt;
+		&lt;version&gt;3.0-ALPHA5-SNAPSHOT&lt;/version&gt;
+	&lt;/parent&gt;
+
 	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
 
 	&lt;name&gt;RTSP Proxy core&lt;/name&gt;
@@ -22,32 +23,51 @@
 	&lt;inceptionYear&gt;2003&lt;/inceptionYear&gt;
 
 	&lt;dependencies&gt;
-		
+
 		&lt;dependency&gt;
-			&lt;groupId&gt;directory-network&lt;/groupId&gt;
-			&lt;artifactId&gt;mina&lt;/artifactId&gt;
-			&lt;version&gt;0.9.0&lt;/version&gt;
+			&lt;groupId&gt;org.apache.directory.mina&lt;/groupId&gt;
+			&lt;artifactId&gt;mina-core&lt;/artifactId&gt;
+			&lt;version&gt;0.9.3&lt;/version&gt;
 		&lt;/dependency&gt;
-		
+
 		&lt;dependency&gt;
 			&lt;groupId&gt;mx4j&lt;/groupId&gt;
 			&lt;artifactId&gt;mx4j-tools&lt;/artifactId&gt;
 			&lt;version&gt;2.1.1&lt;/version&gt;
 		&lt;/dependency&gt;
-		
+
 		&lt;dependency&gt;
-			&lt;groupId&gt;dom4j&lt;/groupId&gt;
-			&lt;artifactId&gt;dom4j&lt;/artifactId&gt;
-			&lt;version&gt;1.6.1&lt;/version&gt;
+			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
+			&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
+			&lt;version&gt;1.0-rc3&lt;/version&gt;
 		&lt;/dependency&gt;
-		
+
 		&lt;dependency&gt;
+			&lt;groupId&gt;log4j&lt;/groupId&gt;
+			&lt;artifactId&gt;log4j&lt;/artifactId&gt;
+			&lt;version&gt;1.2.9&lt;/version&gt;
+		&lt;/dependency&gt;
+ 
+		&lt;dependency&gt;
 			&lt;groupId&gt;commons-pool&lt;/groupId&gt;
 			&lt;artifactId&gt;commons-pool&lt;/artifactId&gt;
 			&lt;version&gt;1.2&lt;/version&gt;
 		&lt;/dependency&gt;
+
+		&lt;dependency&gt;
+			&lt;groupId&gt;commons-configuration&lt;/groupId&gt;
+			&lt;artifactId&gt;commons-configuration&lt;/artifactId&gt;
+			&lt;version&gt;1.2&lt;/version&gt;
+		&lt;/dependency&gt;
 		
+		&lt;!-- Included here to disambiguate the version number --&gt;
 		&lt;dependency&gt;
+			&lt;groupId&gt;commons-collections&lt;/groupId&gt;
+			&lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
+			&lt;version&gt;3.1&lt;/version&gt;
+		&lt;/dependency&gt;
+
+		&lt;dependency&gt;
 			&lt;groupId&gt;junit&lt;/groupId&gt;
 			&lt;artifactId&gt;junit&lt;/artifactId&gt;
 			&lt;version&gt;3.8.1&lt;/version&gt;
@@ -56,16 +76,25 @@
 	&lt;/dependencies&gt;
 
 	&lt;repositories&gt;
-&lt;!--
+
 		&lt;repository&gt;
-		&lt;id&gt;Apache repository&lt;/id&gt;
-		&lt;url&gt;<A HREF="http://svn.apache.org/repository/&lt;/url">http://svn.apache.org/repository/&lt;/url</A>&gt;
+			&lt;id&gt;Apache repository&lt;/id&gt;
+			&lt;url&gt;<A HREF="http://svn.apache.org/repository/&lt;/url">http://svn.apache.org/repository/&lt;/url</A>&gt;
 		&lt;/repository&gt;
---&gt;
+
+		&lt;!-- For snapshots (no release jars or non-apache jars)           --&gt;
 		&lt;repository&gt;
-		&lt;id&gt;ibilio maven1&lt;/id&gt;
-		&lt;url&gt;<A HREF="http://www.ibiblio.org/maven/&lt;/url">http://www.ibiblio.org/maven/&lt;/url</A>&gt;
+			&lt;id&gt;apache.snapshots&lt;/id&gt;
+			&lt;name&gt;Apache Snapshot Repository&lt;/name&gt;
+			&lt;url&gt;<A HREF="http://cvs.apache.org/maven-snapshot-repository&lt;/url">http://cvs.apache.org/maven-snapshot-repository&lt;/url</A>&gt;
 		&lt;/repository&gt;
+
+		&lt;!--
+			&lt;repository&gt;
+			&lt;id&gt;ibilio maven2&lt;/id&gt;
+			&lt;url&gt;<A HREF="http://www.ibiblio.org/maven2/&lt;/url">http://www.ibiblio.org/maven2/&lt;/url</A>&gt;
+			&lt;/repository&gt;
+		--&gt;
 	&lt;/repositories&gt;
 
 	&lt;build&gt;

Modified: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -76,7 +76,8 @@
 		return retval.toString();
 	}
 
-	public String toString()
+	@Override
+    public String toString()
 	{
 		return this.encode();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactoryException.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactoryException.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactoryException.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -70,7 +70,8 @@
 	 * 
 	 * @return the error message
 	 */
-	public String getMessage()
+	@Override
+    public String getMessage()
 	{
 		if ( super.getMessage() != null )
 			return super.getMessage();

Modified: trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpParseException.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpParseException.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpParseException.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -77,7 +77,8 @@
 	 * 
 	 * @return the message stored when the exception was created.
 	 */
-	public String getMessage()
+	@Override
+    public String getMessage()
 	{
 		return super.getMessage();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,20 +26,19 @@
 import java.util.Observer;
 import java.util.Set;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.IoAcceptor;
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.common.IoHandler;
 import org.apache.mina.common.IoSession;
 import org.apache.mina.common.TransportType;
 import org.apache.mina.filter.ThreadPoolFilter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.config.Parameter;
 import rtspproxy.lib.Exceptions;
 import rtspproxy.lib.NetworkInterface;
 import rtspproxy.lib.Singleton;
-import rtspproxy.transport.socket.nio.ConnectionlessSessionTracker;
 
 /**
  * ProxyService is the base abstract class for all the &quot;Services&quot; that can be
@@ -50,266 +49,283 @@
 public abstract class ProxyService extends Singleton implements Observer
 {
 
-	private static Logger log = LoggerFactory.getLogger( ProxyService.class );
+    private static Logger log = LoggerFactory.getLogger( ProxyService.class );
 
-	/**
-	 * Main Socket address used by the service. It can be bound on several
-	 * different addresses and network interfaces, but it MUST have a default
-	 * address to be communicated to third parties.
-	 */
-	private InetSocketAddress socketAddress = null;
+    /**
+     * Main Socket address used by the service. It can be bound on several
+     * different addresses and network interfaces, but it MUST have a default
+     * address to be communicated to third parties.
+     */
+    private InetSocketAddress socketAddress = null;
 
-	/**
-	 * Flag used to keep track of the service status.
-	 */
-	private volatile boolean isRunning = false;
+    /**
+     * Flag used to keep track of the service status.
+     */
+    private volatile boolean isRunning = false;
 
-	/**
-	 * Service hook name.
-	 */
-	protected static final String SERVICE = ProxyService.class.getName();
+    /**
+     * Service hook name.
+     */
+    protected static final String SERVICE = ProxyService.class.getName();
 
-	/**
-	 * Starts the service.
-	 * 
-	 * @throws Exception
-	 */
-	public void start() throws Exception
-	{
-		if ( isRunning ) {
-			log.warn( getName() + &quot; is already running.&quot; );
-			return;
-		}
+    /**
+     * Starts the service.
+     * 
+     * @throws Exception
+     */
+    public void start() throws Exception
+    {
+        if ( isRunning ) {
+            log.warn( getName() + &quot; is already running.&quot; );
+            return;
+        }
 
-		int port = getBindPort();
+        int port = getBindPort();
 
-		try {
-			if (getNetworkAddress() != null) {
-				socketAddress = new InetSocketAddress(getNetworkAddress(), port);
-				log.debug(&quot;binding to specific address: &quot; + socketAddress);
+        log.debug( &quot;Service Bind port: {}&quot;, port );
 
-				Reactor.getRegistry().bind(this, getIoHandler(),
-						socketAddress, getFilterChainBuilder());				
-			} else {
-				String netInterface = getNetworkInterface();
+        try {
+            if ( getNetworkAddress() != null ) {
+                socketAddress = new InetSocketAddress( getNetworkAddress(), port );
+                log.debug( &quot;binding to specific address: {}&quot;, socketAddress );
 
-				Set&lt;InetAddress&gt; addressSet = NetworkInterface.getInterfaceAddresses(netInterface);
+                Reactor.getRegistry().bind( this, getIoHandler(), socketAddress,
+                        getFilterChainBuilder() );
 
-				for (InetAddress inetAddress : addressSet) {
-					// Bind to all addresses
+            } else {
+                String netInterface = getNetworkInterface();
 
-					log.debug(&quot;binding to address from set: &quot; + socketAddress);
-					socketAddress = new InetSocketAddress(inetAddress, port);
+                Set&lt;InetAddress&gt; addressSet = NetworkInterface
+                        .getInterfaceAddresses( netInterface );
 
-					Reactor.getRegistry().bind(this, getIoHandler(),
-							socketAddress, getFilterChainBuilder());
+                log.debug( &quot;Network Interface: {} - Addresses: {}&quot;, netInterface,
+                        addressSet );
+                if ( addressSet == null ) {
+                    throw new RuntimeException( &quot;Invalid Network interface: &quot;
+                            + netInterface );
+                }
 
-				}
+                for ( InetAddress inetAddress : addressSet ) {
+                    // Bind to all addresses
 
-				// Choose a bind address
-				InetAddress inetAddress = NetworkInterface
-						.getBindAddress(addressSet);
-				socketAddress = new InetSocketAddress(inetAddress, port);
+                    log.debug( &quot;binding to address from set: {}&quot;, socketAddress );
+                    socketAddress = new InetSocketAddress( inetAddress, port );
 
-			}
-		} catch (IOException e) {
-			log.error(&quot;Can't start &quot; + getName(), e);
-			throw e;
-		}
-		log.info( getName() + &quot; Started - Listening on: &quot; + socketAddress );
+                    Reactor.getRegistry().bind( this, getIoHandler(), socketAddress,
+                            getFilterChainBuilder() );
 
+                }
 
-		isRunning = true;
-	}
+                // Choose a bind address
+                InetAddress inetAddress = NetworkInterface.getBindAddress( addressSet );
+                socketAddress = new InetSocketAddress( inetAddress, port );
 
-	/**
-	 * Stops the service
-	 * 
-	 * @throws Exception
-	 */
-	public void stop() throws Exception
-	{
-		if ( !isRunning ) {
-			log.warn( getName() + &quot; is not running.&quot; );
-			return;
-		}
+            }
+        } catch ( IOException e ) {
+            log.error( &quot;Can't start {}: {}&quot;, getName(), e );
+            throw e;
+        }
+        log.info( &quot;{} Started - Listening on: {}&quot;, getName(), socketAddress );
 
-		log.info( getName() + &quot; Stopped&quot; );
-		isRunning = false;
-	}
+        isRunning = true;
+    }
 
-	/**
-	 * Restart the service.
-	 * 
-	 * @throws Exception
-	 */
-	public void restart() throws Exception
-	{
-		log.info( &quot;Restarting &quot; + getName() );
-		if ( isRunning )
-			stop();
-		else
-			log.warn( getName() + &quot; is not running.&quot; );
+    /**
+     * Stops the service
+     * 
+     * @throws Exception
+     */
+    public void stop() throws Exception
+    {
+        if ( !isRunning ) {
+            log.warn( getName() + &quot; is not running.&quot; );
+            return;
+        }
 
-		start();
-	}
+        log.info( getName() + &quot; Stopped&quot; );
+        isRunning = false;
+    }
 
-	/**
-	 * @return true if the server is running
-	 */
-	public boolean isRunning()
-	{
-		return isRunning;
-	}
+    /**
+     * Restart the service.
+     * 
+     * @throws Exception
+     */
+    public void restart() throws Exception
+    {
+        log.info( &quot;Restarting {}&quot;, getName() );
+        if ( isRunning )
+            stop();
+        else
+            log.warn( getName() + &quot; is not running.&quot; );
 
-	/**
-	 * @return the transport type used by this service
-	 */
-	public abstract TransportType getTransportType();
+        start();
+    }
 
-	/**
-	 * @return an instance to the IoHandler object that will receive all the
-	 *         messages.
-	 */
-	public abstract IoHandler getIoHandler();
+    /**
+     * @return true if the server is running
+     */
+    public boolean isRunning()
+    {
+        return isRunning;
+    }
 
-	/**
-	 * @return the filter chain builder to be be used by the IoAcceptor
-	 *         associated with the service.
-	 */
-	public IoFilterChainBuilder getFilterChainBuilder()
-	{
-		// By default there's no filter chain
-		return IoFilterChainBuilder.NOOP;
-	}
+    /**
+     * @return the transport type used by this service
+     */
+    public abstract TransportType getTransportType();
 
-	/**
-	 * Return the name of the service.
-	 * 
-	 * @return the human readable name
-	 */
-	public abstract String getName();
+    /**
+     * @return an instance to the IoHandler object that will receive all the
+     *         messages.
+     */
+    public abstract IoHandler getIoHandler();
 
-	/**
-	 * Get the network interface to bind to. This is only used if there is no more specific
-	 * IP address configured.
-	 * @return the network interface to bind this service on, as it appears in
-	 *         the configuratio registry (Config).
-	 */
-	public abstract String getNetworkInterface();
+    /**
+     * @return the filter chain builder to be be used by the IoAcceptor
+     *         associated with the service.
+     */
+    public IoFilterChainBuilder getFilterChainBuilder()
+    {
+        // By default there's no filter chain
+        return IoFilterChainBuilder.NOOP;
+    }
 
-	/**
-	 * @return the network address to bind this service on, as it appears in
-	 *         the configuratio registry (Config). If null, the network interface
-	 *         configuration parameter is used.
-	 */
-	public abstract String getNetworkAddress();
+    /**
+     * Return the name of the service.
+     * 
+     * @return the human readable name
+     */
+    public abstract String getName();
 
-	/**
-	 * @return the port to bind on, as it appear in the configuration registry.
-	 */
-	public abstract int getBindPort();
+    /**
+     * Get the network interface to bind to. This is only used if there is no
+     * more specific IP address configured.
+     * 
+     * @return the network interface to bind this service on, as it appears in
+     *         the configuratio registry (Config).
+     */
+    public abstract String getNetworkInterface();
 
-	/**
-	 * @return the Parameter associated with the network interface used by the
-	 *         service.
-	 */
-	public abstract Parameter getNetworkInterfaceParameter();
+    /**
+     * @return the network address to bind this service on, as it appears in the
+     *         configuration registry (Config). If null, the network interface
+     *         configuration parameter is used.
+     */
+    public abstract String getNetworkAddress();
 
-	/**
-	 * @return the Parameter associated with the port number used by the
-	 *         service.
-	 */
-	public abstract Parameter getPortParameter();
+    /**
+     * @return the port to bind on, as it appear in the configuration registry.
+     */
+    public abstract int getBindPort();
 
-	/**
-	 * @return the main IP address where the service is bound.
-	 */
-	public InetAddress getAddress()
-	{
-		return socketAddress.getAddress();
-	}
+    /**
+     * @return the Parameter associated with the network interface used by the
+     *         service.
+     */
+    public abstract Parameter getNetworkInterfaceParameter();
 
-	/**
-	 * @return the main TCP or UDP port where the service is bound.
-	 */
-	public int getPort()
-	{
-		return socketAddress.getPort();
-	}
+    /**
+     * @return the Parameter associated with the port number used by the
+     *         service.
+     */
+    public abstract Parameter getPortParameter();
 
-	/**
-	 * @return the TCP or UDP address (IP+port) where the service is bound.
-	 */
-	public SocketAddress getSocketAddress()
-	{
-		return socketAddress;
-	}
+    /**
+     * @return the main IP address where the service is bound.
+     */
+    public InetAddress getAddress()
+    {
+        return socketAddress.getAddress();
+    }
 
-	/**
-	 * Creates a new connection-less IoSession to a remote address. This is only
-	 * used to create UDP session.
-	 * 
-	 * @param remoteAddress
-	 *            the address of the remote host to connect to.
-	 * @return the newly created IoSession
-	 */
-	public synchronized IoSession newSession( SocketAddress remoteAddress )
-	{
-		IoSession session = null;
-		IoAcceptor acceptor = Reactor.getRegistry().getAcceptor( this );
-		
-		if(acceptor instanceof ConnectionlessSessionTracker)
-			session = ((ConnectionlessSessionTracker)acceptor).getSession(socketAddress, remoteAddress);
-		
-		if(session == null) 
-		 session = acceptor.newSession( remoteAddress, socketAddress );
-		
-		return session;
-	}
+    /**
+     * @return the main TCP or UDP port where the service is bound.
+     */
+    public int getPort()
+    {
+        return socketAddress.getPort();
+    }
 
-	/**
-	 * Update the ProxyService state. A proxy service will likely subscribe to
-	 * some parameter changes notifications. When a change is notified the
-	 * service will be restarted.
-	 * &lt;p&gt;
-	 * &lt;i&gt;NOTE:&lt;/i&gt;
-	 * &lt;ul&gt;
-	 * &lt;li&gt;if the service is TCP based, all connected clients will be
-	 * disconnected! &lt;/li&gt;
-	 * &lt;li&gt;If the service is UDP based some packets may be missed when the
-	 * service is down. &lt;/li&gt;
-	 * &lt;/ul&gt;
-	 * 
-	 * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
-	 */
-	public void update( Observable o, Object arg )
-	{
-		if ( !(o instanceof Parameter) )
-			throw new IllegalArgumentException( &quot;Only observe parameters&quot; );
+    /**
+     * @return the TCP or UDP address (IP+port) where the service is bound.
+     */
+    public SocketAddress getSocketAddress()
+    {
+        return socketAddress;
+    }
 
-		try {
-			restart();
-		} catch ( Exception e ) {
-			log.error( &quot;Error restarting &quot; + getName() );
-			Exceptions.logStackTrace( e );
-			throw new RuntimeException( e );
-		}
-	}
+    /**
+     * Creates a new connection-less IoSession to a remote address. This is only
+     * used to create UDP session.
+     * 
+     * @param remoteAddress
+     *            the address of the remote host to connect to.
+     * @return the newly created IoSession
+     */
+    public synchronized IoSession newSession( SocketAddress remoteAddress )
+    {
+        IoSession session = null;
+        IoAcceptor acceptor = Reactor.getRegistry().getAcceptor( this );
 
-	/**
-	 * service may provide their own ThreadPoolFilter instances.
-	 * @return a ThreadPoolFilter instance or null if the service wants to use the shared instance.
-	 * 
-	 */
-	public ThreadPoolFilter getThreadPoolFilter() {
-		return null;
-	}
-	
-	/**
-	 * flag if the service wants to use a ThreadPoolFilter at all
-	 */
-	public boolean wantThreadPoolFilter() {
-		return true;
-	}
+        // TODO: ConnectionlessSessionTracker
+        // if(acceptor instanceof ConnectionlessSessionTracker)
+        // session =
+        // ((ConnectionlessSessionTracker)acceptor).getSession(socketAddress,
+        // remoteAddress);
+
+        if ( session == null )
+            session = acceptor.newSession( remoteAddress, socketAddress );
+
+        return session;
+    }
+
+    /**
+     * Update the ProxyService state. A proxy service will likely subscribe to
+     * some parameter changes notifications. When a change is notified the
+     * service will be restarted.
+     * &lt;p&gt;
+     * &lt;i&gt;NOTE:&lt;/i&gt;
+     * &lt;ul&gt;
+     * &lt;li&gt;if the service is TCP based, all connected clients will be
+     * disconnected! &lt;/li&gt;
+     * &lt;li&gt;If the service is UDP based some packets may be missed when the
+     * service is down. &lt;/li&gt;
+     * &lt;/ul&gt;
+     * 
+     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
+     */
+    public void update( Observable o, Object arg )
+    {
+        if ( !(o instanceof Parameter) )
+            throw new IllegalArgumentException( &quot;Only observe parameters&quot; );
+
+        try {
+            restart();
+        } catch ( Exception e ) {
+            log.error( &quot;Error restarting {}&quot;, getName() );
+            Exceptions.logStackTrace( e );
+            throw new RuntimeException( e );
+        }
+    }
+
+    /**
+     * service may provide their own ThreadPoolFilter instances.
+     * 
+     * @return a ThreadPoolFilter instance or null if the service wants to use
+     *         the shared instance.
+     * 
+     */
+    public ThreadPoolFilter getThreadPoolFilter()
+    {
+        return null;
+    }
+
+    /**
+     * flag if the service wants to use a ThreadPoolFilter at all
+     */
+    public boolean wantThreadPoolFilter()
+    {
+        return true;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -28,8 +28,6 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.IoAcceptor;
 import org.apache.mina.common.IoFilter;
 import org.apache.mina.common.IoFilterChain;
@@ -37,13 +35,14 @@
 import org.apache.mina.common.IoHandler;
 import org.apache.mina.common.TransportType;
 import org.apache.mina.filter.ThreadPoolFilter;
+import org.apache.mina.transport.socket.nio.DatagramAcceptor;
 import org.apache.mina.transport.socket.nio.SocketAcceptor;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;
 import rtspproxy.lib.Singleton;
-import rtspproxy.transport.socket.nio.DatagramAcceptor;
-import rtspproxy.transport.socket.nio.SessionAwareDatagramAcceptor;
 
 /**
  * Custom implementation of the ServiceRegistry interface. Creates an acceptor
@@ -127,8 +126,8 @@
 		
 		IoFilterChainBuilder builder = new IoFilterChainBuilderWrapper( service,
 				filterChainBuilder );
-		// acceptor.setFilterChainBuilder( builder );
-		acceptor.bind( address, ioHandler, builder );
+		acceptor.setFilterChainBuilder( builder );
+		acceptor.bind( address, ioHandler );
 
 		services.put( service.getName(), service );
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtClientService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtClientService.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtClientService.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -18,13 +18,9 @@
 
 package rtspproxy;
 
-import java.net.SocketAddress;
-
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.common.IoHandler;
-import org.apache.mina.common.IoSession;
 import org.apache.mina.common.TransportType;
-import org.apache.mina.filter.ThreadPoolFilter;
 
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;
@@ -52,7 +48,7 @@
 		super();
 
 		// Subscribe to parameter changes
-		Config.proxyClientInterface.addObserver( this );
+		Config.proxyClientAddress.addObserver( this );
 		Config.proxyClientRdtPort.addObserver( this );
 	}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtServerService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtServerService.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtServerService.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -18,13 +18,9 @@
 
 package rtspproxy;
 
-import java.net.SocketAddress;
-
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.common.IoHandler;
-import org.apache.mina.common.IoSession;
 import org.apache.mina.common.TransportType;
-import org.apache.mina.filter.ThreadPoolFilter;
 
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/Reactor.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/Reactor.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/Reactor.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -86,7 +86,7 @@
 		ProxyService rdtServerService = new RdtServerService();
 		rdtServerService.start();
 
-		boolean enableJmx = Config.proxyManagementEnable.getValue();
+		boolean enableJmx = Config.jmxEnable.getValue();
 		if ( enableJmx )
 			jmxAgent = new JmxAgent();
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/RtspService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/RtspService.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/RtspService.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -20,14 +20,10 @@
 
 import java.util.Observable;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.apache.mina.common.IoAcceptor;
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.common.IoHandler;
 import org.apache.mina.common.TransportType;
 
-import rtspproxy.ProxyServiceRegistry.IoFilterChainBuilderWrapper;
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;
 import rtspproxy.filter.RtspClientFilters;
@@ -39,11 +35,9 @@
  */
 public final class RtspService extends ProxyService
 {
+	
+	private final IoHandler rtspHandler = new ClientSide();
 
-	private static Logger log = LoggerFactory.getLogger( RtspService.class );
-
-	private IoHandler rtspHandler = new ClientSide();
-
 	private final IoFilterChainBuilder filterChainBuilder = new RtspClientFilters();
 
 	private static final String NAME = &quot;RtspService&quot;;
@@ -54,8 +48,8 @@
 
 		// Subscribe to parameter changes
 		Config.proxyClientInterface.addObserver( this );
+        Config.proxyClientAddress.addObserver( this );
 		Config.proxyRtspPort.addObserver( this );
-
 	}
 
 	@Override

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/ShutdownHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/ShutdownHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/ShutdownHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -34,15 +34,16 @@
 
 	private static Logger log = LoggerFactory.getLogger( ShutdownHandler.class );
 
-	public void run()
+	@Override
+    public void run()
 	{
 		log.info( &quot;Shutting down&quot; );
 		try {
-			log.info( &quot;Stopping &quot; + Config.getName() + &quot; &quot; + Config.getVersion() );
+			log.info( &quot;Stopping {} {}&quot;, Config.getName(), Config.getVersion() );
 			Reactor.stop();
 
 		} catch ( Exception e ) {
-			log.error( &quot;Exception in the reactor: &quot; + e );
+			log.error( &quot;Exception in the reactor: &quot;, e );
 			Exceptions.logStackTrace( e );
 		}
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -8,14 +8,20 @@
 import org.dom4j.Element;
 
 /**
- * This interface is implemented by filters which can be configured via the XML 
+ * This interface is implemented by filters which can be configured via the XML
  * mechanism
+ * 
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
  */
-public interface AAAConfigurable {
-	/**
-	 * configure the filter.
-	 * @param configElements a list of dom4j elements containing the actual configuration
-	 */
-	public void configure(List&lt;Element&gt; configElements) throws Exception;
+public interface AAAConfigurable
+{
+
+    /**
+     * configure the filter.
+     * 
+     * @param configElements
+     *            a list of dom4j elements containing the actual configuration
+     */
+    public void configure( List&lt;Element&gt; configElements ) throws Exception;
+    
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/BooleanParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/BooleanParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/BooleanParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,6 +3,8 @@
  */
 package rtspproxy.config;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  */
@@ -14,25 +16,12 @@
 	private boolean defaultValue;
 
 	public BooleanParameter( String name, boolean defaultValue, boolean mutable,
-			String description, String xpathExpr )
+			String description )
 	{
-		super( name, mutable, description, xpathExpr );
+		super( name, mutable, description );
 		this.defaultValue = defaultValue;
 	}
 
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-		value = value.trim().toLowerCase();
-		if ( &quot;true&quot;.equals( value ) || &quot;yes&quot;.equals( value ) )
-			this.value = true;
-		else if ( &quot;false&quot;.equals( value ) || &quot;no&quot;.equals( value ) )
-			this.value = false;
-		else
-			throw new IllegalArgumentException( &quot;Boolean value not valid: &quot; + value );
-
-		setChanged();
-	}
-
 	/**
 	 * @return Returns the defaultValue.
 	 */
@@ -80,4 +69,12 @@
 			setChanged();
 		}
 	}
+    
+
+    @Override
+    public void readConfiguration( Configuration configuration )
+    {
+        boolean value = configuration.getBoolean( name );
+        setObjectValue( value );
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,3 +1,21 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - <A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">matteo.merli at gmail.com</A>            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
+ * 
+ * $URL$
+ * 
+ */
+
 package rtspproxy.config;
 
 import java.util.ArrayList;
@@ -13,516 +31,482 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import org.apache.log4j.Appender;
+import org.apache.log4j.Level;
+import org.apache.log4j.Logger;
+
 import rtspproxy.lib.Singleton;
 import rtspproxy.rtsp.Handler;
 
+/**
+ * 
+ * @author Matteo Merli
+ */
 public class Config extends Singleton implements Observer
 {
 
-	private static ConcurrentMap&lt;String, Parameter&gt; parameters = new ConcurrentHashMap&lt;String, Parameter&gt;();
+    /** Map that contains all the application parameters. */
+    private static ConcurrentMap&lt;String, Parameter&gt; parameters = new ConcurrentHashMap&lt;String, Parameter&gt;();
 
-	protected static void addParameter( Parameter parameter )
-	{
-		parameters.put( parameter.getName(), parameter );
-	}
+    protected static void addParameter( Parameter parameter )
+    {
+        parameters.put( parameter.getName(), parameter );
+    }
 
-	public static Parameter getParameter( String name )
-	{
-		if ( name == null )
-			throw new IllegalArgumentException( &quot;name is null&quot; );
+    public static Parameter getParameter( String name )
+    {
+        if ( name == null )
+            throw new IllegalArgumentException( &quot;name is null&quot; );
 
-		return parameters.get( name );
-	}
+        return parameters.get( name );
+    }
 
-	public static Collection&lt;Parameter&gt; getAllParameters()
-	{
-		return parameters.values();
-	}
+    public static Collection&lt;Parameter&gt; getAllParameters()
+    {
+        return parameters.values();
+    }
 
-	protected static Map&lt;String, Parameter&gt; getParametersMap()
-	{
-		return parameters;
-	}
-	
-	public static final IntegerParameter threadPoolSize = new IntegerParameter(
-			&quot;thread.pool.size&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 2147483647 ), // max value
-			new Integer( 10 ), // default value
-			true, // mutable
-			&quot;Maximum size of the thread pool. The thread pool is shared &quot;
-					+ &quot;between all services found in RtspProxy.&quot;,
-			&quot;/rtspproxy/threadPoolSize&quot; // xpathExpr
-	);
+    protected static Map&lt;String, Parameter&gt; getParametersMap()
+    {
+        return parameters;
+    }
 
-	public static final IntegerParameter proxyRtspPort = new IntegerParameter(
-			&quot;proxy.rtsp.port&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( Handler.DEFAULT_RTSP_PORT ), // default value
-			true, // mutable
-			&quot;This is the port which the proxy will listen for &quot;
-					+ &quot;RTSP connection. The default is 554, like normal RTSP servers.&quot;,
-			&quot;/rtspproxy/proxy/rtspPort&quot; // xpathExpr
-			);
+    public static final BooleanParameter debugEnabled = new BooleanParameter( &quot;debug&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Enables or disable application-wide debug messages.&quot; );
 
-	public static final StringParameter proxyClientInterface = new StringParameter(
-			&quot;proxy.client.interface&quot;, // name
-			null, // default value
-			false, // mutable
-			&quot;Specify a network interface. Default is to listen on all interfaces.&quot; ,
-			&quot;/rtspproxy/proxy/client/interface&quot; // xpathExpr
-			);
+    public static final IntegerParameter threadPoolSize = new IntegerParameter(
+            &quot;threadPoolSize&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 2147483647 ), // max value
+            new Integer( 10 ), // default value
+            true, // mutable
+            &quot;Maximum size of the thread pool. The thread pool is shared &quot;
+                    + &quot;between all services found in RtspProxy.&quot; );
 
-	public static final StringParameter proxyServerInterface = new StringParameter(
-			&quot;proxy.server.interface&quot;, // name
-			null, // default value
-			false, // mutable
-			&quot;Specify a network interface. Default is to listen on all interfaces.&quot;,
-			&quot;/rtspproxy/proxy/server/interface&quot; // pathExpr
-			);
+    public static final IntegerParameter proxyRtspPort = new IntegerParameter(
+            &quot;proxy.rtspPort&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( Handler.DEFAULT_RTSP_PORT ), // default value
+            true, // mutable
+            &quot;This is the port which the proxy will listen for &quot;
+                    + &quot;RTSP connection. The default is 554, like normal RTSP servers.&quot; );
 
-	public static final StringParameter proxyClientAddress = new StringParameter(
-			&quot;proxy.client.address&quot;, // name
-			null, // default value
-			false, // mutable
-			&quot;Specify a network address.&quot; ,
-			&quot;/rtspproxy/proxy/client/address&quot; // xpathExpr
-			);
+    public static final StringParameter proxyClientInterface = new StringParameter(
+            &quot;proxy.client.interface&quot;, // name
+            null, // default value
+            false, // mutable
+            &quot;Specify a network interface. Default is to listen on all interfaces.&quot; );
 
-	public static final StringParameter proxyServerAddress = new StringParameter(
-			&quot;proxy.server.address&quot;, // name
-			null, // default value
-			false, // mutable
-			&quot;Specify a network address.&quot;,
-			&quot;/rtspproxy/proxy/server/address&quot; // pathExpr
-			);
+    public static final StringParameter proxyServerInterface = new StringParameter(
+            &quot;proxy.server.interface&quot;, // name
+            null, // default value
+            false, // mutable
+            &quot;Specify a network interface. Default is to listen on all interfaces.&quot; );
 
-	public static final IntegerParameter proxyServerRtpPort = new IntegerParameter(
-			&quot;proxy.server.rtp.port&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8000 ), // default value
-			true, // mutable
-			&quot;Port to listen for RTP packets arriving from servers.&quot;,
-			&quot;/rtspproxy/proxy/server/rtpPort&quot; // xpathExpr
-			);
+    public static final StringParameter proxyClientAddress = new StringParameter(
+            &quot;proxy.client.address&quot;, // name
+            null, // default value
+            false, // mutable
+            &quot;Specify a network address. Default is to listen on all addresses&quot; );
 
-	public static final IntegerParameter proxyServerRtcpPort = new IntegerParameter(
-			&quot;proxy.server.rtcp.port&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8001 ), // default value
-			true, // mutable
-			&quot;Port to listen for RTCP packets arriving from servers.&quot;,
-			&quot;/rtspproxy/proxy/server/rtcpPort&quot; // xpathExpr
-			);
+    public static final StringParameter proxyServerAddress = new StringParameter(
+            &quot;proxy.server.address&quot;, // name
+            null, // default value
+            false, // mutable
+            &quot;Specify a network address.&quot; );
 
-	public static final BooleanParameter proxyServerRtpMultiplePorts = new BooleanParameter(
-			&quot;proxy.server.rtp.multiport.enable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Enables the RTP/RTCP multiport handling.&quot;,
-			&quot;/rtspproxy/proxy/server/rtpUsePortrange&quot; // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpPort = new IntegerParameter(
+            &quot;proxy.server.rtpPort&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8000 ), // default value
+            true, // mutable
+            &quot;Port to listen for RTP packets arriving from servers.&quot; );
 
-	public static final IntegerParameter proxyServerRtpMinPort = new IntegerParameter(
-			&quot;proxy.server.rtp.port.min&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 9000 ), // default value
-			true, // mutable
-			&quot;Port to listen for RTP packets arriving from servers.&quot;,
-			&quot;/rtspproxy/proxy/server/rtpPortrange/minPort&quot; // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtcpPort = new IntegerParameter(
+            &quot;proxy.server.rtcp.port&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8001 ), // default value
+            true, // mutable
+            &quot;Port to listen for RTCP packets arriving from servers.&quot; );
 
-	public static final IntegerParameter proxyServerRtpMaxPort = new IntegerParameter(
-			&quot;proxy.server.rtp.port.max&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 9100 ), // default value
-			true, // mutable
-			&quot;Port to listen for RTP packets arriving from servers.&quot;,
-			&quot;/rtspproxy/proxy/server/rtpPortrange/maxPort&quot; // xpathExpr
-			);
-	
-	public static final IntegerParameter proxyServerRtpIdleTimeout = new IntegerParameter(
-			&quot;proxy.server.rtp.portrange.idle.timeout&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 86400 ), // max value
-			new Integer( 3600 ), // default value
-			true, // mutable
-			&quot;Timeout an open RTP server port may linger around.&quot;,
-			&quot;/rtspproxy/proxy/server/rtpPortrange/idleTimeout&quot; // xpathExpr
-			);	
+    public static final BooleanParameter proxyServerRtpMultiplePorts = new BooleanParameter(
+            &quot;proxy.server.rtpUsePortRange&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Enables the RTP/RTCP multiport handling.&quot; );
 
-	public static final IntegerParameter proxyServerRtpIdleScanInterval = new IntegerParameter(
-			&quot;proxy.server.rtp.portrange.idle.timeout&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 86400 ), // max value
-			new Integer( 1800 ), // default value
-			true, // mutable
-			&quot;Scan interval on idle RTP server ports.&quot;,
-			&quot;/rtspproxy/proxy/server/rtpPortrange/idleScanInterval&quot; // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpMinPort = new IntegerParameter(
+            &quot;proxy.server.rtpPortrange.minPort&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 9000 ), // default value
+            true, // mutable
+            &quot;Port to listen for RTP packets arriving from servers.&quot; );
 
-	public static final IntegerParameter proxyServerRtpThreadPoolSize = new IntegerParameter(
-			&quot;proxy.server.rtp.portrange.pool.size&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 2147483647 ), // max value
-			new Integer( 10 ), // default value
-			true, // mutable
-			&quot;Scan interval on idle RTP server ports.&quot;,
-			&quot;/rtspproxy/proxy/server/rtpPortrange/threadPoolSize&quot; // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpMaxPort = new IntegerParameter(
+            &quot;proxy.server.rtpPortrange.maxPort&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 9100 ), // default value
+            true, // mutable
+            &quot;Port to listen for RTP packets arriving from servers.&quot; );
 
-	public static final IntegerParameter proxyClientRtpPort = new IntegerParameter(
-			&quot;proxy.client.rtp.port&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8002 ), // default value
-			true, // mutable
-			&quot;Port to listen for RTP packets arriving from clients.&quot;,
-			&quot;/rtspproxy/proxy/client/rtpPort&quot; // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpIdleTimeout = new IntegerParameter(
+            &quot;proxy.server.rtpPortrange.idleTimeout&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 86400 ), // max value
+            new Integer( 3600 ), // default value
+            true, // mutable
+            &quot;Timeout an open RTP server port may linger around.&quot; );
 
-	public static final IntegerParameter proxyClientRtcpPort = new IntegerParameter(
-			&quot;proxy.client.rtcp.port&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8003 ), // default value
-			true, // mutable
-			&quot;Port to listen for RTCP packets arriving from clients.&quot;,
-			&quot;/rtspproxy/proxy/client/rtcpPort&quot; // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpIdleScanInterval = new IntegerParameter(
+            &quot;proxy.server.rtpPortrange.idleScanInterval&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 86400 ), // max value
+            new Integer( 1800 ), // default value
+            true, // mutable
+            &quot;Scan interval on idle RTP server ports.&quot; );
 
-	public static final IntegerParameter proxyServerRdtPort = new IntegerParameter(
-			&quot;proxy.server.rdt.port&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8020 ), // default value
-			true, // mutable
-			&quot;Port to listen for RDT packets arriving from servers.&quot;,
-			&quot;/rtspproxy/proxy/server/rdtPort&quot; // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpThreadPoolSize = new IntegerParameter(
+            &quot;proxy.server.rtpPortrange.threadPoolSize&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 2147483647 ), // max value
+            new Integer( 10 ), // default value
+            true, // mutable
+            &quot;Scan interval on idle RTP server ports.&quot; );
 
-	public static final IntegerParameter proxyClientRdtPort = new IntegerParameter(
-			&quot;proxy.client.rdt.port&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8022 ), // default value
-			true, // mutable
-			&quot;Port to listen for RDT packets arriving from clients.&quot;,
-			&quot;/rtspproxy/proxy/client/rdtPort&quot; // xpathExpr
-			);
+    public static final IntegerParameter proxyClientRtpPort = new IntegerParameter(
+            &quot;proxy.client.rtpPort&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8002 ), // default value
+            true, // mutable
+            &quot;Port to listen for RTP packets arriving from clients.&quot; );
 
-	public static final BooleanParameter proxyTransportRtpEnable = new BooleanParameter(
-			&quot;proxy.transport.rtp.enable&quot;, // name
-			true, // default value
-			false, // mutable
-			&quot;Enables the UDP/AVP/RTP transport.&quot;,
-			&quot;/rtspproxy/proxy/transport/rtp&quot; // xpathExpr
-			);
-	
+    public static final IntegerParameter proxyClientRtcpPort = new IntegerParameter(
+            &quot;proxy.client.rtcpPort&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8003 ), // default value
+            true, // mutable
+            &quot;Port to listen for RTCP packets arriving from clients.&quot; );
 
-	public static final BooleanParameter proxyTransportRdtEnable = new BooleanParameter(
-			&quot;proxy.transport.rdt.enable&quot;, // name
-			true, // default value
-			false, // mutable
-			&quot;Enables the x-udp-rdt transport.&quot;,
-			&quot;/rtspproxy/proxy/transport/rdt&quot; // xpathExpr
-			);	
-	
+    public static final IntegerParameter proxyServerRdtPort = new IntegerParameter(
+            &quot;proxy.server.rdtPort&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8020 ), // default value
+            true, // mutable
+            &quot;Port to listen for RDT packets arriving from servers.&quot; );
 
-	public static final BooleanParameter proxyLowerTransportSuppress = new BooleanParameter(
-			&quot;proxy.transport.rtp.protocol.disable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Enables the x-udp-rdt transport.&quot;,
-			&quot;/rtspproxy/proxy/transport/hacks/lowerTransportSuppress&quot; // xpathExpr
-			);	
+    public static final IntegerParameter proxyClientRdtPort = new IntegerParameter(
+            &quot;proxy.client.rdtPort&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8022 ), // default value
+            true, // mutable
+            &quot;Port to listen for RDT packets arriving from clients.&quot; );
 
-	public static final BooleanParameter proxyRtspTransportSsrcDisable = new BooleanParameter(
-			&quot;proxy.transport.rtsp.transport.ssrc.disable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;disable the output of the SSRC transport attribute&quot;,
-			&quot;/rtspproxy/proxy/transport/hacks/rtspTransportSsrcDisable&quot; // xpathExpr
-			);	
+    public static final BooleanParameter proxyTransportRtpEnable = new BooleanParameter(
+            &quot;proxy.transport.rtp&quot;, // name
+            true, // default value
+            false, // mutable
+            &quot;Enables the UDP/AVP/RTP transport.&quot; );
 
-	public static final BooleanParameter proxyRtspTransportSourceDisable = new BooleanParameter(
-			&quot;proxy.transport.rtsp.transport.source.disable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;disable the output of the SOURCE transport attribute&quot;,
-			&quot;/rtspproxy/proxy/transport/hacks/rtspTransportSourceDisable&quot; // xpathExpr
-			);	
+    public static final BooleanParameter proxyTransportRdtEnable = new BooleanParameter(
+            &quot;proxy.transport.rdt&quot;, // name
+            true, // default value
+            false, // mutable
+            &quot;Enables the x-udp-rdt transport.&quot; );
 
-	public static final BooleanParameter proxyRtspKeepAlive = new BooleanParameter(
-			&quot;proxy.transport.rtsp.keepAlive.enable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Enable keep-alive on RTSP connections to remote servers.&quot;,
-			&quot;/rtspproxy/proxy/transport/hacks/rtspKeepAlive&quot; // xpathExpr
-			);
-	
-	public static final BooleanParameter proxyRtspAllowBrokenHeaders = new BooleanParameter(
-			&quot;proxy.transport.rtsp.broken.headers.enable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Allow certain work-arounds for clients generating non-conformant RTSP protocol traffic.&quot;,
-			&quot;/rtspproxy/proxy/transport/hacks/rtspAllowBrokenHeaders&quot; // xpathExpr
-			);
+    public static final BooleanParameter proxyLowerTransportSuppress = new BooleanParameter(
+            &quot;proxy.transport.hacks.lowerTransportSuppress&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Enables the x-udp-rdt transport.&quot; );
 
-	public static final BooleanParameter proxyRtspOfferSsrcToServer = new BooleanParameter(
-			&quot;proxy.transport.rtsp.offer.ssrc.enable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Allow certain work-arounds for clients generating non-conformant RTSP protocol traffic.&quot;,
-			&quot;/rtspproxy/proxy/transport/hacks/offerRemoteSsrc&quot; // xpathExpr
-			);
+    public static final BooleanParameter proxyRtspTransportSsrcDisable = new BooleanParameter(
+            &quot;proxy.transport.hacks.rtspTransportSsrcDisable&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Disable the output of the SSRC transport attribute&quot; );
 
-	public static final BooleanParameter proxyServerRtpSsrcUnreliable = new BooleanParameter(
-			&quot;proxy.streaming.rtp.ssrc.unreliable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Disable the evaluation of the SSRC send by the remote streaming server.&quot;,
-			&quot;/rtspproxy/proxy/streaming/hacks/rtpSsrcUnreliable&quot; // xpathExpr
-			);	
+    public static final BooleanParameter proxyRtspTransportSourceDisable = new BooleanParameter(
+            &quot;proxy.transport.rtspTransportSourceDisable&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Disable the output of the SOURCE transport attribute&quot; );
 
-	// /////////////////////////////////////////////////////////
+    public static final BooleanParameter proxyRtspKeepAlive = new BooleanParameter(
+            &quot;proxy.transport.hacks.rtspKeepAlive&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Enable keep-alive on RTSP connections to remote servers.&quot; );
 
-	// JMX
+    public static final BooleanParameter proxyRtspAllowBrokenHeaders = new BooleanParameter(
+            &quot;proxy.transport.hacks.rtspAllowBrokenHeaders&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Allow certain work-arounds for clients generating non-conformant RTSP protocol traffic.&quot; );
 
-	public static final BooleanParameter proxyManagementEnable = new BooleanParameter(
-			&quot;proxy.management.enable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Controls the activation of the management subsystem (JMX).&quot;,
-			&quot;/rtspproxy/jmx/manageable&quot; // xpathExpr
-			);
+    public static final BooleanParameter proxyRtspOfferSsrcToServer = new BooleanParameter(
+            &quot;proxy.transport.hacks.offerRemoteSsrc&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Allow certain work-arounds for clients generating non-conformant RTSP protocol traffic.&quot; );
 
-	public static final StringParameter proxyManagementHost = new StringParameter(
-			&quot;proxy.management.host&quot;, // name
-			&quot;localhost&quot;, // default value
-			false, // mutable
-			&quot;Host to bind the management services. Default is localhost, and the services &quot;
-					+ &quot;will only be reachable from local machine.&quot;,
-			&quot;/rtspproxy/jmx/address&quot; // xpathExpr
-			 );
+    public static final BooleanParameter proxyServerRtpSsrcUnreliable = new BooleanParameter(
+            &quot;proxy.transport.hacks.rtpSsrcUnreliable&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Disable the evaluation of the SSRC send by the remote streaming server.&quot; );
 
-	public static final StringParameter proxyManagementUser = new StringParameter(
-			&quot;proxy.management.user&quot;, // name
-			null, // default value
-			true, // mutable
-			&quot;Remote management administrator user name.&quot;,
-			&quot;/rtspproxy/jmx/user&quot; // xpathExpr
-			 );
-	
-	public static final StringParameter proxyManagementPassword = new StringParameter(
-			&quot;proxy.management.password&quot;, // name
-			null, // default value
-			true, // mutable
-			&quot;Remote management administrator password.&quot;,
-			&quot;/rtspproxy/jmx/password&quot; // xpathExpr
-			 );
+    // /////////////////////////////////////////////////////////
 
-	public static final BooleanParameter proxyManagementWebEnable = new BooleanParameter(
-			&quot;proxy.management.web.enable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Controls the activation of the Web management console.&quot;,
-			&quot;/rtspproxy/jmx/web/manageable&quot; // xpathExpr
-			 );
+    // JMX
 
-	public static final IntegerParameter proxyManagementWebPort = new IntegerParameter(
-			&quot;proxy.management.web.port&quot;, // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8000 ), // default value
-			false, // mutable
-			&quot;TCP port to be used for the Web Console.&quot;,
-			&quot;/rtspproxy/jmx/web/port&quot; // xpathExpr
-			 );
+    public static final BooleanParameter jmxEnable = new BooleanParameter( &quot;jmx.enable&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Controls the activation of the management subsystem (JMX).&quot; );
 
-	public static final BooleanParameter proxyManagementRemoteEnable = new BooleanParameter(
-			&quot;proxy.management.remote.enable&quot;, // name
-			false, // default value
-			false, // mutable
-			&quot;Controls the activation of the JMX connector server.&quot;,
-			&quot;/rtspproxy/jmx/connectorService/manageable&quot; // xpathExpr
-			 );
+    public static final StringParameter jmxAddress = new StringParameter( &quot;jmx.address&quot;, // name
+            &quot;localhost&quot;, // default value
+            false, // mutable
+            &quot;Host to bind the management services. Default is localhost, and the services &quot;
+                    + &quot;will only be reachable from local machine.&quot; );
 
-	// /////////////////////////////////////////////////////////
+    public static final StringParameter jmxUser = new StringParameter( &quot;jmx.user&quot;, // name
+            &quot;&quot;, // default value
+            true, // mutable
+            &quot;Remote management administrator user name.&quot; );
 
-	private static String rtspproxyHome;
+    public static final StringParameter jmxPassword = new StringParameter(
+            &quot;jmx.password&quot;, // name
+            &quot;&quot;, // default value
+            true, // mutable
+            &quot;Remote management administrator password.&quot; );
 
-	private static String name;
+    public static final BooleanParameter jmxWebEnable = new BooleanParameter(
+            &quot;jmx.web.enable&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Controls the activation of the Web management console.&quot; );
 
-	private static String version;
+    public static final IntegerParameter jmxWebPort = new IntegerParameter(
+            &quot;jmx.web.port&quot;, // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8000 ), // default value
+            false, // mutable
+            &quot;TCP port to be used for the Web Console.&quot; );
 
-	private static String proxySignature;
+    public static final BooleanParameter jmxConnectorServiceEnable = new BooleanParameter(
+            &quot;jmx.connectorService.enable&quot;, // name
+            false, // default value
+            false, // mutable
+            &quot;Controls the activation of the JMX connector server.&quot; );
 
-	private static Date startDate;
+    // /////////////////////////////////////////////////////////
 
-	// /////////////////////////////////////////////////////////
-	
-	// filter configurations from XML
-	private static List&lt;AAAConfig&gt; authenticationFilters = new ArrayList&lt;AAAConfig&gt;();
+    private static String rtspproxyHome;
 
-	// filter configurations from XML
-	private static List&lt;AAAConfig&gt; ipAddressFilters = new ArrayList&lt;AAAConfig&gt;();
+    private static String name;
 
-	// filter configurations from XML
-	private static List&lt;AAAConfig&gt; accountingFilters = new ArrayList&lt;AAAConfig&gt;();
+    private static String version;
 
-	// filter configurations from XML
-	private static List&lt;AAAConfig&gt; urlRewritingFilters = new ArrayList&lt;AAAConfig&gt;();
+    private static String proxySignature;
 
-	private static List&lt;AAAConfig&gt; controlFilters = new ArrayList&lt;AAAConfig&gt;();
-	
-	static void addAuthenticationFilter(AAAConfig config) {
-		authenticationFilters.add(config);
-	}
-	
-	static void addIpAddressFilter(AAAConfig config) {
-		ipAddressFilters.add(config);
-	}
-	
-	static void addAccountingFilter(AAAConfig config) {
-		accountingFilters.add(config);
-	}
-	
-	static void addUrlRewritingFilter(AAAConfig config) {
-		urlRewritingFilters.add(config);
-	}
+    private static Date startDate;
 
-	public static void addControlFilter(AAAConfig aaa) {
-		controlFilters.add(aaa);
-	}
+    // /////////////////////////////////////////////////////////
 
-	public static List&lt;AAAConfig&gt; getAuthenticationFilters() {
-		return Collections.unmodifiableList(authenticationFilters);
-	}
-	
-	public static List&lt;AAAConfig&gt; getIpAddressFilters() {
-		return Collections.unmodifiableList(ipAddressFilters);
-	}
-	
-	public static List&lt;AAAConfig&gt; getAccountingFilters() {
-		return Collections.unmodifiableList(accountingFilters);
-	}
+    // filter configurations from XML
+    private static List&lt;AAAConfig&gt; authenticationFilters = new ArrayList&lt;AAAConfig&gt;();
 
-	public static List&lt;AAAConfig&gt; getUrlRewritingFilters() {
-		return Collections.unmodifiableList(urlRewritingFilters);
-	}
-	
-	public static List&lt;AAAConfig&gt; getControlFilters() {
-		return Collections.unmodifiableList(controlFilters);
-	}
- 	
-	// /////////////////////////////////////////////////////////
+    // filter configurations from XML
+    private static List&lt;AAAConfig&gt; ipAddressFilters = new ArrayList&lt;AAAConfig&gt;();
 
-	public Config()
-	{
-		// Read home directory
-		rtspproxyHome = System.getProperty( &quot;rtspproxy.home&quot; );
-		if ( rtspproxyHome == null ) {
-			rtspproxyHome = System.getProperty( &quot;user.dir&quot; );
-		}
+    // filter configurations from XML
+    private static List&lt;AAAConfig&gt; accountingFilters = new ArrayList&lt;AAAConfig&gt;();
 
-		// Read program name and version
-		Properties jarProps = new Properties();
-		try {
-			jarProps.load( Thread.currentThread().getContextClassLoader().getResourceAsStream(
-					&quot;META-INF/application.properties&quot; ) );
-			name = jarProps.getProperty( &quot;application.name&quot; );
-			version = jarProps.getProperty( &quot;application.version&quot; );
-		} catch ( Exception e ) {
-			name = &quot;RtspProxy&quot;;
-			version = &quot;&quot;;
-		}
+    // filter configurations from XML
+    private static List&lt;AAAConfig&gt; urlRewritingFilters = new ArrayList&lt;AAAConfig&gt;();
 
-		// Build proxy signature
-		StringBuilder sb = new StringBuilder();
-		sb.append( name ).append( &quot; &quot; ).append( version );
-		sb.append( &quot; (&quot; ).append( System.getProperty( &quot;os.name&quot; ) );
-		sb.append( &quot; / &quot; ).append( System.getProperty( &quot;os.version&quot; ) );
-		sb.append( &quot; / &quot; ).append( System.getProperty( &quot;os.arch&quot; ) );
-		sb.append( &quot;)&quot; );
-		proxySignature = sb.toString();
+    private static List&lt;AAAConfig&gt; controlFilters = new ArrayList&lt;AAAConfig&gt;();
 
-		startDate = new Date();
+    static void addAuthenticationFilter( AAAConfig config )
+    {
+        authenticationFilters.add( config );
+    }
 
-	}
+    static void addIpAddressFilter( AAAConfig config )
+    {
+        ipAddressFilters.add( config );
+    }
 
-	/**
-	 * Manage parameters value changes
-	 * 
-	 * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
-	 */
-	public void update( Observable o, Object arg )
-	{
-		if ( !( o instanceof Parameter ) )
-			throw new IllegalArgumentException( &quot;Only observe parameters&quot; );
-	}
+    static void addAccountingFilter( AAAConfig config )
+    {
+        accountingFilters.add( config );
+    }
 
-	/**
-	 * @return the application base dir or null if the home directory cannot be determined.
-	 */
-	public static String getHome()
-	{
-		return rtspproxyHome;
-	}
+    static void addUrlRewritingFilter( AAAConfig config )
+    {
+        urlRewritingFilters.add( config );
+    }
 
-	/**
-	 * @return Returns the application name.
-	 */
-	public static String getName()
-	{
-		return name;
-	}
+    public static void addControlFilter( AAAConfig aaa )
+    {
+        controlFilters.add( aaa );
+    }
 
-	/**
-	 * @return Returns the application version.
-	 */
-	public static String getVersion()
-	{
-		return version;
-	}
+    public static List&lt;AAAConfig&gt; getAuthenticationFilters()
+    {
+        return Collections.unmodifiableList( authenticationFilters );
+    }
 
-	/**
-	 * @return Returns the proxySignature.
-	 */
-	public static String getProxySignature()
-	{
-		return proxySignature;
-	}
+    public static List&lt;AAAConfig&gt; getIpAddressFilters()
+    {
+        return Collections.unmodifiableList( ipAddressFilters );
+    }
 
-	public static Date getStartDate()
-	{
-		return startDate;
-	}
+    public static List&lt;AAAConfig&gt; getAccountingFilters()
+    {
+        return Collections.unmodifiableList( accountingFilters );
+    }
 
-	// /////////////////////////////////////////////////////////
+    public static List&lt;AAAConfig&gt; getUrlRewritingFilters()
+    {
+        return Collections.unmodifiableList( urlRewritingFilters );
+    }
 
-	/**
-	 * @return a String containing all the parameters
-	 */
-	public static String debugParameters()
-	{
-		StringBuilder sb = new StringBuilder();
-		Map&lt;String, Parameter&gt; parameters = new TreeMap&lt;String, Parameter&gt;(
-				Config.getParametersMap() );
-		sb.append( &quot;Parameters:\n&quot; );
-		for ( Parameter parameter : parameters.values() ) {
-			sb.append( parameter.getName() );
-			sb.append( &quot;: &quot; );
-			sb.append( parameter.getStringValue() );
-			sb.append( &quot;\n&quot; );
-		}
+    public static List&lt;AAAConfig&gt; getControlFilters()
+    {
+        return Collections.unmodifiableList( controlFilters );
+    }
 
-		return sb.toString();
-	}
+    // /////////////////////////////////////////////////////////
 
+    public Config()
+    {
+        // Read home directory
+        rtspproxyHome = System.getProperty( &quot;rtspproxy.home&quot; );
+        if ( rtspproxyHome == null ) {
+            rtspproxyHome = System.getProperty( &quot;user.dir&quot; );
+        }
+
+        // Read program name and version
+        Properties jarProps = new Properties();
+        try {
+            jarProps.load( Thread.currentThread().getContextClassLoader()
+                    .getResourceAsStream( &quot;META-INF/application.properties&quot; ) );
+            name = jarProps.getProperty( &quot;application.name&quot; );
+            version = jarProps.getProperty( &quot;application.version&quot; );
+        } catch ( Exception e ) {
+            name = &quot;RtspProxy&quot;;
+            version = &quot;&quot;;
+        }
+
+        // Build proxy signature
+        StringBuilder sb = new StringBuilder();
+        sb.append( name ).append( ' ' ).append( version );
+        sb.append( &quot; (&quot; ).append( System.getProperty( &quot;os.name&quot; ) );
+        sb.append( &quot; / &quot; ).append( System.getProperty( &quot;os.version&quot; ) );
+        sb.append( &quot; / &quot; ).append( System.getProperty( &quot;os.arch&quot; ) );
+        sb.append( ')' );
+        proxySignature = sb.toString();
+
+        startDate = new Date();
+
+    }
+
+    /**
+     * Manage parameters value changes
+     * 
+     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
+     */
+    public void update( Observable o, Object arg )
+    {
+        if ( !(o instanceof Parameter) )
+            throw new IllegalArgumentException( &quot;Only observe parameters&quot; );
+    }
+
+    /**
+     * @return the application base dir or null if the home directory cannot be
+     *         determined.
+     */
+    public static String getHome()
+    {
+        return rtspproxyHome;
+    }
+
+    /**
+     * @return Returns the application name.
+     */
+    public static String getName()
+    {
+        return name;
+    }
+
+    /**
+     * @return Returns the application version.
+     */
+    public static String getVersion()
+    {
+        return version;
+    }
+
+    /**
+     * @return Returns the proxySignature.
+     */
+    public static String getProxySignature()
+    {
+        return proxySignature;
+    }
+
+    public static Date getStartDate()
+    {
+        return startDate;
+    }
+
+    // /////////////////////////////////////////////////////////
+
+    protected static void updateDebugSettings()
+    {
+        Logger rootLogger = Logger.getRootLogger();
+        if ( debugEnabled.getValue() ) {
+            rootLogger.setLevel( Level.DEBUG );
+        }
+
+        /*
+         * else use the default level set in the log4j configuration file, which
+         * is INFO
+         */
+    }
+
+    /**
+     * @return a String containing all the parameters
+     */
+    public static String debugParameters()
+    {
+        StringBuilder sb = new StringBuilder();
+        Map&lt;String, Parameter&gt; parameters = new TreeMap&lt;String, Parameter&gt;( Config
+                .getParametersMap() );
+
+        sb.append( &quot;Parameters:\n&quot; );
+        for ( Parameter parameter : parameters.values() ) {
+            sb.append( parameter.getName() );
+            sb.append( &quot;: &quot; );
+            sb.append( parameter.getStringValue() );
+            sb.append( '\n' );
+        }
+
+        return sb.toString();
+    }
+
 }

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerListParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerListParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerListParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,139 +0,0 @@
-/**
- * 
- */
-package rtspproxy.config;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author Matteo Merli
- */
-public class IntegerListParameter extends ListParameter
-{
-	private List&lt;Integer&gt; values = null;
-
-	private Integer minValue;
-
-	private Integer maxValue;
-
-	private Integer defaultValue;
-
-	public IntegerListParameter( String name, Integer minValue, Integer maxValue,
-			Integer defaultValue, boolean mutable, String description, String xpathExpr )
-	{
-		super( name, mutable, description, xpathExpr );
-
-		if ( defaultValue == null )
-			throw new IllegalArgumentException( &quot;Default value for &quot; + name
-					+ &quot; must be not null.&quot; );
-		this.defaultValue = defaultValue;
-		this.minValue = minValue;
-		this.maxValue = maxValue;
-	}
-
-	@Override
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-		this.values = new ArrayList&lt;Integer&gt;();
-		Integer tmpValue = null;
-		String[] tokens = value.split( &quot;,&quot; );
-
-		for ( String token : tokens ) {
-
-			token = token.trim();
-			try {
-				tmpValue = Integer.valueOf( token );
-			} catch ( NumberFormatException nfe ) {
-				throw new IllegalArgumentException( &quot;Integer value for &quot; + name
-						+ &quot; not valid: &quot; + token );
-			}
-
-			if ( minValue != null &amp;&amp; (tmpValue.compareTo( minValue ) &lt; 0) )
-				throw new IllegalArgumentException( &quot;Integer value for &quot; + name
-						+ &quot; must be greater than &quot; + minValue );
-			if ( maxValue != null &amp;&amp; (tmpValue.compareTo( maxValue ) &gt; 0) )
-				throw new IllegalArgumentException( &quot;Integer value for &quot; + name
-						+ &quot; must be lesser than &quot; + maxValue );
-
-			this.values.add( tmpValue );
-		}
-
-		setChanged();
-	}
-
-	@Override	
-	public void addValue(String value) {
-		try {
-			Integer tmpValue = Integer.valueOf(value);
-
-			this.values.add(tmpValue);
-		} catch ( NumberFormatException nfe ) {
-			throw new IllegalArgumentException( &quot;Integer value for &quot; + name
-					+ &quot; not valid: &quot; + value );
-		}
-		
-		setChanged();
-	}
-
-	@Override
-	public String getStringValue()
-	{
-		if ( values == null )
-			return defaultValue.toString();
-
-		StringBuilder sb = new StringBuilder();
-		final int size = values.size();
-		for ( int i = 0; i &lt; size; i++ ) {
-			sb.append( values.get( i ).toString() );
-			if ( i &lt; size - 1 )
-				sb.append( &quot;, &quot; );
-		}
-		return sb.toString();
-	}
-
-	/**
-	 * @return Returns the defaultValue.
-	 */
-	public String getDefaultValue()
-	{
-		return defaultValue.toString();
-	}
-
-	public int[] getValue()
-	{
-		if ( values == null )
-			return new int[] { defaultValue };
-
-		int[] v = new int[values.size()];
-		for ( int i = values.size() - 1; i &gt;= 0; i-- )
-			v[i] = values.get( i );
-		return v;
-	}
-
-	@Override
-	public String getType()
-	{
-		return &quot;[I&quot;;
-	}
-
-	@Override
-	public Object getObjectValue()
-	{
-		return getValue();
-	}
-
-	@Override
-	public void setObjectValue( Object object )
-	{
-		if ( !(object instanceof int[]) )
-			throw new IllegalArgumentException( &quot;Value must be a int[]&quot; );
-		
-		this.values = new ArrayList&lt;Integer&gt;( ((int[]) object).length );
-		for ( int v : (int[]) object )
-			values.add( v );
-
-		setChanged();
-	}
-
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,6 +3,8 @@
  */
 package rtspproxy.config;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  */
@@ -17,9 +19,9 @@
 	private Integer defaultValue;
 
 	public IntegerParameter( String name, Integer minValue, Integer maxValue,
-			Integer defaultValue, boolean mutable, String description, String xpathExpr )
+			Integer defaultValue, boolean mutable, String description )
 	{
-		super( name, mutable, description, xpathExpr );
+		super( name, mutable, description );
 
 		if ( defaultValue == null )
 			throw new IllegalArgumentException( &quot;Default value for &quot; + name
@@ -30,21 +32,6 @@
 	}
 
 	@Override
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-
-		Integer tmpValue;
-		try {
-			tmpValue = Integer.valueOf( value );
-		} catch ( NumberFormatException nfe ) {
-			throw new IllegalArgumentException( &quot;Integer value for &quot; + name
-					+ &quot;not valid: &quot; + value );
-		}
-
-		setObjectValue( tmpValue );
-	}
-
-	@Override
 	public String getStringValue()
 	{
 		return (value != null ? value : defaultValue).toString();
@@ -96,5 +83,12 @@
 			setChanged();
 		}
 	}
+    
+    @Override
+    public void readConfiguration( Configuration configuration )
+    {
+        int value = configuration.getInt( name );
+        setObjectValue( value );
+    }
 
 }

Added: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - <A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">matteo.merli at gmail.com</A>            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
+ * 
+ * $URL$
+ * 
+ */
+package rtspproxy.config;
+
+/**
+ * @author Matteo Merli
+ * 
+ */
+public interface ListElementParameter
+{
+    
+}


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,25 +3,72 @@
  */
 package rtspproxy.config;
 
+import java.util.List;
+
+import org.apache.commons.configuration.Configuration;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
- *
+ * 
  */
-public abstract class ListParameter extends Parameter {
+public class ListParameter&lt;T&gt; extends Parameter
+{
 
-	/**
-	 * @param name
-	 * @param mutable
-	 * @param description
-	 * @param xpathExpr
-	 */
-	public ListParameter(String name, boolean mutable, String description,
-			String xpathExpr) {
-		super(name, mutable, description, xpathExpr);
-	}
+    private static Logger log = LoggerFactory.getLogger( ListParameter.class );
 
-	/**
-	 * add a value to the list
-	 */
-	public abstract void addValue(String value);
+    private List&lt;T&gt; list;
+
+    /**
+     * @param name
+     * @param mutable
+     * @param description
+     */
+    public ListParameter( String name, boolean mutable, String description )
+    {
+        super( name, mutable, description );
+    }
+
+    @Override
+    public Object getObjectValue()
+    {
+        return list;
+    }
+
+    @Override
+    public String getStringValue()
+    {
+        return list.toString();
+    }
+
+    @Override
+    public String getType()
+    {
+        return &quot;java.util.List&quot;;
+    }
+
+    @Override
+    public void readConfiguration( Configuration configuration )
+    {
+        List elements = configuration.getList( name );
+        if ( elements == null ) {
+            log.debug( &quot;Elements not found for key '{}'&quot;, name );
+            return;
+        }
+
+        for ( Object element : elements ) {
+            log.info( &quot;ELEMENT: {}&quot;, element );
+        }
+    }
+
+    @Override
+    public void setObjectValue( Object object )
+    {
+        if ( !(object instanceof List) ) {
+            throw new IllegalArgumentException( &quot;Only accept a List parameter.&quot; );
+        }
+        
+        list = (List&lt;T&gt;)object;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Parameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Parameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Parameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -5,110 +5,101 @@
 
 import java.util.Observable;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  */
 public abstract class Parameter extends Observable
 {
 
-	protected final String name;
+    protected final String name;
 
-	protected final boolean mutable;
+    protected final boolean mutable;
 
-	protected final String description;
-	
-	protected final String xpathExpr;
+    protected final String description;
 
-	protected Parameter( String name, boolean mutable, String description, String xpathExpr )
-	{
-		validateName( name );
+    protected Parameter( String name, boolean mutable, String description )
+    {
+        validateName( name );
 
-		this.name = name;
-		this.mutable = mutable;
-		this.description = description;
-		this.xpathExpr = xpathExpr;
-		
-		Config.addParameter( this );
-	}
+        this.name = name;
+        this.mutable = mutable;
+        this.description = description;
 
-	/**
-	 * Validate the name of the parameter. The name length must be &gt; 0
-	 */
-	private void validateName( String name ) throws IllegalArgumentException
-	{
-		if ( (name == null) || (name.length() &lt; 1) ) {
-			throw new IllegalArgumentException(
-					&quot; A configuration parameter name can't be null or 0 length&quot; );
-		}
-	}
+        Config.addParameter( this );
+    }
 
-	/**
-	 * Changes the value of this parameter
-	 * 
-	 * @param value
-	 * @throws IllegalArgumentException
-	 */
-	public abstract void setValue( String value ) throws IllegalArgumentException;
+    /**
+     * Validate the name of the parameter. The name length must be &gt; 0
+     */
+    private void validateName( String name ) throws IllegalArgumentException
+    {
+        if ( (name == null) || (name.length() &lt; 1) ) {
+            throw new IllegalArgumentException(
+                    &quot; A configuration parameter name can't be null or 0 length&quot; );
+        }
+    }
+    
+    /**
+     * @return a String representation of the value of this parameter.
+     */
+    public abstract String getStringValue();
 
-	/**
-	 * @return a String representation of the value of this parameter.
-	 */
-	public abstract String getStringValue();
+    public abstract Object getObjectValue();
 
-	public abstract Object getObjectValue();
+    public abstract void setObjectValue( Object object );
 
-	public abstract void setObjectValue( Object object );
+    /**
+     * @return the name of this parameter
+     */
+    public String getName()
+    {
+        return name;
+    }
 
-	/**
-	 * @return the name of this parameter
-	 */
-	public String getName()
-	{
-		return name;
-	}
+    /**
+     * @return true if this parameter is &quot;mutable&quot; (so that it can be modified
+     *         at runtime)
+     */
+    public boolean isMutable()
+    {
+        return mutable;
+    }
 
-	/**
-	 * @return true if this parameter is &quot;mutable&quot; (so that it can be modified
-	 *         at runtime)
-	 */
-	public boolean isMutable()
-	{
-		return mutable;
-	}
+    /**
+     * @return the description string of this parameter
+     */
+    public String getDescription()
+    {
+        return description;
+    }
 
-	/**
-	 * @return the description string of this parameter
-	 */
-	public String getDescription()
-	{
-		return description;
-	}
+    /**
+     * @return the string representation of the type for this parameter, such as
+     *         java.lang.String, java.lang.Integer...
+     */
+    public abstract String getType();
 
-	/**
-	 * @return the string representation of the type for this parameter, such as
-	 *         java.lang.String, java.lang.Integer...
-	 */
-	public abstract String getType();
+    /**
+     * Marks the parameter as changed and notify all the Observers.
+     * 
+     * @see java.util.Observable#setChanged()
+     */
+    @Override
+    protected void setChanged()
+    {
+        super.setChanged();
+        if ( mutable )
+            notifyObservers();
+    }
 
-	/**
-	 * @return the xpath expression used to address this parameter in the xml configuration file.
-	 * If null, this parameter is ignored in the configuration file evaluation.
-	 */
-	public final String getXPathExpr() {
-		return this.xpathExpr;
-	}
-	
-	/**
-	 * Marks the parameter as changed and notify all the Observers.
-	 * 
-	 * @see java.util.Observable#setChanged()
-	 */
-	@Override
-	protected void setChanged()
-	{
-		super.setChanged();
-		if ( mutable )
-			notifyObservers();
-	}
+    /**
+     * Concrete classes must use this method to read from a Configuration object
+     * the value of the parameter.
+     * 
+     * @param configuration
+     */
+    public abstract void readConfiguration( Configuration configuration );
 
-}
\ No newline at end of file
+}

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringListParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringListParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringListParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,108 +0,0 @@
-/**
- * 
- */
-package rtspproxy.config;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author Matteo Merli
- */
-public class StringListParameter extends ListParameter
-{
-	private List&lt;String&gt; values = null;
-
-	private String defaultValue;
-
-	public StringListParameter( String name, String defaultValue, boolean mutable,
-			String description, String xpathExpr )
-	{
-		super( name, mutable, description, xpathExpr );
-
-		if ( defaultValue == null )
-			throw new IllegalArgumentException( &quot;Default value for &quot; + name
-					+ &quot; must be not null.&quot; );
-		this.defaultValue = defaultValue;
-	}
-
-	@Override
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-		this.values = new ArrayList&lt;String&gt;();
-		String[] tokens = value.split( &quot;,&quot; );
-
-		for ( String token : tokens ) {
-			this.values.add( token );
-		}
-		setChanged();
-	}
-	
-	@Override	
-	public void addValue(String value) {
-		this.values.add(value);
-		
-		setChanged();
-	}
-
-	@Override
-	public String getStringValue()
-	{
-		if ( values == null )
-			return defaultValue.toString();
-
-		StringBuilder sb = new StringBuilder();
-		final int size = values.size();
-		for ( int i = 0; i &lt; size; i++ ) {
-			sb.append( values.get( i ) );
-			if ( i &lt; size - 1 )
-				sb.append( &quot;, &quot; );
-		}
-		return sb.toString();
-	}
-
-	/**
-	 * @return Returns the defaultValue.
-	 */
-	public String getDefaultValue()
-	{
-		return defaultValue;
-	}
-
-	public String[] getValue()
-	{
-		if ( values == null )
-			return new String[] { defaultValue };
-
-		String[] v = new String[values.size()];
-		for ( int i = values.size() - 1; i &gt;= 0; i-- )
-			v[i] = values.get( i );
-		return v;
-	}
-
-	@Override
-	public String getType()
-	{
-		return &quot;[Ljava.lang.String&quot;;
-	}
-
-	@Override
-	public Object getObjectValue()
-	{
-		return getValue();
-	}
-
-	@Override
-	public void setObjectValue( Object object )
-	{
-		if ( !(object instanceof String[]) )
-			throw new IllegalArgumentException( &quot;Value must be a String[]&quot; );
-
-		this.values = new ArrayList&lt;String&gt;( ((String[]) object).length );
-		for ( String s : (String[]) object )
-			values.add( s );
-
-		setChanged();
-	}
-
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,74 +1,96 @@
-/**
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - <A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">matteo.merli at gmail.com</A>            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
  * 
+ * $URL$
+ * 
  */
 package rtspproxy.config;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  */
 public class StringParameter extends Parameter
 {
 
-	private String value = null;
+    private String value = null;
 
-	private String defaultValue;
+    private String defaultValue;
 
-	public StringParameter( String name, String defaultValue, boolean mutable,
-			String description, String xpathExpr )
-	{
-		super( name, mutable, description, xpathExpr );
-		this.defaultValue = defaultValue;
-	}
+    public StringParameter( String name, String defaultValue, boolean mutable,
+            String description )
+    {
+        super( name, mutable, description );
+        this.defaultValue = defaultValue;
+    }
 
-	@Override
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-		this.value = value;
-		setChanged();
-	}
+    @Override
+    public String getStringValue()
+    {
+        return getValue();
+    }
 
-	@Override
-	public String getStringValue()
-	{
-		return getValue();
-	}
+    @Override
+    public String getType()
+    {
+        return &quot;java.lang.String&quot;;
+    }
 
-	@Override
-	public String getType()
-	{
-		return &quot;java.lang.String&quot;;
-	}
+    public String getValue()
+    {
+        return value == null ? defaultValue : value;
+    }
 
-	public String getValue()
-	{
-		return value == null ? defaultValue : value;
-	}
+    /**
+     * @return Returns the defaultValue.
+     */
+    public String getDefaultValue()
+    {
+        return defaultValue;
+    }
 
-	/**
-	 * @return Returns the defaultValue.
-	 */
-	public String getDefaultValue()
-	{
-		return defaultValue;
-	}
+    @Override
+    public Object getObjectValue()
+    {
+        return getValue();
+    }
 
-	@Override
-	public Object getObjectValue()
-	{
-		return getValue();
-	}
+    @Override
+    public void setObjectValue( Object object )
+    {
+        if ( object == null ) {
+            value = null;
+            return;
+        }
 
-	@Override
-	public void setObjectValue( Object object )
-	{
-		if ( !(object instanceof String) )
-			throw new IllegalArgumentException( &quot;Value must be a String&quot; );
+        if ( !(object instanceof String) )
+            throw new IllegalArgumentException( &quot;Value for parameter '&quot; + name
+                    + &quot;' must be a String&quot; );
 
-		if ( !object.equals( getObjectValue() ) ) {
-			// Only notify if the value is different
-			this.value = (String) object;
-			setChanged();
-		}
-	}
+        if ( !object.equals( getObjectValue() ) ) {
+            // Only notify if the value is different
+            this.value = (String) object;
+            setChanged();
+        }
+    }
 
+    @Override
+    public void readConfiguration( Configuration configuration )
+    {
+        String value = configuration.getString( name, defaultValue );
+        setObjectValue( value );
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,141 +1,96 @@
-/**
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - <A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">matteo.merli at gmail.com</A>            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id: Main.java 378 2006-01-06 20:36:11Z rbieniek $
  * 
+ * $URL: <A HREF="https://svn.berlios.de/svnroot/repos/rtspproxy/trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java">https://svn.berlios.de/svnroot/repos/rtspproxy/trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java</A> $
+ * 
  */
 package rtspproxy.config;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
+import java.io.BufferedReader;
 import java.io.File;
-import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
 import java.io.IOException;
-import java.io.InputStream;
-import java.util.List;
+import java.io.Reader;
+import java.util.NoSuchElementException;
 
-import org.dom4j.Attribute;
-import org.dom4j.Document;
+import org.apache.commons.configuration.ConfigurationException;
+import org.apache.commons.configuration.XMLConfiguration;
 import org.dom4j.DocumentException;
-import org.dom4j.Element;
-import org.dom4j.Node;
-import org.dom4j.io.SAXReader;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import rtspproxy.lib.Side;
-
 /**
  * This class implements a parser for XML configuration files.
+ * 
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
  * @todo validate the parsed configuration file by a schema.
  */
-public class XMLConfigReader {
+public class XMLConfigReader
+{
 
-	// logger
-	private static final Logger logger = LoggerFactory.getLogger(XMLConfigReader.class);
-	
-	/**
-	 * create the xml config read object
-	 */
-	public XMLConfigReader() {}
-	
-	/**
-	 * read the configuration file.
-	 * @param fName the pathname of the configuration file
-	 * @exception IOException the file denoted by the file name cannot be read
-	 * @throws DocumentException parsing the config file failed.
-	 */ 
-	public final void readConfig(String fName) throws IOException, DocumentException {
-		logger.debug(&quot;radConfig, fName=&quot; + fName);
-		File fFile = new File(fName);
-		
-		if(fFile.canRead())
-			this.readConfig(new FileInputStream(fFile));
-	}
-	
-	/**
-	 * read the configuration file
-	 * @param is the input stream to read the configuration from.
-	 * @throws DocumentException parsing the input stream failed.
-	 * @throws IllegalArgumentException invalid parameter value given
-	 */
-	public final void readConfig(InputStream is) throws DocumentException, IllegalArgumentException {
-		SAXReader reader = new SAXReader();
-		Document doc = reader.read(is); // TODO validate the document by a schema
-		
-		for(Parameter param : Config.getAllParameters()) {
-			String xpathExpr = param.getXPathExpr();
-			
-			if(xpathExpr != null) {
-				logger.debug(&quot;evaluating parameter &quot; + param.getName() + &quot; with xpath &quot; + xpathExpr);
-				
-				List&lt;Node&gt; nodes = (List&lt;Node&gt;)doc.selectNodes(xpathExpr);
-				
-				if(nodes.size() &gt; 1) {
-					if(param instanceof ListParameter) {
-						for(Node node : nodes) {
-							String value = null;
-							
-							if(node instanceof Attribute)
-								value = ((Attribute)node).getText();
-							else if(node instanceof Element)
-								value = ((Element)node).getTextTrim();
-							
-							if(value == null)
-								throw new IllegalArgumentException(&quot;Invalid value specified for parameter &quot; + param.getName());
-							
-							((ListParameter)param).addValue(value);							
-						}
-					} else
-						throw new IllegalArgumentException(&quot;Parameter &quot; + param.getName() + &quot; is not a list value&quot;);
-				} else if(nodes.size() == 1){
-					String value = null;
-					Node node = nodes.get(0);
-					
-					if(node instanceof Attribute)
-						value = ((Attribute)node).getText();
-					else if(node instanceof Element)
-						value = ((Element)node).getTextTrim();
-					
-					if(value == null)
-						throw new IllegalArgumentException(&quot;Invalid value specified for parameter &quot; + param.getName());
-					
-					param.setValue(value);
-				}
-			}
-		}
-		
-		for(Node aaaNode : (List&lt;Node&gt;)doc.selectNodes(&quot;/rtspproxy/filters/*&quot;)) {
-			String name = aaaNode.getName();
-			String implClass = ((Element)aaaNode).attributeValue(&quot;implClass&quot;);
-			Side side = Side.fromString(((Element)aaaNode).attributeValue(&quot;side&quot;));
-			
-			logger.debug(&quot;element name=&quot; + name + &quot;, implClass=&quot; + implClass + &quot;,side=&quot; + side);
-			
-			if(implClass == null || implClass.length() == 0)
-				throw new IllegalArgumentException(&quot;no implementation class given&quot;);
+    // logger
+    private static final Logger log = LoggerFactory.getLogger( XMLConfigReader.class );
 
-			AAAConfig aaa = new AAAConfig(implClass, side, 
-					(List&lt;Element&gt;)((Element)aaaNode).elements());
-			
-			for(Attribute attr : (List&lt;Attribute&gt;)((Element)aaaNode).attributes()) {
-				if(attr.getName().equals(&quot;implClass&quot;) || attr.getName().equals(&quot;side&quot;))
-					continue;
-				aaa.setAttribute(attr.getName(), attr.getText().trim());
-			}
-			
-			if(name.equals(&quot;authentication&quot;)) {
-				Config.addAuthenticationFilter(aaa);
-			} else if(name.equals(&quot;ipaddress&quot;)) {
-				Config.addIpAddressFilter(aaa);
-			} else if(name.equals(&quot;accounting&quot;)) {
-				Config.addAccountingFilter(aaa);				
-			} else if(name.equals(&quot;rewriting&quot;)) {
-				Config.addUrlRewritingFilter(aaa);
-			} else if(name.equals(&quot;control&quot;)) {
-				if(side == Side.Client || side == Side.Server) 
-					Config.addControlFilter(aaa);
-				else
-					throw new IllegalArgumentException(&quot;control filters can be only applied to either client or server side, not both&quot;);
-			} else
-				throw new IllegalArgumentException(&quot;invalid AAA element given, name=&quot; + name);
-		}
-	}
+    /**
+     * read the configuration file.
+     * 
+     * @param fileName
+     *            the pathname of the configuration file
+     * @exception IOException
+     *                the file denoted by the file name cannot be read
+     * @throws DocumentException
+     *             parsing the config file failed.
+     */
+    public final void readConfig( String fileName ) throws FileNotFoundException
+    {
+        log.debug( &quot;Reading configuration file={}&quot;, fileName );
+        File file = new File( fileName );
+
+        if ( file.canRead() ) {
+            readConfig( new BufferedReader( new FileReader( file ) ) );
+        }
+    }
+
+    /**
+     * read the configuration file
+     * 
+     * @param is
+     *            the input stream to read the configuration from.
+     */
+    public final void readConfig( Reader reader )
+    {
+        XMLConfiguration configuration = new XMLConfiguration();
+        try {
+            configuration.load( reader );
+        } catch ( ConfigurationException e ) {
+            log.error( &quot;Error reading configuration file.&quot; );
+            throw new RuntimeException( e );
+        }
+
+        for ( Parameter param : Config.getAllParameters() ) {
+            try {
+                param.readConfiguration( configuration );
+                log.debug( &quot;Parameter value: {}&quot;, param.getStringValue() );
+
+            } catch ( NoSuchElementException e ) {
+                log.debug( &quot;Parameter NOT found: '{}'. Using default value: {}&quot;, param
+                        .getName(), param.getStringValue() );
+
+            }
+        }
+
+        Config.updateDebugSettings();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -18,196 +18,220 @@
 
 /**
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
- *
+ * 
  */
-public class FilterBase extends IoFilterAdapter {
+public class FilterBase extends IoFilterAdapter
+{
 
-	private static Logger logger = LoggerFactory.getLogger(FilterBase.class);
-	
-	// filter name
-	private String filterName;
-	
-	// class name
-	private String className;
-	
-	// filter type
-	private String typeName;
-	
-	// running flag
-	protected boolean running = true; 
-	
-	// side
-	private Side side;
-	
-	// MBean name assigned by JMX interface
-	private ObjectName mbeanName;
-	
-	// chain name of filter
-	private String chainName;
-	
-	/**
-	 * 
-	 */
-	public FilterBase(String filterName, String className, String typeName) {
-		this.filterName = filterName;
-		this.className = className;
-		this.typeName = typeName;
-	}
+    private static Logger logger = LoggerFactory.getLogger( FilterBase.class );
 
-	/**
-	 * 
-	 */
-	public FilterBase(String filterName, String typeName) {
-		this.filterName = filterName;
-		this.typeName = typeName;
-	}
+    // filter name
+    private String filterName;
 
-	/**
-	 * query running flag
-	 */
-	public final boolean isRunning() {
-		return this.running;
-	}
-	
-	/**
-	 * suspend the filter
-	 */
-	public final void suspend() {
-		this.running = false;
-		logger.info(getChainName() + &quot; suspended&quot;);
-	}
-	
-	/**
-	 * resume the filter
-	 */
-	public final void resume() {
-		this.running = true;
-		logger.info(getChainName() + &quot; resumed&quot;);
-	}
-	
-	/**
-	 * get the object name of a more specific MBean 
-	 */
-	public ObjectName getDetailMBean() {
-		return null;
-	}
-	
-	/**
-	 * get the side 
-	 */
-	public Side getSide() {
-		return this.side;
-	}
-	
-	/**
-	 * set the side
-	 */
-	public void setSide(Side side) {
-		this.side = side;
-	}
+    // class name
+    private String className;
 
-	/**
-	 * @return Returns the mbeanName.
-	 */
-	public ObjectName getMbeanName() {
-		return mbeanName;
-	}
+    // filter type
+    private String typeName;
 
-	/**
-	 * Set the name of the MBean used for filter management. This property is write-once.
-	 * @param mbeanName The mbeanName to set.
-	 */
-	public void setMbeanName(ObjectName mbeanName) {
-		// once set it can not change
-		if(this.mbeanName == null)
-			this.mbeanName = mbeanName;
-	}
+    // running flag
+    protected boolean running = true;
 
-	/**
-	 * @return Returns the className.
-	 */
-	public String getClassName() {
-		return className;
-	}
+    // side
+    private Side side;
 
-	/**
-	 * @return Returns the typeName.
-	 */
-	public String getTypeName() {
-		return typeName;
-	}
-	
-	/**
-	 * get the chain name for the filter. 
-	 */
-	public String getChainName() {
-		
-		if (this.chainName == null) {
-			StringBuffer buf = new StringBuffer(this.filterName);
+    // MBean name assigned by JMX interface
+    private ObjectName mbeanName;
 
-			buf.append(&quot;/&quot;);
-			buf.append(this.typeName);
-			if (this.className != null) {
-				buf.append(&quot;/&quot;);
-				buf.append(this.className);
-			}
+    // chain name of filter
+    private String chainName;
 
-			this.chainName = buf.toString();
-		}
-		return this.chainName;
-	}
-	
-	/**
-	 * load a provider class, instantiate an object, configure and init it.
-	 * @param className the name of the provider class to load
-	 * @param requiredInterface the provider interface the loaded class should implement.
-	 * This implementation assumes that the interface is a sub-interface of GenericProvider
-	 * @param configElements the configuration elements used to configure the loaded provider
-	 */
-	protected GenericProvider loadConfigInitProvider(String className, Class requiredInterface, 
-			List&lt;Element&gt; configElements) {
-		GenericProvider provider = null;
-		String providerName = requiredInterface.getSimpleName();
-		Class providerClass;
-		try {
-			providerClass = Class.forName( className );
+    /**
+     * 
+     */
+    public FilterBase( String filterName, String className, String typeName )
+    {
+        this.filterName = filterName;
+        this.className = className;
+        this.typeName = typeName;
+    }
 
-		} catch ( Throwable t ) {
-			logger.error( &quot;Invalid &quot; + providerName + &quot;class: &quot; + className, t );
-			Reactor.stop();
-			return null;
-		}
+    /**
+     * 
+     */
+    public FilterBase( String filterName, String typeName )
+    {
+        this.filterName = filterName;
+        this.typeName = typeName;
+    }
 
-		// Check if the class implements the IpAddressProvider interfaces
-		boolean found = false;
-		for ( Class interFace : providerClass.getInterfaces() ) {
-			if ( requiredInterface.equals( interFace ) ) {
-				found = true;
-				break;
-			}
-		}
+    /**
+     * query running flag
+     */
+    public final boolean isRunning()
+    {
+        return this.running;
+    }
 
-		if ( !found ) {
-			logger.error( &quot;Class (&quot; + providerClass
-					+ &quot;) does not implement the &quot; + providerName + &quot; interface.&quot; );
-			Reactor.stop();
-			return null;
-		}
+    /**
+     * suspend the filter
+     */
+    public final void suspend()
+    {
+        this.running = false;
+        logger.info( getChainName() + &quot; suspended&quot; );
+    }
 
-		try {
-			provider = (GenericProvider) providerClass.newInstance();
-			
-			if(provider instanceof AAAConfigurable)
-				((AAAConfigurable)provider).configure(configElements);
+    /**
+     * resume the filter
+     */
+    public final void resume()
+    {
+        this.running = true;
+        logger.info( getChainName() + &quot; resumed&quot; );
+    }
 
-			provider.init();
+    /**
+     * get the object name of a more specific MBean
+     */
+    public ObjectName getDetailMBean()
+    {
+        return null;
+    }
 
-		} catch ( Exception e ) {
-			logger.error( &quot;Error starting &quot; + providerName + &quot;: &quot; + e );
-			Reactor.stop();
-			return null;
-		}		
-		
-		return provider;
-	}
+    /**
+     * get the side
+     */
+    public Side getSide()
+    {
+        return this.side;
+    }
+
+    /**
+     * set the side
+     */
+    public void setSide( Side side )
+    {
+        this.side = side;
+    }
+
+    /**
+     * @return Returns the mbeanName.
+     */
+    public ObjectName getMbeanName()
+    {
+        return mbeanName;
+    }
+
+    /**
+     * Set the name of the MBean used for filter management. This property is
+     * write-once.
+     * 
+     * @param mbeanName
+     *            The mbeanName to set.
+     */
+    public void setMbeanName( ObjectName mbeanName )
+    {
+        // once set it can not change
+        if ( this.mbeanName == null )
+            this.mbeanName = mbeanName;
+    }
+
+    /**
+     * @return Returns the className.
+     */
+    public String getClassName()
+    {
+        return className;
+    }
+
+    /**
+     * @return Returns the typeName.
+     */
+    public String getTypeName()
+    {
+        return typeName;
+    }
+
+    /**
+     * get the chain name for the filter.
+     */
+    public String getChainName()
+    {
+
+        if ( this.chainName == null ) {
+            StringBuffer buf = new StringBuffer( this.filterName );
+
+            buf.append( '/' );
+            buf.append( this.typeName );
+            if ( this.className != null ) {
+                buf.append( '/' );
+                buf.append( this.className );
+            }
+
+            this.chainName = buf.toString();
+        }
+        return this.chainName;
+    }
+
+    /**
+     * load a provider class, instantiate an object, configure and init it.
+     * 
+     * @param className
+     *            the name of the provider class to load
+     * @param requiredInterface
+     *            the provider interface the loaded class should implement. This
+     *            implementation assumes that the interface is a sub-interface
+     *            of GenericProvider
+     * @param configElements
+     *            the configuration elements used to configure the loaded
+     *            provider
+     */
+    protected GenericProvider loadConfigInitProvider( String className,
+            Class requiredInterface, List&lt;Element&gt; configElements )
+    {
+        GenericProvider provider = null;
+        String providerName = requiredInterface.getSimpleName();
+        Class providerClass;
+        try {
+            providerClass = Class.forName( className );
+
+        } catch ( Throwable t ) {
+            logger.error( &quot;Invalid &quot; + providerName + &quot;class: &quot; + className, t );
+            Reactor.stop();
+            return null;
+        }
+
+        // Check if the class implements the IpAddressProvider interfaces
+        boolean found = false;
+        for ( Class interFace : providerClass.getInterfaces() ) {
+            if ( requiredInterface.equals( interFace ) ) {
+                found = true;
+                break;
+            }
+        }
+
+        if ( !found ) {
+            logger.error( &quot;Class ({}) does not implement the {} interface.&quot;, providerClass,
+                    providerName );
+            Reactor.stop();
+            return null;
+        }
+
+        try {
+            provider = (GenericProvider) providerClass.newInstance();
+
+            if ( provider instanceof AAAConfigurable )
+                ((AAAConfigurable) provider).configure( configElements );
+
+            provider.init();
+
+        } catch ( Exception e ) {
+            logger.error( &quot;Error starting &quot; + providerName + &quot;: &quot; + e );
+            Reactor.stop();
+            return null;
+        }
+
+        return provider;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,6 +1,21 @@
-/**
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - <A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">matteo.merli at gmail.com</A>            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id: RtspFilters.java 406 2006-01-27 00:28:56Z rbieniek $
  * 
+ * $URL: <A HREF="https://svn.berlios.de/svnroot/repos/rtspproxy/trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java">https://svn.berlios.de/svnroot/repos/rtspproxy/trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java</A> $
+ * 
  */
+
 package rtspproxy.filter;
 
 import java.util.Collections;
@@ -16,7 +31,6 @@
 import rtspproxy.filter.accounting.AccountingFilter;
 import rtspproxy.filter.authentication.AuthenticationFilter;
 import rtspproxy.filter.control.ClientControlFilter;
-import rtspproxy.filter.control.ControlFilter;
 import rtspproxy.filter.control.ServerControlFilter;
 import rtspproxy.filter.ipaddress.IpAddressFilter;
 import rtspproxy.filter.rewrite.ClientUrlRewritingFilter;
@@ -36,31 +50,31 @@
 	private static Logger logger = LoggerFactory.getLogger(FilterRegistry.class);
 
 	// client side address filters
-	private LinkedList&lt;IpAddressFilter&gt; clientAddressFilters = new LinkedList&lt;IpAddressFilter&gt;();
+	private List&lt;IpAddressFilter&gt; clientAddressFilters = new LinkedList&lt;IpAddressFilter&gt;();
 	
 	// server side address filters
-	private LinkedList&lt;IpAddressFilter&gt; serverAddressFilters = new LinkedList&lt;IpAddressFilter&gt;();
+	private List&lt;IpAddressFilter&gt; serverAddressFilters = new LinkedList&lt;IpAddressFilter&gt;();
 
 	// client side authentication filters
-	private LinkedList&lt;AuthenticationFilter&gt; clientAuthenticationFilters = new LinkedList&lt;AuthenticationFilter&gt;();
+	private List&lt;AuthenticationFilter&gt; clientAuthenticationFilters = new LinkedList&lt;AuthenticationFilter&gt;();
 	
 	// client side accounting filter
-	private LinkedList&lt;AccountingFilter&gt; clientAccountingFilters = new LinkedList&lt;AccountingFilter&gt;();
+	private List&lt;AccountingFilter&gt; clientAccountingFilters = new LinkedList&lt;AccountingFilter&gt;();
 	
 	// server side accounting filter
-	private LinkedList&lt;AccountingFilter&gt; serverAccountingFilters = new LinkedList&lt;AccountingFilter&gt;();
+	private List&lt;AccountingFilter&gt; serverAccountingFilters = new LinkedList&lt;AccountingFilter&gt;();
 	
 	// client side rewriting filters
-	private LinkedList&lt;UrlRewritingFilter&gt; clientUrlRewritingFilters = new LinkedList&lt;UrlRewritingFilter&gt;();
+	private List&lt;UrlRewritingFilter&gt; clientUrlRewritingFilters = new LinkedList&lt;UrlRewritingFilter&gt;();
 	
 	// server side rewriting filters
-	private LinkedList&lt;UrlRewritingFilter&gt; serverUrlRewritingFilters = new LinkedList&lt;UrlRewritingFilter&gt;();
+	private List&lt;UrlRewritingFilter&gt; serverUrlRewritingFilters = new LinkedList&lt;UrlRewritingFilter&gt;();
 	
 	// client side control traffic filters
-	private LinkedList&lt;ClientControlFilter&gt; clientControlFilters = new LinkedList&lt;ClientControlFilter&gt;();
+	private List&lt;ClientControlFilter&gt; clientControlFilters = new LinkedList&lt;ClientControlFilter&gt;();
 	
 	// client side control traffic filters
-	private LinkedList&lt;ServerControlFilter&gt; serverControlFilters = new LinkedList&lt;ServerControlFilter&gt;();
+	private List&lt;ServerControlFilter&gt; serverControlFilters = new LinkedList&lt;ServerControlFilter&gt;();
 	
 	/**
 	 * 
@@ -180,7 +194,7 @@
 	}
 	
 	private void registerFilterMBean(FilterBase filter) {
-		if(Config.proxyManagementEnable.getValue())
+		if(Config.jmxEnable.getValue())
 			JmxAgent.getInstance().registerFilter(filter);
 	}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -48,150 +48,136 @@
 public abstract class RtspFilters implements IoFilterChainBuilder
 {
 
-	private static ProtocolCodecFactory codecFactory = new ProtocolCodecFactory()
-	{
+    private static ProtocolCodecFactory codecFactory = new ProtocolCodecFactory()
+    {
 
-		// Decoders can be shared
-		private ProtocolEncoder rtspEncoder = new RtspEncoder();
+        // Decoders can be shared
+        private final ProtocolEncoder rtspEncoder = new RtspEncoder();
 
-		private ProtocolDecoder rtspDecoder = new RtspDecoder();
+        private final ProtocolDecoder rtspDecoder = new RtspDecoder();
 
-		public ProtocolEncoder getEncoder()
-		{
-			return rtspEncoder;
-		}
+        public ProtocolEncoder getEncoder()
+        {
+            return rtspEncoder;
+        }
 
-		public ProtocolDecoder getDecoder()
-		{
-			return rtspDecoder;
-		}
-	};
+        public ProtocolDecoder getDecoder()
+        {
+            return rtspDecoder;
+        }
+    };
 
-	private static final IoFilter codecFilter = new ProtocolCodecFilter( codecFactory );
+    private static final IoFilter codecFilter = new ProtocolCodecFilter( codecFactory );
 
-	public static final String rtspCodecNAME = &quot;rtspCodec&quot;;
+    public static final String rtspCodecNAME = &quot;rtspCodec&quot;;
 
-	/**
-	 * IP Address filter.
-	 * &lt;p&gt;
-	 * This needs to be the first filter in the chain to block blacklisted host
-	 * in the early stage of the connection, preventing network and computation
-	 * load from unwanted hosts.
-	 */
-	protected void addIpAddressFilter( IoFilterChain chain, Side side )
-	{
-		List&lt;IpAddressFilter&gt; filters;
-		
-		if(side == Side.Client)
-			filters = FilterRegistry.getInstance().getClientAddressFilters();
-		else
-			filters = FilterRegistry.getInstance().getServerAddressFilters();
-		
-		for(IpAddressFilter ipAddressFilter : filters) {
+    /**
+     * IP Address filter.
+     * &lt;p&gt;
+     * This needs to be the first filter in the chain to block blacklisted host
+     * in the early stage of the connection, preventing network and computation
+     * load from unwanted hosts.
+     */
+    protected void addIpAddressFilter( IoFilterChain chain, Side side )
+    {
+        // XXX: disabled
+        /*
+         * List&lt;IpAddressFilter&gt; filters;
+         * 
+         * if(side == Side.Client) filters =
+         * FilterRegistry.getInstance().getClientAddressFilters(); else filters =
+         * FilterRegistry.getInstance().getServerAddressFilters();
+         * 
+         * for(IpAddressFilter ipAddressFilter : filters) {
+         * 
+         * chain.addAfter( ProxyServiceRegistry.threadPoolFilterNAME,
+         * ipAddressFilter.getChainName(), ipAddressFilter );
+         *  }
+         */
+    }
 
-			chain.addAfter( ProxyServiceRegistry.threadPoolFilterNAME,
-					ipAddressFilter.getChainName(), ipAddressFilter );
-			
-		}
-		
-	}
+    /**
+     * The RTSP codec filter is always present. Translates the incoming streams
+     * into RTSP messages.
+     */
+    protected void addRtspCodecFilter( IoFilterChain chain )
+    {
+        chain.addLast( rtspCodecNAME, codecFilter );
+    }
 
-	/**
-	 * The RTSP codec filter is always present. Translates the incoming streams
-	 * into RTSP messages.
-	 */
-	protected void addRtspCodecFilter( IoFilterChain chain )
-	{
-		chain.addLast( rtspCodecNAME, codecFilter );
-	}
+    /**
+     * Authentication filter.
+     */
+    protected void addAuthenticationFilter( IoFilterChain chain )
+    {
+        for ( AuthenticationFilter authenticationFilter : FilterRegistry.getInstance()
+                .getClientAuthenticationFilters() ) {
+            chain.addAfter( rtspCodecNAME, authenticationFilter.getChainName(),
+                    authenticationFilter );
+        }
+    }
 
-	/**
-	 * Authentication filter.
-	 */
-	protected void addAuthenticationFilter( IoFilterChain chain )
-	{
-		for(AuthenticationFilter authenticationFilter : FilterRegistry.getInstance().getClientAuthenticationFilters()) {
-			chain.addAfter( rtspCodecNAME, authenticationFilter.getChainName(),
-					authenticationFilter );
-			
-		}
-	}
+    protected void addAccountingFilter( IoFilterChain chain, Side side )
+    {
+        // XXX: disabled
+        /*
+        List&lt;AccountingFilter&gt; filters;
 
-	protected void addAccountingFilter( IoFilterChain chain, Side side )
-	{
-		List&lt;AccountingFilter&gt; filters;
-		
-		if(side == Side.Client) {
-			filters = FilterRegistry.getInstance().getClientAccountingFilters();
+        if ( side == Side.Client ) {
+            filters = FilterRegistry.getInstance().getClientAccountingFilters();
 
-			for(AccountingFilter accountingFilter : filters) {
-				chain.addAfter( rtspCodecNAME,
-						accountingFilter.getChainName(), accountingFilter );
-			}
-		} else {
-			filters = FilterRegistry.getInstance().getServerAccountingFilters();
+            for ( AccountingFilter accountingFilter : filters ) {
+                chain.addAfter( rtspCodecNAME, accountingFilter.getChainName(),
+                        accountingFilter );
+            }
+        } else {
+            filters = FilterRegistry.getInstance().getServerAccountingFilters();
 
-			for(AccountingFilter accountingFilter : filters) {
-				chain.addAfter( rtspCodecNAME,
-						accountingFilter.getChainName(), accountingFilter );
-			}
-		}
-		
-		/*
-		boolean enableAccountingFilter = Config.proxyFilterAccountingEnable.getValue();
+            for ( AccountingFilter accountingFilter : filters ) {
+                chain.addAfter( rtspCodecNAME, accountingFilter.getChainName(),
+                        accountingFilter );
+            }
+        }
+        */
+    }
 
-		if ( enableAccountingFilter ) {
-			if ( accountingFilter == null ) {
-				accountingFilter = new AccountingFilter();
-			}
-			if ( chain.contains( authenticationFilterNAME ) ) {
-				/ *
-				 * If we have the authentication filter in the chain, it's
-				 * preferable to have the accounting after that, to see the user
-				 * identity if authenticated.
-				 * /
-				chain.addAfter( authenticationFilterNAME, accountingFilterNAME,
-						accountingFilter );
-			} else {
-				/ *
-				 * At least we want to have it after the RTSP codec, because it
-				 * deals with already parsed RTSP messages.
-				 * /
-				chain.addAfter( rtspCodecNAME, accountingFilterNAME, accountingFilter );
-			}
-		}
-		*/
-	}
+    protected void addRewriteFilter( IoFilterChain chain, Side side )
+    {
+        // XXX: disabled
+        /*
+        List&lt;UrlRewritingFilter&gt; filters;
 
-	protected void addRewriteFilter( IoFilterChain chain, Side side )
-	{
-		List&lt;UrlRewritingFilter&gt; filters;
-		
-		if(side == Side.Client)
-			filters = FilterRegistry.getInstance().getClientUrlRewritingFilters();
-		else
-			filters = FilterRegistry.getInstance().getServerUrlRewritingFilters();
-		
-		for(UrlRewritingFilter urlRewritingFilter : filters) {
+        if ( side == Side.Client )
+            filters = FilterRegistry.getInstance().getClientUrlRewritingFilters();
+        else
+            filters = FilterRegistry.getInstance().getServerUrlRewritingFilters();
 
-			chain.addAfter( rtspCodecNAME, urlRewritingFilter.getChainName(), urlRewritingFilter );
-			
-		}
-	}
+        for ( UrlRewritingFilter urlRewritingFilter : filters ) {
 
-	protected void addControlFilter ( IoFilterChain chain, Side side) {
-		if(side == Side.Client) {
-			List&lt;ClientControlFilter&gt; filters = FilterRegistry.getInstance().getClientControlFilters();
+            chain.addAfter( rtspCodecNAME, urlRewritingFilter.getChainName(),
+                    urlRewritingFilter );
+        }
+        */
+    }
 
-			for(ControlFilter controlFilter : filters) {
-				chain.addAfter( rtspCodecNAME, controlFilter.getChainName(), controlFilter);
-			}
-		} else {
-			List&lt;ServerControlFilter&gt; filters = FilterRegistry.getInstance().getServerControlFilters();
-		
-			for(ControlFilter controlFilter : filters) {
-				chain.addAfter( rtspCodecNAME, controlFilter.getChainName(), controlFilter);
-			}
-		}
-	}
+    protected void addControlFilter( IoFilterChain chain, Side side )
+    {
+        if ( side == Side.Client ) {
+            List&lt;ClientControlFilter&gt; filters = FilterRegistry.getInstance()
+                    .getClientControlFilters();
+
+            for ( ControlFilter controlFilter : filters ) {
+                chain.addAfter( rtspCodecNAME, controlFilter.getChainName(),
+                        controlFilter );
+            }
+        } else {
+            List&lt;ServerControlFilter&gt; filters = FilterRegistry.getInstance()
+                    .getServerControlFilters();
+
+            for ( ControlFilter controlFilter : filters ) {
+                chain.addAfter( rtspCodecNAME, controlFilter.getChainName(),
+                        controlFilter );
+            }
+        }
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -45,162 +45,160 @@
 public class AuthenticationFilter extends FilterBase
 {
 
-	private static Logger log = LoggerFactory.getLogger( AuthenticationFilter.class );
+    private static Logger log = LoggerFactory.getLogger( AuthenticationFilter.class );
 
-	public static final String FilterNAME = &quot;authenticationFilter&quot;;
+    public static final String FilterNAME = &quot;authenticationFilter&quot;;
 
-	public static final String ATTR = AuthenticationFilter.class.getName() + &quot;Attr&quot;;
+    public static final String ATTR = AuthenticationFilter.class.getName() + &quot;Attr&quot;;
 
-	private static final Map&lt;String, Class&gt; schemeRegistry = new HashMap&lt;String, Class&gt;();
+    private static final Map&lt;String, Class&gt; schemeRegistry = new HashMap&lt;String, Class&gt;();
 
-	static {
-		// Fill in known schemes
-		schemeRegistry.put( &quot;basic&quot;, BasicAuthentication.class );
-		schemeRegistry.put( &quot;digest&quot;, DigestAuthentication.class );
-	}
+    static {
+        // Fill in known schemes
+        schemeRegistry.put( &quot;basic&quot;, BasicAuthentication.class );
+        schemeRegistry.put( &quot;digest&quot;, DigestAuthentication.class );
+    }
 
-	/**
-	 * Backend provider.
-	 */
-	private AuthenticationProvider provider;
+    /**
+     * Backend provider.
+     */
+    private AuthenticationProvider provider;
 
-	/** Different authentication schemes implementation */
-	private AuthenticationScheme scheme = null;
+    /** Different authentication schemes implementation */
+    private AuthenticationScheme scheme = null;
 
-	/**
-	 * Construct a new AuthenticationFilter. Looks at the configuration to load
-	 * the choseen backend implementation.
-	 */
-	public AuthenticationFilter(String className, String schemeName, List&lt;Element&gt; configElements)
-	{
-		super(FilterNAME, className, &quot;authentication&quot;);
-		
-		this.provider = (AuthenticationProvider)loadConfigInitProvider(className, 
-				AuthenticationProvider.class, 
-				configElements);
-		
-		// Validate the choosen authentication scheme
-		Class schemeClass = schemeRegistry.get( schemeName.toLowerCase() );
-		if ( schemeClass == null ) {
-			// scheme not found
-			log.error( &quot;Authentication Scheme not found: &quot; + schemeName
-					+ &quot;. Valid values are: &quot;
-					+ Arrays.toString( schemeRegistry.keySet().toArray() ) );
-			Reactor.stop();
-			return;
-		}
+    /**
+     * Construct a new AuthenticationFilter. Looks at the configuration to load
+     * the choseen backend implementation.
+     */
+    public AuthenticationFilter( String className, String schemeName,
+            List&lt;Element&gt; configElements )
+    {
+        super( FilterNAME, className, &quot;authentication&quot; );
 
-		// Instanciate the selected scheme
-		try {
-			scheme = (AuthenticationScheme) schemeClass.newInstance();
-		} catch ( Exception e ) {
-		}
+        this.provider = (AuthenticationProvider) loadConfigInitProvider( className,
+                AuthenticationProvider.class, configElements );
 
-		log.info( &quot;Using AuthenticationFilter &quot; + scheme.getName() + &quot; (&quot; + className
-				+ &quot;)&quot; );
-	}
+        // Validate the choosen authentication scheme
+        Class schemeClass = schemeRegistry.get( schemeName.toLowerCase() );
+        if ( schemeClass == null ) {
+            // scheme not found
+            log.error( &quot;Authentication Scheme not found: &quot; + schemeName
+                    + &quot;. Valid values are: &quot;
+                    + Arrays.toString( schemeRegistry.keySet().toArray() ) );
+            Reactor.stop();
+            return;
+        }
 
-	public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( !(message instanceof RtspRequest) ) {
-			// Shouldn't happen
-			log.warn( &quot;Object message is not a RTSP message&quot; );
-			return;
-		}
+        // Instanciate the selected scheme
+        try {
+            scheme = (AuthenticationScheme) schemeClass.newInstance();
+        } catch ( Exception e ) {
+        }
 
-		if (isRunning()) {
-			if (session.getAttribute(ATTR) != null) {
-				// Client already autheticated
-				log
-						.debug(&quot;Already authenticaed: &quot;
-								+ session.getAttribute(ATTR));
-				nextFilter.messageReceived(session, message);
-			}
+        log.info( &quot;Using AuthenticationFilter &quot; + scheme.getName() + &quot; (&quot; + className
+                + &quot;)&quot; );
+    }
 
-			String authString = ((RtspMessage) message)
-					.getHeader(&quot;Proxy-Authorization&quot;);
-			if (authString == null) {
-				log.debug(&quot;RTSP message: \n&quot; + message);
-				RtspResponse response = RtspResponse
-						.errorResponse(RtspCode.ProxyAuthenticationRequired);
-				response.setHeader(&quot;Proxy-Authenticate&quot;, scheme.getName() + &quot; &quot;
-						+ scheme.getChallenge());
+    @Override
+    public void messageReceived( final NextFilter nextFilter, final IoSession session,
+            final Object message ) throws Exception
+    {
+        if ( !(message instanceof RtspRequest) ) {
+            // Shouldn't happen
+            log.warn( &quot;Object message is not a RTSP message&quot; );
+            return;
+        }
 
-				log.debug(&quot;Sending RTSP message: \n&quot; + response);
+        if ( isRunning() ) {
+            if ( session.getAttribute( ATTR ) != null ) {
+                // Client already autheticated
+                log.debug( &quot;Already authenticaed: {}&quot;, session.getAttribute( ATTR ) );
+                nextFilter.messageReceived( session, message );
+            }
 
-				session.write(response);
-				return;
-			}
+            final String authString = ((RtspMessage) message)
+                    .getHeader( &quot;Proxy-Authorization&quot; );
+            if ( authString == null ) {
+                log.debug( &quot;RTSP message: \n{}&quot;, message );
+                final RtspResponse response = RtspResponse
+                        .errorResponse( RtspCode.ProxyAuthenticationRequired );
+                
+                response.setHeader( &quot;Proxy-Authenticate&quot;, scheme.getName() + &quot; &quot;
+                        + scheme.getChallenge() );
 
-			if (!validateAuthenticationScheme(authString)) {
-				RtspResponse response = RtspResponse
-						.errorResponse(RtspCode.BadRequest);
+                log.debug( &quot;Sending RTSP message: \n{}&quot;, response );
 
-				session.write(response);
-				return;
-			}
+                session.write( response );
+                return;
+            }
 
-			log.debug(&quot;RTSP message: \n&quot; + message);
+            if ( !validateAuthenticationScheme( authString ) ) {
+                final RtspResponse response = RtspResponse
+                        .errorResponse( RtspCode.BadRequest );
 
-			// Check the authentication credentials
-			Credentials credentials = scheme
-					.getCredentials((RtspMessage) message);
+                session.write( response );
+                return;
+            }
 
-			boolean authenticationOk = false;
-			if (credentials != null) {
-				String password = provider.getPassword(credentials
-						.getUserName());
-				if (password != null)
-					if (scheme.computeAuthentication(credentials, password) == true)
-						authenticationOk = true;
-			}
+            log.debug( &quot;RTSP message: \n{}&quot;, message );
 
-			if (!authenticationOk) {
-				log.warn(&quot;Authentication failed for user: &quot; + credentials);
-				RtspResponse response = RtspResponse
-						.errorResponse(RtspCode.ProxyAuthenticationRequired);
-				response.setHeader(&quot;Proxy-Authenticate&quot;, scheme.getName() + &quot; &quot;
-						+ scheme.getChallenge());
+            // Check the authentication credentials
+            final Credentials credentials = scheme.getCredentials( (RtspMessage) message );
 
-				session.write(response);
-				return;
-			}
+            boolean authenticationOk = false;
+            if ( credentials != null ) {
+                final String password = provider.getPassword( credentials.getUserName() );
+                if ( password != null )
+                    if ( scheme.computeAuthentication( credentials, password ) == true )
+                        authenticationOk = true;
+            }
 
-			log.debug(&quot;Authentication succesfull for user: &quot; + credentials);
+            if ( !authenticationOk ) {
+                log.warn( &quot;Authentication failed for user: {}&quot;, credentials );
+                final RtspResponse response = RtspResponse
+                        .errorResponse( RtspCode.ProxyAuthenticationRequired );
+                response.setHeader( &quot;Proxy-Authenticate&quot;, scheme.getName() + &quot; &quot;
+                        + scheme.getChallenge() );
 
-			/*
-			 * Mark the session with an &quot;authenticated&quot; attribute. This will
-			 * prevent the check for the credentials for every message received.
-			 */
-			session.setAttribute(ATTR, credentials.getUserName());
-		}
-		
-		// Forward message
-		nextFilter.messageReceived( session, message );
-	}
+                session.write( response );
+                return;
+            }
 
-	/**
-	 * Gets the authentication scheme stated by the client.
-	 * 
-	 * @param authString
-	 * @return
-	 */
-	private boolean validateAuthenticationScheme( String authString )
-	{
-		String schemeName;
-		try {
-			schemeName = authString.split( &quot; &quot; )[0];
-		} catch ( IndexOutOfBoundsException e ) {
-			// Malformed auth string
-			return false;
-		}
+            log.debug( &quot;Authentication succesfull for user: {}&quot;, credentials );
 
-		if ( schemeName.equalsIgnoreCase( scheme.getName() ) )
-			return true;
+            /*
+             * Mark the session with an &quot;authenticated&quot; attribute. This will
+             * prevent the check for the credentials for every message received.
+             */
+            session.setAttribute( ATTR, credentials.getUserName() );
+        }
 
-		// Scheme not valid
-		return false;
-	}
+        // Forward message
+        nextFilter.messageReceived( session, message );
+    }
 
+    /**
+     * Gets the authentication scheme stated by the client.
+     * 
+     * @param authString
+     * @return
+     */
+    private boolean validateAuthenticationScheme( String authString )
+    {
+        String schemeName;
+        try {
+            schemeName = authString.split( &quot; &quot; )[0];
+        } catch ( IndexOutOfBoundsException e ) {
+            // Malformed auth string
+            return false;
+        }
+
+        if ( schemeName.equalsIgnoreCase( scheme.getName() ) )
+            return true;
+
+        // Scheme not valid
+        return false;
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -64,12 +64,13 @@
 			byte[] decBytes = Base64.decode( authString );
 			String auth = StringUtil.toString( decBytes );
 
-			log.debug( &quot;auth: &quot; + auth );
+			log.debug( &quot;auth: {}&quot;, auth );
 			username = auth.split( &quot;:&quot;, 2 )[0];
 			password = auth.split( &quot;:&quot;, 2 )[1];
-			log.debug( &quot;username=&quot; + username + &quot; - password=&quot; + password );
+			log.debug( &quot;username={} - password={}&quot;, username, password );
+            
 		} catch ( Exception e ) {
-			log.warn( &quot;Malformed authString: &quot; + authString );
+			log.warn( &quot;Malformed authString: {}&quot;, authString );
 			return null;
 		}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/Credentials.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/Credentials.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/Credentials.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,56 +26,60 @@
 public class Credentials
 {
 
-	protected String userName;
+    protected String userName;
 
-	protected String password;
-	
-	public Credentials()
-	{
-	}
+    protected String password;
 
-	public Credentials( String userName, String password )
-	{
-		this.userName = userName;
-		this.password = password;
-	}
+    public Credentials()
+    {
+    }
 
-	/**
-	 * @return Returns the password.
-	 */
-	public String getPassword()
-	{
-		return password;
-	}
+    public Credentials( String userName, String password )
+    {
+        this.userName = userName;
+        this.password = password;
+    }
 
-	/**
-	 * @param password
-	 *            The password to set.
-	 */
-	public void setPassword( String password )
-	{
-		this.password = password;
-	}
+    /**
+     * @return Returns the password.
+     */
+    public String getPassword()
+    {
+        return password;
+    }
 
-	/**
-	 * @return Returns the userName.
-	 */
-	public String getUserName()
-	{
-		return userName;
-	}
+    /**
+     * @param password
+     *            The password to set.
+     */
+    public void setPassword( String password )
+    {
+        this.password = password;
+    }
 
-	/**
-	 * @param userName
-	 *            The userName to set.
-	 */
-	public void setUserName( String userName )
-	{
-		this.userName = userName;
-	}
+    /**
+     * @return Returns the userName.
+     */
+    public String getUserName()
+    {
+        return userName;
+    }
 
-	public String toString()
-	{
-		return &quot;(&quot; + userName + &quot;:&quot; + password + &quot;)&quot;;
-	}
+    /**
+     * @param userName
+     *            The userName to set.
+     */
+    public void setUserName( String userName )
+    {
+        this.userName = userName;
+    }
+
+    @Override
+    public String toString()
+    {
+        final StringBuilder sb = new StringBuilder();
+        sb.append( '(' ).append( userName ).append( ':' );
+        sb.append( password ).append( ')' );
+        return sb.toString();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/DigestAuthentication.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/DigestAuthentication.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/DigestAuthentication.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,3 +1,21 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - <A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">matteo.merli at gmail.com</A>            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
+ * 
+ * $URL$
+ * 
+ */
+
 package rtspproxy.filter.authentication.scheme;
 
 import static rtspproxy.lib.StringUtil.getStringMap;
@@ -21,300 +39,302 @@
 public class DigestAuthentication implements AuthenticationScheme
 {
 
-	private static Logger log = LoggerFactory.getLogger( DigestAuthentication.class );
+    private static Logger log = LoggerFactory.getLogger( DigestAuthentication.class );
 
-	/** This is the value of the validity of a challenge response. */
-	private static final int NONCE_TIMEOUT = 60 * 5; // 5 minutes
+    /** This is the value of the validity of a challenge response. */
+    private static final int NONCE_TIMEOUT = 60 * 5; // 5 minutes
 
-	private UnsignedLong privateKey;
+    private UnsignedLong privateKey;
 
-	private String realm;
+    private String realm;
 
-	private MessageDigest md5;
+    private MessageDigest md5;
 
-	public DigestAuthentication()
-	{
-		// Generate the private key
-		Random random = new Random();
-		privateKey = new UnsignedLong( random );
+    public DigestAuthentication()
+    {
+        // Generate the private key
+        Random random = new Random();
+        privateKey = new UnsignedLong( random );
 
-		try {
-			md5 = MessageDigest.getInstance( &quot;MD5&quot; );
-		} catch ( NoSuchAlgorithmException e ) {
-		}
+        try {
+            md5 = MessageDigest.getInstance( &quot;MD5&quot; );
+        } catch ( NoSuchAlgorithmException e ) {
+            log.error( &quot;No such algorithm: MD5&quot; );
+        }
 
-		// Initiazialize the realm string
-		realm = &quot;realm=&quot;
-				+ quote( &quot;RtspProxy@&quot;
-						+ RtspService.getInstance().getAddress().getHostAddress() );
-	}
+        // Initiazialize the realm string
+        realm = &quot;realm=&quot;
+                + quote( &quot;RtspProxy@&quot;
+                        + RtspService.getInstance().getAddress().getHostAddress() );
+    }
 
-	public String getName()
-	{
-		return &quot;Digest&quot;;
-	}
+    public String getName()
+    {
+        return &quot;Digest&quot;;
+    }
 
-	public Credentials getCredentials( RtspMessage message )
-	{
-		String authString = message.getHeader( &quot;Proxy-Authorization&quot; );
-		authString = authString.split( &quot; &quot; )[1];
-		Map&lt;String, String&gt; params = getStringMap( authString );
-		if ( params == null )
-			return null;
+    public Credentials getCredentials( RtspMessage message )
+    {
+        String authString = message.getHeader( &quot;Proxy-Authorization&quot; );
+        authString = authString.split( &quot; &quot; )[1];
+        Map&lt;String, String&gt; params = getStringMap( authString );
+        if ( params == null )
+            return null;
 
-		String username = params.get( &quot;username&quot; );
-		String response = params.get( &quot;response&quot; );
-		String realm = params.get( &quot;realm&quot; );
-		String nonce = params.get( &quot;nonce&quot; );
-		String uri = params.get( &quot;uri&quot; );
-		String cnonce = params.get( &quot;cnonce&quot; );
-		String nc = params.get( &quot;nc&quot; );
-		if ( username == null || response == null || realm == null || nonce == null
-				|| uri == null || cnonce == null || nc == null )
-			return null;
+        String username = params.get( &quot;username&quot; );
+        String response = params.get( &quot;response&quot; );
+        String realm = params.get( &quot;realm&quot; );
+        String nonce = params.get( &quot;nonce&quot; );
+        String uri = params.get( &quot;uri&quot; );
+        String cnonce = params.get( &quot;cnonce&quot; );
+        String nc = params.get( &quot;nc&quot; );
+        if ( username == null || response == null || realm == null || nonce == null
+                || uri == null || cnonce == null || nc == null )
+            return null;
 
-		// Check the validity of the nonce
-		String sTimeStamp = nonce.substring( 0, 16 );
-		long timestamp = Long.valueOf( sTimeStamp, 16 );
-		long current = System.currentTimeMillis();
-		long diff = current - timestamp;
-		log.debug( &quot;Time diff: &quot; + ((float) diff / 1000 ) + &quot; sec&quot; );
-		if ( diff &lt; 0 || diff &gt; NONCE_TIMEOUT * 1000 )
-			// Timeout excedeed
-			return null;
+        // Check the validity of the nonce
+        String sTimeStamp = nonce.substring( 0, 16 );
+        long timestamp = Long.valueOf( sTimeStamp, 16 );
+        long current = System.currentTimeMillis();
+        long diff = current - timestamp;
+        log.debug( &quot;Time diff: {} sec&quot;, ((float) diff / 1000) );
+        if ( diff &lt; 0 || diff &gt; NONCE_TIMEOUT * 1000 )
+            // Timeout excedeed
+            return null;
 
-		DigestCredentials credentials = new DigestCredentials();
-		credentials.setUserName( username );
-		credentials.setResponse( response );
-		credentials.setRealm( realm );
-		credentials.setNonce( nonce );
-		credentials.setUri( uri );
-		credentials.setMethod( ( (RtspRequest) message ).getVerbString() );
-		credentials.setCnonce( cnonce );
-		credentials.setNc( nc );
+        DigestCredentials credentials = new DigestCredentials();
+        credentials.setUserName( username );
+        credentials.setResponse( response );
+        credentials.setRealm( realm );
+        credentials.setNonce( nonce );
+        credentials.setUri( uri );
+        credentials.setMethod( ((RtspRequest) message).getVerbString() );
+        credentials.setCnonce( cnonce );
+        credentials.setNc( nc );
 
-		return credentials;
-	}
+        return credentials;
+    }
 
-	public String getChallenge()
-	{
-		StringBuilder challenge = new StringBuilder();
-		challenge.append( realm ).append( &quot;,&quot; );
-		challenge.append( &quot;nonce=&quot; ).append( quote( newNonce() ) ).append( &quot;,&quot; );
-		challenge.append( &quot;qop=auth,&quot; );
-		challenge.append( &quot;algorithm=&quot; ).append( quote(&quot;MD5&quot;) );
-		return challenge.toString();
-	}
+    public String getChallenge()
+    {
+        StringBuilder challenge = new StringBuilder();
+        challenge.append( realm ).append( ',' );
+        challenge.append( &quot;nonce=&quot; ).append( quote( newNonce() ) ).append( ',' );
+        challenge.append( &quot;qop=auth,&quot; );
+        challenge.append( &quot;algorithm=&quot; ).append( quote( &quot;MD5&quot; ) );
+        return challenge.toString();
+    }
 
-	/**
-	 * Generate a new nonce, defined as
-	 * &lt;code&gt;time-stamp H(time-stamp &quot;:&quot; private-key)&lt;/code&gt;
-	 * 
-	 * encoded in Base64.
-	 * 
-	 * @return the nonce
-	 */
-	private String newNonce()
-	{
-		UnsignedLong timestamp = new UnsignedLong( System.currentTimeMillis() );
+    /**
+     * Generate a new nonce, defined as
+     * &lt;code&gt;time-stamp H(time-stamp &quot;:&quot; private-key)&lt;/code&gt;
+     * 
+     * encoded in Base64.
+     * 
+     * @return the nonce
+     */
+    private String newNonce()
+    {
+        UnsignedLong timestamp = new UnsignedLong( System.currentTimeMillis() );
 
-		byte[] firstPart = null;
-		synchronized ( md5 ) {
-			md5.update( timestamp.getBytes() );
-			md5.update( (byte) ':' );
-			md5.update( privateKey.getBytes() );
-			firstPart = md5.digest();
-		}
+        byte[] firstPart = null;
+        synchronized ( md5 ) {
+            md5.update( timestamp.getBytes() );
+            md5.update( (byte) ':' );
+            md5.update( privateKey.getBytes() );
+            firstPart = md5.digest();
+        }
 
-		return toHexString( timestamp.getBytes() ) + toHexString( firstPart );
-	}
+        return toHexString( timestamp.getBytes() ) + toHexString( firstPart );
+    }
 
-	public boolean computeAuthentication( Credentials credentials, String storedPassword )
-	{
-		if ( !( credentials instanceof DigestCredentials ) )
-			return false;
+    /**
+     * @param credentials
+     * @param storedPassword
+     * 
+     * @return true if the user authenticate. false if the authentication fails
+     */
+    public boolean computeAuthentication( Credentials credentials, String storedPassword )
+    {
+        if ( !(credentials instanceof DigestCredentials) )
+            return false;
 
-		// response = KD ( H(A1), unq(nonce-value) &quot;:&quot; H(A2) )
-		// A1 = unq(username-value) &quot;:&quot; unq(realm-value) &quot;:&quot; passwd
-		// A2 = Method &quot;:&quot; digest-uri-value
+        // response = KD ( H(A1), unq(nonce-value) &quot;:&quot; H(A2) )
+        // A1 = unq(username-value) &quot;:&quot; unq(realm-value) &quot;:&quot; passwd
+        // A2 = Method &quot;:&quot; digest-uri-value
 
-		DigestCredentials creds = (DigestCredentials) credentials;
-		String A1 = creds.getUserName() + &quot;:&quot; + creds.getRealm() + &quot;:&quot; + storedPassword;
-		String A2 = creds.getMethod() + &quot;:&quot; + creds.getUri();
+        DigestCredentials creds = (DigestCredentials) credentials;
+        String A1 = creds.getUserName() + &quot;:&quot; + creds.getRealm() + &quot;:&quot; + storedPassword;
+        String A2 = creds.getMethod() + &quot;:&quot; + creds.getUri();
 
-		byte[] response;
-		synchronized ( md5 ) {
-			md5.update( toByteArray( A1 ) );
-			byte[] HA1 = md5.digest();
-			md5.update( toByteArray( A2 ) );
-			byte[] HA2 = md5.digest();
+        byte[] response;
+        synchronized ( md5 ) {
+            md5.update( toByteArray( A1 ) );
+            byte[] HA1 = md5.digest();
+            md5.update( toByteArray( A2 ) );
+            byte[] HA2 = md5.digest();
 
-			String sHA1 = toHexString( HA1 );
-			String sHA2 = toHexString( HA2 );
+            String sHA1 = toHexString( HA1 );
+            String sHA2 = toHexString( HA2 );
 
-			md5.update( toByteArray( sHA1 ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( creds.getNonce() ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( creds.getNc() ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( creds.getCnonce() ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( &quot;auth&quot; ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( sHA2 ) );
-			response = md5.digest();
-		}
+            md5.update( toByteArray( sHA1 ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( creds.getNonce() ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( creds.getNc() ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( creds.getCnonce() ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( &quot;auth&quot; ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( sHA2 ) );
+            response = md5.digest();
+        }
 
-		String expectedResponse = toHexString( response );
-		log.debug( &quot;Expected: &quot; + expectedResponse );
-		log.debug( &quot;Got:      &quot; + creds.getResponse() );
-		return expectedResponse.equals( creds.getResponse() );
-	}
+        String expectedResponse = toHexString( response );
+        log.debug( &quot;Expected: {}&quot;, expectedResponse );
+        log.debug( &quot;Got:      {}&quot;, creds.getResponse() );
+        return expectedResponse.equals( creds.getResponse() );
+    }
 
-	/**
-	 * Specialized credentials class that holds all the relevant digest data.
-	 */
-	private static class DigestCredentials extends Credentials
-	{
+    /**
+     * Specialized credentials class that holds all the relevant digest data.
+     */
+    private static class DigestCredentials extends Credentials
+    {
 
-		private String response;
+        private String response;
+        private String realm;
+        private String nonce;
+        private String uri;
+        private String method;
+        private String cnonce;
+        private String nc;
 
-		private String realm;
+        /**
+         * @return Returns the nonce.
+         */
+        public String getNonce()
+        {
+            return nonce;
+        }
 
-		private String nonce;
+        /**
+         * @param nonce
+         *            The nonce to set.
+         */
+        public void setNonce( String nonce )
+        {
+            this.nonce = nonce;
+        }
 
-		private String uri;
+        /**
+         * @return Returns the realm.
+         */
+        public String getRealm()
+        {
+            return realm;
+        }
 
-		private String method;
+        /**
+         * @param realm
+         *            The realm to set.
+         */
+        public void setRealm( String realm )
+        {
+            this.realm = realm;
+        }
 
-		private String cnonce;
+        /**
+         * @return Returns the response.
+         */
+        public String getResponse()
+        {
+            return response;
+        }
 
-		private String nc;
+        /**
+         * @param response
+         *            The response to set.
+         */
+        public void setResponse( String response )
+        {
+            this.response = response;
+        }
 
-		/**
-		 * @return Returns the nonce.
-		 */
-		public String getNonce()
-		{
-			return nonce;
-		}
+        /**
+         * @return Returns the uri.
+         */
+        public String getUri()
+        {
+            return uri;
+        }
 
-		/**
-		 * @param nonce
-		 *            The nonce to set.
-		 */
-		public void setNonce( String nonce )
-		{
-			this.nonce = nonce;
-		}
+        /**
+         * @param uri
+         *            The uri to set.
+         */
+        public void setUri( String uri )
+        {
+            this.uri = uri;
+        }
 
-		/**
-		 * @return Returns the realm.
-		 */
-		public String getRealm()
-		{
-			return realm;
-		}
+        /**
+         * @return Returns the method.
+         */
+        public String getMethod()
+        {
+            return method;
+        }
 
-		/**
-		 * @param realm
-		 *            The realm to set.
-		 */
-		public void setRealm( String realm )
-		{
-			this.realm = realm;
-		}
+        /**
+         * @param method
+         *            The method to set.
+         */
+        public void setMethod( String method )
+        {
+            this.method = method;
+        }
 
-		/**
-		 * @return Returns the response.
-		 */
-		public String getResponse()
-		{
-			return response;
-		}
+        /**
+         * @return Returns the cnonce.
+         */
+        public String getCnonce()
+        {
+            return cnonce;
+        }
 
-		/**
-		 * @param response
-		 *            The response to set.
-		 */
-		public void setResponse( String response )
-		{
-			this.response = response;
-		}
+        /**
+         * @param cnonce
+         *            The cnonce to set.
+         */
+        public void setCnonce( String cnonce )
+        {
+            this.cnonce = cnonce;
+        }
 
-		/**
-		 * @return Returns the uri.
-		 */
-		public String getUri()
-		{
-			return uri;
-		}
+        /**
+         * @return Returns the nc.
+         */
+        public String getNc()
+        {
+            return nc;
+        }
 
-		/**
-		 * @param uri
-		 *            The uri to set.
-		 */
-		public void setUri( String uri )
-		{
-			this.uri = uri;
-		}
+        /**
+         * @param nc
+         *            The nc to set.
+         */
+        public void setNc( String nc )
+        {
+            this.nc = nc;
+        }
 
-		/**
-		 * @return Returns the method.
-		 */
-		public String getMethod()
-		{
-			return method;
-		}
+        @Override
+        public String toString()
+        {
+            return &quot;(&quot; + userName + &quot;:&quot; + response + &quot;)&quot;;
+        }
 
-		/**
-		 * @param method
-		 *            The method to set.
-		 */
-		public void setMethod( String method )
-		{
-			this.method = method;
-		}
-
-		/**
-		 * @return Returns the cnonce.
-		 */
-		public String getCnonce()
-		{
-			return cnonce;
-		}
-
-		/**
-		 * @param cnonce
-		 *            The cnonce to set.
-		 */
-		public void setCnonce( String cnonce )
-		{
-			this.cnonce = cnonce;
-		}
-
-		/**
-		 * @return Returns the nc.
-		 */
-		public String getNc()
-		{
-			return nc;
-		}
-
-		/**
-		 * @param nc
-		 *            The nc to set.
-		 */
-		public void setNc( String nc )
-		{
-			this.nc = nc;
-		}
-
-		public String toString()
-		{
-			return &quot;(&quot; + userName + &quot;:&quot; + response + &quot;)&quot;;
-		}
-
-	}
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,7 +6,6 @@
 import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -5,26 +5,17 @@
 
 import java.util.List;
 
-import org.apache.mina.common.IdleStatus;
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import rtspproxy.filter.FilterBase;
-import rtspproxy.rtsp.RtspMessage;
-import rtspproxy.rtsp.RtspRequest;
-import rtspproxy.rtsp.RtspResponse;
 
 /**
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
  *
  */
-public class ControlFilter extends FilterBase {
-
-	private static Logger log = LoggerFactory.getLogger(ControlFilter.class);
-	
+public class ControlFilter extends FilterBase 
+{	
 	public static final String FilterNAME = &quot;controlFilter&quot;;
 
 	protected ControlProvider provider;

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,7 +6,6 @@
 import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -16,51 +15,53 @@
 
 /**
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
- *
+ * 
  */
-public class ServerControlFilter extends ControlFilter {
+public class ServerControlFilter extends ControlFilter
+{
 
-	private static Logger log = LoggerFactory.getLogger(ClientControlFilter.class);
+    private static Logger log = LoggerFactory.getLogger( ClientControlFilter.class );
 
-	/**
-	 * @param className
-	 * @param configElements
-	 * @param typeName
-	 */
-	public ServerControlFilter(String className, List&lt;Element&gt; configElements) {
-		super(className, configElements, &quot;serverControl&quot;);
-	}
+    /**
+     * @param className
+     * @param configElements
+     * @param typeName
+     */
+    public ServerControlFilter( String className, List&lt;Element&gt; configElements )
+    {
+        super( className, configElements, &quot;serverControl&quot; );
+    }
 
-	@Override
-	public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( provider != null &amp;&amp; isRunning()) {
-			if(message instanceof RtspResponse)
-				provider.processResponse(session, (RtspResponse)message);
-			else
-				log.error( &quot;Expecting a RtspResponse. Received a &quot;
-						+ message.getClass().getName() );
-		}
+    @Override
+    public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+        if ( provider != null &amp;&amp; isRunning() ) {
+            if ( message instanceof RtspResponse )
+                provider.processResponse( session, (RtspResponse) message );
+            else
+                log.error( &quot;Expecting a RtspResponse. Received a {}&quot;, message.getClass()
+                        .getName() );
+        }
 
-		// Forward message
-		nextFilter.messageReceived( session, message );
-	}
+        // Forward message
+        nextFilter.messageReceived( session, message );
+    }
 
-	@Override
-	public void messageSent( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( provider != null  &amp;&amp; isRunning()) {
-			if ( message instanceof RtspRequest )
-				provider.processRequest(session, (RtspRequest)message);
-			else
-				log.error( &quot;Expecting a Rtsprequest. Received a &quot;
-						+ message.getClass().getName() );
-		}
-		
-		// Forward message
-		nextFilter.messageSent( session, message );
-	}
+    @Override
+    public void messageSent( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+        if ( provider != null &amp;&amp; isRunning() ) {
+            if ( message instanceof RtspRequest )
+                provider.processRequest( session, (RtspRequest) message );
+            else
+                log.error( &quot;Expecting a Rtsprequest. Received a {}&quot;,
+                        message.getClass().getName() );
+        }
 
+        // Forward message
+        nextFilter.messageSent( session, message );
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,14 +6,12 @@
 import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.rtsp.RtspMessage;
 import rtspproxy.rtsp.RtspRequest;
-import rtspproxy.rtsp.RtspResponse;
 
 /**
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,13 +6,11 @@
 import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.rtsp.RtspMessage;
-import rtspproxy.rtsp.RtspRequest;
 import rtspproxy.rtsp.RtspResponse;
 
 /**

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -11,10 +11,7 @@
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.mina.common.IoFilter;
-import org.apache.mina.common.IoFilterAdapter;
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -23,7 +20,6 @@
 import rtspproxy.jmx.JmxManageable;
 import rtspproxy.jmx.JmxManageable2;
 import rtspproxy.proxy.ProxyHandler;
-import rtspproxy.rtsp.RtspMessage;
 import rtspproxy.rtsp.RtspRequest;
 import rtspproxy.rtsp.RtspResponse;
 
@@ -31,155 +27,169 @@
  * @author bieniekr
  * 
  */
-public abstract class UrlRewritingFilter extends FilterBase implements JmxManageable {
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory.getLogger(UrlRewritingFilter.class);
+public abstract class UrlRewritingFilter extends FilterBase implements JmxManageable
+{
 
-	public static final String FilterNAME = &quot;rewriting&quot;;
+    /**
+     * Logger for this class
+     */
+    private static Logger log = LoggerFactory.getLogger( UrlRewritingFilter.class );
 
-	// the filter instance
-	protected UrlRewritingProvider provider;
+    public static final String FilterNAME = &quot;rewriting&quot;;
 
-	// list of exposed session attributes
-	private String[] exposedAttributes;
-	
-	/**
-	 * construct the IoFilter around the filter class denoted by the clazz name
-	 * parameter.
-	 */
-	public UrlRewritingFilter(String className, List&lt;Element&gt; configElements)
-			throws Exception {
-		super(FilterNAME, className, &quot;rewriting&quot;);
+    // the filter instance
+    protected UrlRewritingProvider provider;
 
-		this.provider = (UrlRewritingProvider)loadConfigInitProvider(className, 
-				UrlRewritingProvider.class, 
-				configElements);
-		
-		this.exposedAttributes = this.provider.getWantedSessionAttributes();
-		if(this.exposedAttributes == null)
-			this.exposedAttributes = new String[0];
-	}
+    // list of exposed session attributes
+    private String[] exposedAttributes;
 
-	public abstract void messageReceived(NextFilter nextFilter, IoSession session,
-			Object message) throws Exception;
-	
-	/**
-	 * process a request message
-	 * @return true if the caller should pass the message on, false if the message should not be
-	 * passed on
-	 */
-	protected boolean processRequest(IoSession session, RtspRequest req) {
-		boolean passOn = true;
-		
-		if (req.getUrl() != null) {
-			HashMap&lt;String, Object&gt; exposedSessionAttributes = new HashMap&lt;String, Object&gt;();
-			
-			for(String attr : this.exposedAttributes) {
-				logger.debug(&quot;exposing session attribute: &quot; + attr);
-				if(session.containsAttribute(attr)) {
-					Object o = session.getAttribute(attr);
-					
-					logger.debug(&quot;attribute &quot; + attr + &quot; found in session, val=&quot; + o);
-					exposedSessionAttributes.put(attr, o);
-				}
-				
-				if(ProxyHandler.containsSharedSessionAttribute(session, attr)) {
-					Object o = ProxyHandler.getSharedSessionAttribute(session, attr);
+    /**
+     * construct the IoFilter around the filter class denoted by the clazz name
+     * parameter.
+     */
+    public UrlRewritingFilter( String className, List&lt;Element&gt; configElements )
+            throws Exception
+    {
+        super( FilterNAME, className, &quot;rewriting&quot; );
 
-					logger.debug(&quot;attribute &quot; + attr + &quot; found in shared session map, val=&quot; + o);
-					exposedSessionAttributes.put(attr, o);
-				}
-			}
-			
-			UrlRewritingResult result = this.provider.rewriteRequestUrl(req.getUrl(), req.getVerb(), 
-					session.getRemoteAddress(), req.getHeaders(), exposedSessionAttributes); 
-			
-			if(result != null) {
-				URL rewritten = result.getRewrittenUrl();
+        this.provider = (UrlRewritingProvider) loadConfigInitProvider( className,
+                UrlRewritingProvider.class, configElements );
 
-				if (rewritten != null) {
-					logger.debug(&quot;changed request URL from '&quot; + req.getUrl()
-						+ &quot;' to '&quot; + rewritten + &quot;'&quot;);
+        this.exposedAttributes = this.provider.getWantedSessionAttributes();
+        if ( this.exposedAttributes == null )
+            this.exposedAttributes = new String[0];
+    }
 
-					req.setUrl(rewritten);
-				} else if(result.getResponse() != null) {
-					RtspResponse resp = result.getResponse();
+    @Override
+    public abstract void messageReceived( NextFilter nextFilter, IoSession session,
+            Object message ) throws Exception;
 
-					resp.setCommonHeaders();
-					resp.setSequenceNumber(req.getSequenceNumber());
-					if(resp.getHeader(&quot;Session&quot;) != null)
-						resp.setHeader(&quot;Session&quot;, req.getHeader(&quot;Session&quot;));
-					logger.debug(&quot;dropped  request, return response: &quot; + resp);
+    /**
+     * process a request message
+     * 
+     * @return true if the caller should pass the message on, false if the
+     *         message should not be passed on
+     */
+    protected boolean processRequest( IoSession session, RtspRequest req )
+    {
+        boolean passOn = true;
 
-					session.write(resp);
-					passOn = false;
-				}
-			}
-		}
-		
-		return passOn;
-	}
-	
-	/**
-	 * process a response message
-	 */
-	protected void processResponse(RtspResponse resp) {
-		switch (resp.getRequestVerb()) {
-		case DESCRIBE:
-			rewriteUrlHeader(&quot;Content-base&quot;, resp);
-			break;
-		case PLAY:
-			// rewriteUrlHeader(&quot;RTP-Info&quot;, resp);
-			break;
-		}		
-	}
-	
-	/**
-	 * rewrite a header
-	 */
-	private void rewriteUrlHeader(String headerName, RtspResponse resp) {
-		String oldHeader = resp.getHeader(headerName);
+        if ( req.getUrl() != null ) {
+            HashMap&lt;String, Object&gt; exposedSessionAttributes = new HashMap&lt;String, Object&gt;();
 
-		if (oldHeader != null) {
-			logger.debug(&quot;old content &quot; + headerName + &quot; header value: &quot;
-					+ oldHeader);
+            for ( String attr : this.exposedAttributes ) {
+                log.debug( &quot;exposing session attribute: {}&quot;, attr );
+                if ( session.containsAttribute( attr ) ) {
+                    Object o = session.getAttribute( attr );
 
-			try {
-				URL header = this.provider.rewriteResponseHeaderUrl(new URL(
-						oldHeader));
+                    log.debug( &quot;attribute {} found in session, val={}&quot;, attr, o );
+                    exposedSessionAttributes.put( attr, o );
+                }
 
-				if (header != null) {
-					logger.debug(&quot;changed header &quot; + headerName + &quot; to &quot;
-							+ header);
+                if ( ProxyHandler.containsSharedSessionAttribute( session, attr ) ) {
+                    Object o = ProxyHandler.getSharedSessionAttribute( session, attr );
 
-					resp.setHeader(headerName, header.toString());
-				}
-			} catch (MalformedURLException mue) {
-				logger.error(&quot;failed to parse &quot; + headerName + &quot; header&quot;, mue);
-			}
-		}
-	}
+                    log.debug( &quot;attribute {} found in shared session map, val={}&quot;, attr,
+                            o );
+                    exposedSessionAttributes.put( attr, o );
+                }
+            }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.jmx.JmxManageable#setMBeanServer(javax.management.MBeanServer)
-	 */
-	public void setMBeanServer(MBeanServer mbeanServer) {
-		if(this.provider instanceof JmxManageable)
-			((JmxManageable)this.provider).setMBeanServer(mbeanServer);
-	}
+            UrlRewritingResult result = this.provider.rewriteRequestUrl( req.getUrl(),
+                    req.getVerb(), session.getRemoteAddress(), req.getHeaders(),
+                    exposedSessionAttributes );
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.FilterBase#getDetailMBean()
-	 */
-	@Override
-	public ObjectName getDetailMBean() {
-		ObjectName name = null;
-		
-		if(this.provider instanceof JmxManageable2)
-			name = ((JmxManageable2)this.provider).getMBean();
-		
-		return name;
-	}
+            if ( result != null ) {
+                URL rewritten = result.getRewrittenUrl();
+
+                if ( rewritten != null ) {
+                    log.debug( &quot;changed request URL from '{}' to '{}'&quot;, req.getUrl(),
+                            rewritten );
+
+                    req.setUrl( rewritten );
+                } else if ( result.getResponse() != null ) {
+                    RtspResponse resp = result.getResponse();
+
+                    resp.setCommonHeaders();
+                    resp.setSequenceNumber( req.getSequenceNumber() );
+                    if ( resp.getHeader( &quot;Session&quot; ) != null )
+                        resp.setHeader( &quot;Session&quot;, req.getHeader( &quot;Session&quot; ) );
+                    log.debug( &quot;dropped  request, return response: {}&quot;, resp );
+
+                    session.write( resp );
+                    passOn = false;
+                }
+            }
+        }
+
+        return passOn;
+    }
+
+    /**
+     * process a response message
+     */
+    protected void processResponse( RtspResponse resp )
+    {
+        switch ( resp.getRequestVerb() )
+        {
+        case DESCRIBE:
+            rewriteUrlHeader( &quot;Content-base&quot;, resp );
+            break;
+        case PLAY:
+            // rewriteUrlHeader(&quot;RTP-Info&quot;, resp);
+            break;
+        }
+    }
+
+    /**
+     * rewrite a header
+     */
+    private void rewriteUrlHeader( String headerName, RtspResponse resp )
+    {
+        String oldHeader = resp.getHeader( headerName );
+
+        if ( oldHeader != null ) {
+            log.debug( &quot;old content: {} header value: {}&quot;, headerName, oldHeader );
+
+            try {
+                URL header = this.provider
+                        .rewriteResponseHeaderUrl( new URL( oldHeader ) );
+
+                if ( header != null ) {
+                    log.debug( &quot;changed header {} to {}&quot;, headerName, header );
+
+                    resp.setHeader( headerName, header.toString() );
+                }
+            } catch ( MalformedURLException mue ) {
+                log.error( &quot;failed to parse {} header: {}&quot;, headerName, mue );
+            }
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.jmx.JmxManageable#setMBeanServer(javax.management.MBeanServer)
+     */
+    public void setMBeanServer( MBeanServer mbeanServer )
+    {
+        if ( this.provider instanceof JmxManageable )
+            ((JmxManageable) this.provider).setMBeanServer( mbeanServer );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getDetailMBean()
+     */
+    @Override
+    public ObjectName getDetailMBean()
+    {
+        ObjectName name = null;
+
+        if ( this.provider instanceof JmxManageable2 )
+            name = ((JmxManageable2) this.provider).getMBean();
+
+        return name;
+    }
 }

Added: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -0,0 +1,126 @@
+/**
+ * 
+ */
+package rtspproxy.filter.tracking;
+
+import java.net.URL;
+
+import org.apache.mina.common.IoSession;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import rtspproxy.rtsp.RtspRequest;
+import rtspproxy.rtsp.RtspTransport;
+
+/**
+ * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
+ * 
+ */
+public class RdtSessionClientTrackingFilter extends RdtSessionTrackingFilter {
+
+	private static Logger logger = LoggerFactory
+			.getLogger(RdtSessionClientTrackingFilter.class);
+
+	// session attribute
+	private static final String SessionAttribute = &quot;lastSetupURL&quot;;
+
+	/**
+	 * @param filterName
+	 * @param typeName
+	 */
+	public RdtSessionClientTrackingFilter() {
+		super(&quot;client&quot;);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.mina.common.IoFilterAdapter#messageSent(org.apache.mina.common.IoFilter.NextFilter,
+	 *      org.apache.mina.common.IoSession, java.lang.Object)
+	 */
+	@Override
+	public void messageSent(NextFilter nextFilter, IoSession session,
+			Object message) throws Exception {
+		handleMessage(session, message);
+
+		logger.debug(&quot;sending response to client: &quot; + message);
+
+		nextFilter.messageSent(session, message);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.mina.common.IoFilterAdapter#messageReceived(org.apache.mina.common.IoFilter.NextFilter,
+	 *      org.apache.mina.common.IoSession, java.lang.Object)
+	 */
+	@Override
+	public void messageReceived(NextFilter nextFilter, IoSession session,
+			Object message) throws Exception {
+		if (message instanceof RtspRequest) {
+			RtspRequest req = (RtspRequest) message;
+
+			logger.debug(&quot;having RTSP request message, message=&quot; + req);
+			if (req.getVerb() == RtspRequest.Verb.SETUP) {
+				logger.debug(&quot;having SETUP request&quot;);
+
+				if (req.getUrl() != null) {
+					URL url = req.getUrl();
+
+					logger.debug(&quot;requesting setup for &quot; + url);
+					session.setAttribute(SessionAttribute, url);
+				}
+			}
+		}
+
+		nextFilter.messageReceived(session, message);
+	}
+
+	@Override
+	protected void handleTransportRdtUdpUnicast(IoSession session,
+			RtspTransport transport) {
+		logger.debug(&quot;handling client-side RDT/UDP/unicast header, header=&quot;
+				+ transport);
+
+        logger.debug( &quot;RDT tracking disabled. (merlimat)&quot; );
+        // TODO: RDT tracking disabled. (merlimat)
+        /*
+		try {
+			if (ProxyHandler.containsSharedSessionAttribute(session,
+					RdtSessionToken.SessionAttribute)) {
+				RdtSessionToken token = (RdtSessionToken) ProxyHandler
+						.getSharedSessionAttribute(session,
+								RdtSessionToken.SessionAttribute);
+
+				logger.debug(&quot;have session token, server_addr=&quot;
+						+ token.getRemoteServer() + &quot;, server_port=&quot;
+						+ token.getRemotePort() + &quot;, client_addr=&quot;
+						+ session.getRemoteAddress() + &quot;, client_port=&quot;
+						+ transport.getClientPort()[0]);
+
+				// now we can create and initialise
+				URL url = (URL) session.getAttribute(SessionAttribute);
+
+				InetSocketAddress serverAddr = new InetSocketAddress(
+						((InetSocketAddress) token.getRemoteServer())
+								.getAddress(), token.getRemotePort());
+
+				RdtTrack track;
+				if ((track = (RdtTrack) RdtTrack.getByServerAddress(serverAddr)) == null) {
+					logger.debug(&quot;creating new RdtTrack&quot;);
+
+					track = new RdtTrack(url.toString());
+
+					track.setClientAddress(((InetSocketAddress) session
+							.getRemoteAddress()).getAddress(), transport
+							.getClientPort()[0]);
+					track.setServerAddress(serverAddr.getAddress(), serverAddr
+							.getPort());
+				}
+			}
+		} catch (Throwable t) {
+			logger.error(&quot;runtime exception in RDP session handling code&quot;, t);
+		}
+        */
+	}
+}


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Added: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -0,0 +1,82 @@
+/**
+ * 
+ */
+package rtspproxy.filter.tracking;
+
+import org.apache.mina.common.IoSession;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import rtspproxy.config.Config;
+import rtspproxy.filter.FilterBase;
+import rtspproxy.rtsp.RtspRequest;
+import rtspproxy.rtsp.RtspResponse;
+import rtspproxy.rtsp.RtspTransport;
+import rtspproxy.rtsp.RtspTransportList;
+
+/**
+ * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
+ *
+ */
+public abstract class RdtSessionTrackingFilter extends FilterBase {
+	
+	private static Logger logger = LoggerFactory.getLogger(RdtSessionTrackingFilter.class);
+
+	public static final String FilterNAME = &quot;rdtTrackingFilter&quot;;
+
+	/**
+	 * @param filterName
+	 * @param className
+	 * @param typeName
+	 */
+	public RdtSessionTrackingFilter(String typeName) {
+		super(FilterNAME, typeName);
+	}
+
+	/**
+	 * check the message for following conditions
+	 */
+	protected void handleMessage(IoSession session, Object message) {
+		if(Config.proxyTransportRdtEnable.getValue() &amp;&amp; message instanceof RtspResponse) {
+			RtspResponse resp = (RtspResponse)message;
+			
+			logger.debug(&quot;analyzing RTSP response message&quot;);
+			if(resp.getRequestVerb() == RtspRequest.Verb.SETUP) {
+				logger.debug(&quot;found SETUP response&quot;);
+				
+				String transHdr = resp.getHeader(&quot;Transport&quot;);
+				
+				if(transHdr != null) {
+					logger.debug(&quot;SETUP response has transport header: &quot; + transHdr);
+					
+					RtspTransportList rtl = new RtspTransportList(transHdr);
+					
+					if(rtl.count() == 1) {
+						// at this point we can only have one transport. Everything else is a protocol violation
+						RtspTransport transport = rtl.get(0);
+						
+						if(transport.getTransportProtocol() == RtspTransport.TransportProtocol.RDT) {
+							logger.debug(&quot;found RDT transport protocol&quot;);
+							
+							if(transport.getDeliveryType() == RtspTransport.DeliveryType.unicast
+									&amp;&amp; transport.getLowerTransport() == RtspTransport.LowerTransport.UDP) {
+								logger.debug(&quot;found RDT/UDP/unicast transport header, server_port=&quot; 
+										+ transport.getServerPort()[0] + &quot;, client_port=&quot; 
+										+ transport.getClientPort()[0]);
+								
+								handleTransportRdtUdpUnicast(session, transport);
+							}
+						}
+					} else 
+						logger.error(&quot;found invalid transport header: &quot; + transHdr);
+				}
+			}
+		}
+	}
+	
+	/**
+	 * handle the extracted RTSP response RDT/UDP/unicast transport header
+	 */
+	protected abstract void handleTransportRdtUdpUnicast(IoSession session, RtspTransport transport);
+	
+}


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Authenticator.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Authenticator.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Authenticator.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -40,45 +40,46 @@
 public class Authenticator implements JMXAuthenticator
 {
 
-	private static Logger log = LoggerFactory.getLogger( Authenticator.class );
+    private static Logger log = LoggerFactory.getLogger( Authenticator.class );
 
-	public Subject authenticate( Object credentials ) throws SecurityException
-	{
-		if ( !( credentials instanceof String[] ) )
-			throw new SecurityException( &quot;Bad credentials&quot; );
+    public Subject authenticate( Object credentials ) throws SecurityException
+    {
+        if ( !(credentials instanceof String[]) )
+            throw new SecurityException( &quot;Bad credentials&quot; );
 
-		String[] creds = (String[]) credentials;
-		if ( creds.length != 2 )
-			throw new SecurityException( &quot;Bad credentials&quot; );
+        String[] creds = (String[]) credentials;
+        if ( creds.length != 2 )
+            throw new SecurityException( &quot;Bad credentials&quot; );
 
-		String user = creds[0];
-		String password = creds[1];
+        String user = creds[0];
+        String password = creds[1];
 
-		if ( user == null ) {
-			log.info( &quot;Authentication failed: null username&quot; );
-			throw new SecurityException( &quot;Bad user name&quot; );
-		}
+        if ( user == null ) {
+            log.info( &quot;Authentication failed: null username&quot; );
+            throw new SecurityException( &quot;Bad user name&quot; );
+        }
 
-		if ( password == null ) {
-			log.info( &quot;Authentication failed for user &quot; + user + &quot; null password.&quot; );
-			throw new SecurityException( &quot;Bad password&quot; );
-		}
+        if ( password == null ) {
+            log.info( &quot;Authentication failed for user '{}': null password.&quot;, user );
+            throw new SecurityException( &quot;Bad password&quot; );
+        }
 
-		// Expected values
-		String adminUser = Config.proxyManagementUser.getValue();
-		String adminPassword = Config.proxyManagementPassword.getValue();
+        // Expected values
+        String adminUser = Config.jmxUser.getValue();
+        String adminPassword = Config.jmxPassword.getValue();
 
-		if ( !user.equals( adminUser ) || !password.equals( adminPassword ) ) {
-			log.info( &quot;Authentication failed for user &quot; + user
-					+ &quot;. Invalid username or password.&quot; );
-			throw new SecurityException( &quot;Invalid username or password.&quot; );
-		}
+        if ( !user.equals( adminUser ) || !password.equals( adminPassword ) ) {
+            log.info( &quot;Authentication failed for user {}. Invalid username or password.&quot;,
+                    user );
+            throw new SecurityException( &quot;Invalid username or password.&quot; );
+        }
 
-		log.debug( &quot;Successful Authentication for user &quot; + user );
-		Set&lt;JMXPrincipal&gt; principals = new HashSet&lt;JMXPrincipal&gt;();
-		principals.add( new JMXPrincipal( user ) );
-		Subject subject = new Subject( true, principals, Collections.EMPTY_SET,
-				Collections.EMPTY_SET );
-		return subject;
-	}
+        log.debug( &quot;Successful Authentication for user '{}'&quot;, user );
+        
+        Set&lt;JMXPrincipal&gt; principals = new HashSet&lt;JMXPrincipal&gt;();
+        principals.add( new JMXPrincipal( user ) );
+        Subject subject = new Subject( true, principals, Collections.EMPTY_SET,
+                Collections.EMPTY_SET );
+        return subject;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -134,14 +134,14 @@
 
 	private void startWebConsole() throws Exception
 	{
-		boolean enabled = Config.proxyManagementWebEnable.getValue();
+		boolean enabled = Config.jmxWebEnable.getValue();
 		if ( !enabled )
 			return;
 
-		String host = Config.proxyManagementHost.getValue();
-		int port = Config.proxyManagementWebPort.getValue();
-		String user = Config.proxyManagementUser.getValue();
-		String password = Config.proxyManagementPassword.getValue();
+		String host = Config.jmxAddress.getValue();
+		int port = Config.jmxWebPort.getValue();
+		String user = Config.jmxUser.getValue();
+		String password = Config.jmxPassword.getValue();
 
 		HttpAdaptor adaptor = new HttpAdaptor();
 		ObjectName name = new ObjectName( &quot;Server:name=HttpAdaptor&quot; );
@@ -164,7 +164,7 @@
 	@SuppressWarnings(&quot;unchecked&quot;)
 	private void startConnectorServer() throws Exception
 	{
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -177,7 +177,7 @@
 		int namingPort = ( (Integer) mbeanServer.getAttribute( namingName, &quot;Port&quot; ) ).intValue();
 
 		String jndiPath = &quot;/rtspproxy&quot;;
-		String host = Config.proxyManagementHost.getValue();
+		String host = Config.jmxAddress.getValue();
 		String uri = &quot;service:jmx:<A HREF="rmi://">rmi://</A>&quot; + host + &quot;/jndi/<A HREF="rmi://">rmi://</A>&quot; + host + &quot;:&quot;
 				+ namingPort + jndiPath;
 
@@ -207,7 +207,7 @@
 	 * register a MBean as a management facade to a filter implementation
 	 */
 	public void registerFilter(FilterBase filter) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -287,7 +287,7 @@
 	 * 
 	 */
 	public void registerProxySession(ProxySession session) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -306,7 +306,7 @@
 	 * unregister a proxy session
 	 */
 	public void unregisterProxySession(ProxySession session) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -318,9 +318,9 @@
 				session.setObjectName(null);
 			}
 		} catch(InstanceNotFoundException infe) {
-			log.debug(&quot;internal problem: MBean not found, name=&quot; + session.getObjectName(), infe);
+			log.debug(&quot;internal problem: MBean not found, name={}&quot;, session.getObjectName(), infe);
 		} catch(Exception e) {
-			log.error( &quot;failed to register proxy session MBean: session=&quot; + session, e );
+			log.error( &quot;failed to register proxy session MBean: session={}&quot;, session, e );
 		}
 		
 	}
@@ -330,7 +330,7 @@
 	 * 
 	 */
 	public void registerPortRangeRtpServerSessionfactory(PortrangeRtpServerSessionFactory sessionFactory) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -348,7 +348,7 @@
 	 * 
 	 */
 	public void unregisterPortRangeRtpServerSessionfactory() {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -367,7 +367,7 @@
 	 * register a generated RTP server session in the portrange case
 	 */
 	public void registerPortrangeRtpServerSession(PortrangeRtpServerSession session) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 		
@@ -378,7 +378,7 @@
 			mbeanServer.registerMBean(mbean, name);
 			session.setObjectName(name);
 		} catch(Exception e) {
-			log.error( &quot;failed to register proxy session MBean: session=&quot; + session, e );
+			log.error( &quot;failed to register proxy session MBean: session={}&quot;, session, e );
 		}
 	}
 	
@@ -386,7 +386,7 @@
 	 * register a generated RTP server session in the portrange case
 	 */
 	public void unregisterPortrangeRtpServerSession(PortrangeRtpServerSession session) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 		
@@ -400,7 +400,7 @@
 		} catch(InstanceNotFoundException infe) {
 			log.debug(&quot;internal problem: MBean not found, name=&quot; + session.getObjectName(), infe);
 		} catch(Exception e) {
-			log.error( &quot;failed to register proxy session MBean: session=&quot; + session, e );
+			log.error( &quot;failed to register proxy session MBean: session={}&quot;, session, e );
 		}		
 	}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,16 +6,20 @@
 import javax.management.MBeanServer;
 
 /**
- * This interface is implemented by components that wish you expose its own MBeans to the
- * managment interface.
+ * This interface is implemented by components that wish you expose its own
+ * MBeans to the managment interface.
  * 
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
  */
-public interface JmxManageable {
-	/**
-	 * set the MBeanServer instance. This method becomes called after the MBean managing the
-	 * component has been created and attached to the MBeanServer.
-	 * @param mbeanServer the MBeanServer instance used to manage the RTSPProxy.
-	 */
-	public void setMBeanServer(MBeanServer mbeanServer);
+public interface JmxManageable
+{
+
+    /**
+     * Set the MBeanServer instance. This method becomes called after the MBean
+     * managing the component has been created and attached to the MBeanServer.
+     * 
+     * @param mbeanServer
+     *            the MBeanServer instance used to manage the RTSPProxy.
+     */
+    public void setMBeanServer( MBeanServer mbeanServer );
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/ParametersMBean.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/ParametersMBean.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/ParametersMBean.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -157,7 +157,7 @@
 		for ( Object obj : attributes ) {
 
 			attr = (Attribute) obj;
-			parameter = Config.getParameter( ((Attribute) attr).getName() );
+			parameter = Config.getParameter( attr.getName() );
 			if ( parameter == null )
 				continue;
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -2,47 +2,49 @@
 
 /**
  * Encodes and decodes to and from Base64 notation.
- *
+ * 
  * &lt;p&gt;
  * Change Log:
  * &lt;/p&gt;
  * &lt;ul&gt;
- *  &lt;li&gt;v2.1 - Cleaned up javadoc comments and unused variables and methods. Added
- *   some convenience methods for reading and writing to and from files.&lt;/li&gt;
- *  &lt;li&gt;v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems
- *   with other encodings (like EBCDIC).&lt;/li&gt;
- *  &lt;li&gt;v2.0.1 - Fixed an error when decoding a single byte, that is, when the
- *   encoded data was a single byte.&lt;/li&gt;
- *  &lt;li&gt;v2.0 - I got rid of methods that used booleans to set options. 
- *   Now everything is more consolidated and cleaner. The code now detects
- *   when data that's being decoded is gzip-compressed and will decompress it
- *   automatically. Generally things are cleaner. You'll probably have to
- *   change some method calls that you were making to support the new
- *   options format (&lt;tt&gt;int&lt;/tt&gt;s that you &quot;OR&quot; together).&lt;/li&gt;
- *  &lt;li&gt;v1.5.1 - Fixed bug when decompressing and decoding to a             
- *   byte[] using &lt;tt&gt;decode( String s, boolean gzipCompressed )&lt;/tt&gt;.      
- *   Added the ability to &quot;suspend&quot; encoding in the Output Stream so        
- *   you can turn on and off the encoding if you need to embed base64       
- *   data in an otherwise &quot;normal&quot; stream (like an XML file).&lt;/li&gt;  
- *  &lt;li&gt;v1.5 - Output stream pases on flush() command but doesn't do anything itself.
- *      This helps when using GZIP streams.
- *      Added the ability to GZip-compress objects before encoding them.&lt;/li&gt;
- *  &lt;li&gt;v1.4 - Added helper methods to read/write files.&lt;/li&gt;
- *  &lt;li&gt;v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.&lt;/li&gt;
- *  &lt;li&gt;v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream
- *      where last buffer being read, if not completely full, was not returned.&lt;/li&gt;
- *  &lt;li&gt;v1.3.4 - Fixed when &quot;improperly padded stream&quot; error was thrown at the wrong time.&lt;/li&gt;
- *  &lt;li&gt;v1.3.3 - Fixed I/O streams which were totally messed up.&lt;/li&gt;
+ * &lt;li&gt;v2.1 - Cleaned up javadoc comments and unused variables and methods.
+ * Added some convenience methods for reading and writing to and from files.&lt;/li&gt;
+ * &lt;li&gt;v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on
+ * systems with other encodings (like EBCDIC).&lt;/li&gt;
+ * &lt;li&gt;v2.0.1 - Fixed an error when decoding a single byte, that is, when the
+ * encoded data was a single byte.&lt;/li&gt;
+ * &lt;li&gt;v2.0 - I got rid of methods that used booleans to set options. Now
+ * everything is more consolidated and cleaner. The code now detects when data
+ * that's being decoded is gzip-compressed and will decompress it automatically.
+ * Generally things are cleaner. You'll probably have to change some method
+ * calls that you were making to support the new options format (&lt;tt&gt;int&lt;/tt&gt;s
+ * that you &quot;OR&quot; together).&lt;/li&gt;
+ * &lt;li&gt;v1.5.1 - Fixed bug when decompressing and decoding to a byte[] using
+ * &lt;tt&gt;decode( String s, boolean gzipCompressed )&lt;/tt&gt;. Added the ability to
+ * &quot;suspend&quot; encoding in the Output Stream so you can turn on and off the
+ * encoding if you need to embed base64 data in an otherwise &quot;normal&quot; stream
+ * (like an XML file).&lt;/li&gt;
+ * &lt;li&gt;v1.5 - Output stream pases on flush() command but doesn't do anything
+ * itself. This helps when using GZIP streams. Added the ability to
+ * GZip-compress objects before encoding them.&lt;/li&gt;
+ * &lt;li&gt;v1.4 - Added helper methods to read/write files.&lt;/li&gt;
+ * &lt;li&gt;v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.&lt;/li&gt;
+ * &lt;li&gt;v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input
+ * stream where last buffer being read, if not completely full, was not
+ * returned.&lt;/li&gt;
+ * &lt;li&gt;v1.3.4 - Fixed when &quot;improperly padded stream&quot; error was thrown at the
+ * wrong time.&lt;/li&gt;
+ * &lt;li&gt;v1.3.3 - Fixed I/O streams which were totally messed up.&lt;/li&gt;
  * &lt;/ul&gt;
- *
+ * 
  * &lt;p&gt;
- * I am placing this code in the Public Domain. Do with it as you will.
- * This software comes with no guarantees or warranties but with
- * plenty of well-wishing instead!
- * Please visit &lt;a href=&quot;<A HREF="http://iharder.net/base64">http://iharder.net/base64</A>&quot;&gt;<A HREF="http://iharder.net/base64&lt;/a">http://iharder.net/base64&lt;/a</A>&gt;
- * periodically to check for updates or to contribute improvements.
+ * I am placing this code in the Public Domain. Do with it as you will. This
+ * software comes with no guarantees or warranties but with plenty of
+ * well-wishing instead! Please visit &lt;a
+ * href=&quot;<A HREF="http://iharder.net/base64">http://iharder.net/base64</A>&quot;&gt;<A HREF="http://iharder.net/base64&lt;/a">http://iharder.net/base64&lt;/a</A>&gt; periodically
+ * to check for updates or to contribute improvements.
  * &lt;/p&gt;
- *
+ * 
  * @author Robert Harder
  * @author <A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">rob at iharder.net</A>
  * @version 2.1
@@ -50,1300 +52,1389 @@
 public class Base64
 {
 
-	/* ********  P U B L I C   F I E L D S  ******** */
+    /* ******** P U B L I C F I E L D S ******** */
 
-	/** No options specified. Value is zero. */
-	public final static int NO_OPTIONS = 0;
+    /** No options specified. Value is zero. */
+    public final static int NO_OPTIONS = 0;
 
-	/** Specify encoding. */
-	public final static int ENCODE = 1;
+    /** Specify encoding. */
+    public final static int ENCODE = 1;
 
-	/** Specify decoding. */
-	public final static int DECODE = 0;
+    /** Specify decoding. */
+    public final static int DECODE = 0;
 
-	/** Specify that data should be gzip-compressed. */
-	public final static int GZIP = 2;
+    /** Specify that data should be gzip-compressed. */
+    public final static int GZIP = 2;
 
-	/** Don't break lines when encoding (violates strict Base64 specification) */
-	public final static int DONT_BREAK_LINES = 8;
+    /** Don't break lines when encoding (violates strict Base64 specification) */
+    public final static int DONT_BREAK_LINES = 8;
 
-	/* ********  P R I V A T E   F I E L D S  ******** */
+    /* ******** P R I V A T E F I E L D S ******** */
 
-	/** Maximum line length (76) of Base64 output. */
-	private final static int MAX_LINE_LENGTH = 76;
+    /** Maximum line length (76) of Base64 output. */
+    private final static int MAX_LINE_LENGTH = 76;
 
-	/** The equals sign (=) as a byte. */
-	private final static byte EQUALS_SIGN = (byte) '=';
+    /** The equals sign (=) as a byte. */
+    private final static byte EQUALS_SIGN = (byte) '=';
 
-	/** The new line character (\n) as a byte. */
-	private final static byte NEW_LINE = (byte) '\n';
+    /** The new line character (\n) as a byte. */
+    private final static byte NEW_LINE = (byte) '\n';
 
-	/** Preferred encoding. */
-	private final static String PREFERRED_ENCODING = &quot;UTF-8&quot;;
+    /** Preferred encoding. */
+    private final static String PREFERRED_ENCODING = &quot;UTF-8&quot;;
 
-	/** The 64 valid Base64 values. */
-	private final static byte[] ALPHABET;
-	private final static byte[] _NATIVE_ALPHABET = /* May be something funny like EBCDIC */
-	{ (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G',
-			(byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M',
-			(byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S',
-			(byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y',
-			(byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
-			(byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k',
-			(byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q',
-			(byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w',
-			(byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2',
-			(byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
-			(byte) '9', (byte) '+', (byte) '/' };
+    /** The 64 valid Base64 values. */
+    private final static byte[] ALPHABET;
 
-	/** Determine which ALPHABET to use. */
-	static {
-		byte[] __bytes;
-		try {
-			__bytes = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.getBytes( PREFERRED_ENCODING );
-		} // end try
-		catch ( java.io.UnsupportedEncodingException use ) {
-			__bytes = _NATIVE_ALPHABET; // Fall back to native encoding
-		} // end catch
-		ALPHABET = __bytes;
-	} // end static
+    private final static byte[] _NATIVE_ALPHABET = /*
+                                                     * May be something funny
+                                                     * like EBCDIC
+                                                     */
+    { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G',
+            (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M',
+            (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S',
+            (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y',
+            (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+            (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k',
+            (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q',
+            (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w',
+            (byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2',
+            (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+            (byte) '9', (byte) '+', (byte) '/' };
 
-	/** 
-	 * Translates a Base64 value to either its 6-bit reconstruction value
-	 * or a negative number indicating some other meaning.
-	 **/
-	private final static byte[] DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
-			-5, -5, // Whitespace: Tab and Linefeed
-			-9, -9, // Decimal 11 - 12
-			-5, // Whitespace: Carriage Return
-			-9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
-			-9, -9, -9, -9, -9, // Decimal 27 - 31
-			-5, // Whitespace: Space
-			-9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
-			62, // Plus sign at decimal 43
-			-9, -9, -9, // Decimal 44 - 46
-			63, // Slash at decimal 47
-			52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
-			-9, -9, -9, // Decimal 58 - 60
-			-1, // Equals sign at decimal 61
-			-9, -9, -9, // Decimal 62 - 64
-			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
-			14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
-			-9, -9, -9, -9, -9, -9, // Decimal 91 - 96
-			26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
-			39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
-			-9, -9, -9, -9 // Decimal 123 - 126
-	/*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
-	};
+    /** Determine which ALPHABET to use. */
+    static {
+        byte[] __bytes;
+        try {
+            __bytes = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;
+                    .getBytes( PREFERRED_ENCODING );
+        } // end try
+        catch ( java.io.UnsupportedEncodingException use ) {
+            __bytes = _NATIVE_ALPHABET; // Fall back to native encoding
+        } // end catch
+        ALPHABET = __bytes;
+    } // end static
 
-	// I think I end up not using the BAD_ENCODING indicator.
-	//private final static byte BAD_ENCODING    = -9; // Indicates error in encoding
-	private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding
-	private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding
+    /**
+     * Translates a Base64 value to either its 6-bit reconstruction value or a
+     * negative number indicating some other meaning.
+     */
+    private final static byte[] DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal
+            // 0 -
+            // 8
+            -5, -5, // Whitespace: Tab and Linefeed
+            -9, -9, // Decimal 11 - 12
+            -5, // Whitespace: Carriage Return
+            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
+            // 26
+            -9, -9, -9, -9, -9, // Decimal 27 - 31
+            -5, // Whitespace: Space
+            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
+            62, // Plus sign at decimal 43
+            -9, -9, -9, // Decimal 44 - 46
+            63, // Slash at decimal 47
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+            -9, -9, -9, // Decimal 58 - 60
+            -1, // Equals sign at decimal 61
+            -9, -9, -9, // Decimal 62 - 64
+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A'
+            // through 'N'
+            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O'
+            // through 'Z'
+            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
+            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a'
+            // through 'm'
+            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n'
+            // through 'z'
+            -9, -9, -9, -9 // Decimal 123 - 126
+    /*
+     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 140 - 152
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 166 - 178
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 205 - 217
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 231 - 243
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
+     */
+    };
 
-	/** Defeats instantiation. */
-	private Base64()
-	{
-	}
+    // I think I end up not using the BAD_ENCODING indicator.
+    // private final static byte BAD_ENCODING = -9; // Indicates error in
+    // encoding
+    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in
 
-	/* ********  E N C O D I N G   M E T H O D S  ******** */
+    // encoding
 
-	/**
-	 * Encodes up to the first three bytes of array &lt;var&gt;threeBytes&lt;/var&gt;
-	 * and returns a four-byte array in Base64 notation.
-	 * The actual number of significant bytes in your array is
-	 * given by &lt;var&gt;numSigBytes&lt;/var&gt;.
-	 * The array &lt;var&gt;threeBytes&lt;/var&gt; needs only be as big as
-	 * &lt;var&gt;numSigBytes&lt;/var&gt;.
-	 * Code can reuse a byte array by passing a four-byte array as &lt;var&gt;b4&lt;/var&gt;.
-	 *
-	 * @param b4 A reusable byte array to reduce array instantiation
-	 * @param threeBytes the array to convert
-	 * @param numSigBytes the number of significant bytes in your array
-	 * @return four byte array in Base64 notation.
-	 * @since 1.5.1
-	 */
-	private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes )
-	{
-		encode3to4( threeBytes, 0, numSigBytes, b4, 0 );
-		return b4;
-	} // end encode3to4
+    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in
 
-	/**
-	 * Encodes up to three bytes of the array &lt;var&gt;source&lt;/var&gt;
-	 * and writes the resulting four Base64 bytes to &lt;var&gt;destination&lt;/var&gt;.
-	 * The source and destination arrays can be manipulated
-	 * anywhere along their length by specifying 
-	 * &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;.
-	 * This method does not check to make sure your arrays
-	 * are large enough to accomodate &lt;var&gt;srcOffset&lt;/var&gt; + 3 for
-	 * the &lt;var&gt;source&lt;/var&gt; array or &lt;var&gt;destOffset&lt;/var&gt; + 4 for
-	 * the &lt;var&gt;destination&lt;/var&gt; array.
-	 * The actual number of significant bytes in your array is
-	 * given by &lt;var&gt;numSigBytes&lt;/var&gt;.
-	 *
-	 * @param source the array to convert
-	 * @param srcOffset the index where conversion begins
-	 * @param numSigBytes the number of significant bytes in your array
-	 * @param destination the array to hold the conversion
-	 * @param destOffset the index where output will be put
-	 * @return the &lt;var&gt;destination&lt;/var&gt; array
-	 * @since 1.3
-	 */
-	private static byte[] encode3to4( byte[] source, int srcOffset, int numSigBytes,
-			byte[] destination, int destOffset )
-	{
-		//           1         2         3  
-		// 01234567890123456789012345678901 Bit position
-		// --------000000001111111122222222 Array position from threeBytes
-		// --------|    ||    ||    ||    | Six bit groups to index ALPHABET
-		//          &gt;&gt;18  &gt;&gt;12  &gt;&gt; 6  &gt;&gt; 0  Right shift necessary
-		//                0x3f  0x3f  0x3f  Additional AND
+    // encoding
 
-		// Create buffer with zero-padding if there are only one or two
-		// significant bytes passed in the array.
-		// We have to shift left 24 in order to flush out the 1's that appear
-		// when Java treats a value as negative that is cast from a byte to an int.
-		int inBuff = ( numSigBytes &gt; 0 ? ( ( source[srcOffset] &lt;&lt; 24 ) &gt;&gt;&gt; 8 ) : 0 )
-				| ( numSigBytes &gt; 1 ? ( ( source[srcOffset + 1] &lt;&lt; 24 ) &gt;&gt;&gt; 16 ) : 0 )
-				| ( numSigBytes &gt; 2 ? ( ( source[srcOffset + 2] &lt;&lt; 24 ) &gt;&gt;&gt; 24 ) : 0 );
+    /** Defeats instantiation. */
+    private Base64()
+    {
+    }
 
-		switch ( numSigBytes ) {
-			case 3:
-				destination[destOffset] = ALPHABET[( inBuff &gt;&gt;&gt; 18 )];
-				destination[destOffset + 1] = ALPHABET[( inBuff &gt;&gt;&gt; 12 ) &amp; 0x3f];
-				destination[destOffset + 2] = ALPHABET[( inBuff &gt;&gt;&gt; 6 ) &amp; 0x3f];
-				destination[destOffset + 3] = ALPHABET[( inBuff ) &amp; 0x3f];
-				return destination;
+    /* ******** E N C O D I N G M E T H O D S ******** */
 
-			case 2:
-				destination[destOffset] = ALPHABET[( inBuff &gt;&gt;&gt; 18 )];
-				destination[destOffset + 1] = ALPHABET[( inBuff &gt;&gt;&gt; 12 ) &amp; 0x3f];
-				destination[destOffset + 2] = ALPHABET[( inBuff &gt;&gt;&gt; 6 ) &amp; 0x3f];
-				destination[destOffset + 3] = EQUALS_SIGN;
-				return destination;
+    /**
+     * Encodes up to the first three bytes of array &lt;var&gt;threeBytes&lt;/var&gt; and
+     * returns a four-byte array in Base64 notation. The actual number of
+     * significant bytes in your array is given by &lt;var&gt;numSigBytes&lt;/var&gt;. The
+     * array &lt;var&gt;threeBytes&lt;/var&gt; needs only be as big as &lt;var&gt;numSigBytes&lt;/var&gt;.
+     * Code can reuse a byte array by passing a four-byte array as &lt;var&gt;b4&lt;/var&gt;.
+     * 
+     * @param b4
+     *            A reusable byte array to reduce array instantiation
+     * @param threeBytes
+     *            the array to convert
+     * @param numSigBytes
+     *            the number of significant bytes in your array
+     * @return four byte array in Base64 notation.
+     * @since 1.5.1
+     */
+    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes )
+    {
+        encode3to4( threeBytes, 0, numSigBytes, b4, 0 );
+        return b4;
+    } // end encode3to4
 
-			case 1:
-				destination[destOffset] = ALPHABET[( inBuff &gt;&gt;&gt; 18 )];
-				destination[destOffset + 1] = ALPHABET[( inBuff &gt;&gt;&gt; 12 ) &amp; 0x3f];
-				destination[destOffset + 2] = EQUALS_SIGN;
-				destination[destOffset + 3] = EQUALS_SIGN;
-				return destination;
+    /**
+     * Encodes up to three bytes of the array &lt;var&gt;source&lt;/var&gt; and writes the
+     * resulting four Base64 bytes to &lt;var&gt;destination&lt;/var&gt;. The source and
+     * destination arrays can be manipulated anywhere along their length by
+     * specifying &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;. This method
+     * does not check to make sure your arrays are large enough to accomodate
+     * &lt;var&gt;srcOffset&lt;/var&gt; + 3 for the &lt;var&gt;source&lt;/var&gt; array or
+     * &lt;var&gt;destOffset&lt;/var&gt; + 4 for the &lt;var&gt;destination&lt;/var&gt; array. The
+     * actual number of significant bytes in your array is given by
+     * &lt;var&gt;numSigBytes&lt;/var&gt;.
+     * 
+     * @param source
+     *            the array to convert
+     * @param srcOffset
+     *            the index where conversion begins
+     * @param numSigBytes
+     *            the number of significant bytes in your array
+     * @param destination
+     *            the array to hold the conversion
+     * @param destOffset
+     *            the index where output will be put
+     * @return the &lt;var&gt;destination&lt;/var&gt; array
+     * @since 1.3
+     */
+    private static byte[] encode3to4( byte[] source, int srcOffset, int numSigBytes,
+            byte[] destination, int destOffset )
+    {
+        // 1 2 3
+        // 01234567890123456789012345678901 Bit position
+        // --------000000001111111122222222 Array position from threeBytes
+        // --------| || || || | Six bit groups to index ALPHABET
+        // &gt;&gt;18 &gt;&gt;12 &gt;&gt; 6 &gt;&gt; 0 Right shift necessary
+        // 0x3f 0x3f 0x3f Additional AND
 
-			default:
-				return destination;
-		} // end switch
-	} // end encode3to4
+        // Create buffer with zero-padding if there are only one or two
+        // significant bytes passed in the array.
+        // We have to shift left 24 in order to flush out the 1's that appear
+        // when Java treats a value as negative that is cast from a byte to an
+        // int.
+        int inBuff = (numSigBytes &gt; 0 ? ((source[srcOffset] &lt;&lt; 24) &gt;&gt;&gt; 8) : 0)
+                | (numSigBytes &gt; 1 ? ((source[srcOffset + 1] &lt;&lt; 24) &gt;&gt;&gt; 16) : 0)
+                | (numSigBytes &gt; 2 ? ((source[srcOffset + 2] &lt;&lt; 24) &gt;&gt;&gt; 24) : 0);
 
-	/**
-	 * Serializes an object and returns the Base64-encoded
-	 * version of that serialized object. If the object
-	 * cannot be serialized or there is another error,
-	 * the method will return &lt;tt&gt;null&lt;/tt&gt;.
-	 * The object is not GZip-compressed before being encoded.
-	 *
-	 * @param serializableObject The object to encode
-	 * @return The Base64-encoded object
-	 * @since 1.4
-	 */
-	public static String encodeObject( java.io.Serializable serializableObject )
-	{
-		return encodeObject( serializableObject, NO_OPTIONS );
-	} // end encodeObject
+        switch ( numSigBytes )
+        {
+        case 3:
+            destination[destOffset] = ALPHABET[(inBuff &gt;&gt;&gt; 18)];
+            destination[destOffset + 1] = ALPHABET[(inBuff &gt;&gt;&gt; 12) &amp; 0x3f];
+            destination[destOffset + 2] = ALPHABET[(inBuff &gt;&gt;&gt; 6) &amp; 0x3f];
+            destination[destOffset + 3] = ALPHABET[(inBuff) &amp; 0x3f];
+            return destination;
 
-	/**
-	 * Serializes an object and returns the Base64-encoded
-	 * version of that serialized object. If the object
-	 * cannot be serialized or there is another error,
-	 * the method will return &lt;tt&gt;null&lt;/tt&gt;.
-	 * &lt;p&gt;
-	 * Valid options:&lt;pre&gt;
-	 *   GZIP: gzip-compresses object before encoding it.
-	 *   DONT_BREAK_LINES: don't break lines at 76 characters
-	 *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
-	 * &lt;/pre&gt;
-	 * &lt;p&gt;
-	 * Example: &lt;code&gt;encodeObject( myObj, Base64.GZIP )&lt;/code&gt; or
-	 * &lt;p&gt;
-	 * Example: &lt;code&gt;encodeObject( myObj, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
-	 *
-	 * @param serializableObject The object to encode
-	 * @param options Specified options
-	 * @return The Base64-encoded object
-	 * @see Base64#GZIP
-	 * @see Base64#DONT_BREAK_LINES
-	 * @since 2.0
-	 */
-	public static String encodeObject( java.io.Serializable serializableObject,
-			int options )
-	{
-		// Streams
-		java.io.ByteArrayOutputStream baos = null;
-		java.io.OutputStream b64os = null;
-		java.io.ObjectOutputStream oos = null;
-		java.util.zip.GZIPOutputStream gzos = null;
+        case 2:
+            destination[destOffset] = ALPHABET[(inBuff &gt;&gt;&gt; 18)];
+            destination[destOffset + 1] = ALPHABET[(inBuff &gt;&gt;&gt; 12) &amp; 0x3f];
+            destination[destOffset + 2] = ALPHABET[(inBuff &gt;&gt;&gt; 6) &amp; 0x3f];
+            destination[destOffset + 3] = EQUALS_SIGN;
+            return destination;
 
-		// Isolate options
-		int gzip = ( options &amp; GZIP );
-		int dontBreakLines = ( options &amp; DONT_BREAK_LINES );
+        case 1:
+            destination[destOffset] = ALPHABET[(inBuff &gt;&gt;&gt; 18)];
+            destination[destOffset + 1] = ALPHABET[(inBuff &gt;&gt;&gt; 12) &amp; 0x3f];
+            destination[destOffset + 2] = EQUALS_SIGN;
+            destination[destOffset + 3] = EQUALS_SIGN;
+            return destination;
 
-		try {
-			// ObjectOutputStream -&gt; (GZIP) -&gt; Base64 -&gt; ByteArrayOutputStream
-			baos = new java.io.ByteArrayOutputStream();
-			b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
+        default:
+            return destination;
+        } // end switch
+    } // end encode3to4
 
-			// GZip?
-			if ( gzip == GZIP ) {
-				gzos = new java.util.zip.GZIPOutputStream( b64os );
-				oos = new java.io.ObjectOutputStream( gzos );
-			} // end if: gzip
-			else
-				oos = new java.io.ObjectOutputStream( b64os );
+    /**
+     * Serializes an object and returns the Base64-encoded version of that
+     * serialized object. If the object cannot be serialized or there is another
+     * error, the method will return &lt;tt&gt;null&lt;/tt&gt;. The object is not
+     * GZip-compressed before being encoded.
+     * 
+     * @param serializableObject
+     *            The object to encode
+     * @return The Base64-encoded object
+     * @since 1.4
+     */
+    public static String encodeObject( java.io.Serializable serializableObject )
+    {
+        return encodeObject( serializableObject, NO_OPTIONS );
+    } // end encodeObject
 
-			oos.writeObject( serializableObject );
-		} // end try
-		catch ( java.io.IOException e ) {
-			Exceptions.logStackTrace( e );
-			return null;
-		} // end catch
-		finally {
-			try {
-				oos.close();
-			} catch ( Exception e ) {
-			}
-			try {
-				gzos.close();
-			} catch ( Exception e ) {
-			}
-			try {
-				b64os.close();
-			} catch ( Exception e ) {
-			}
-			try {
-				baos.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+    /**
+     * Serializes an object and returns the Base64-encoded version of that
+     * serialized object. If the object cannot be serialized or there is another
+     * error, the method will return &lt;tt&gt;null&lt;/tt&gt;.
+     * &lt;p&gt;
+     * Valid options:
+     * 
+     * &lt;pre&gt;
+     *      GZIP: gzip-compresses object before encoding it.
+     *      DONT_BREAK_LINES: don't break lines at 76 characters
+     *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * &lt;/pre&gt;
+     * 
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeObject( myObj, Base64.GZIP )&lt;/code&gt; or
+     * &lt;p&gt;
+     * Example:
+     * &lt;code&gt;encodeObject( myObj, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
+     * 
+     * @param serializableObject
+     *            The object to encode
+     * @param options
+     *            Specified options
+     * @return The Base64-encoded object
+     * @see Base64#GZIP
+     * @see Base64#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeObject( java.io.Serializable serializableObject,
+            int options )
+    {
+        // Streams
+        java.io.ByteArrayOutputStream baos = null;
+        java.io.OutputStream b64os = null;
+        java.io.ObjectOutputStream oos = null;
+        java.util.zip.GZIPOutputStream gzos = null;
 
-		// Return value according to relevant encoding.
-		try {
-			return new String( baos.toByteArray(), PREFERRED_ENCODING );
-		} // end try
-		catch ( java.io.UnsupportedEncodingException uue ) {
-			return new String( baos.toByteArray() );
-		} // end catch
+        // Isolate options
+        int gzip = (options &amp; GZIP);
+        int dontBreakLines = (options &amp; DONT_BREAK_LINES);
 
-	} // end encode
+        try {
+            // ObjectOutputStream -&gt; (GZIP) -&gt; Base64 -&gt; ByteArrayOutputStream
+            baos = new java.io.ByteArrayOutputStream();
+            b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
 
-	/**
-	 * Encodes a byte array into Base64 notation.
-	 * Does not GZip-compress data.
-	 *
-	 * @param source The data to convert
-	 * @since 1.4
-	 */
-	public static String encodeBytes( byte[] source )
-	{
-		return encodeBytes( source, 0, source.length, NO_OPTIONS );
-	} // end encodeBytes
+            // GZip?
+            if ( gzip == GZIP ) {
+                gzos = new java.util.zip.GZIPOutputStream( b64os );
+                oos = new java.io.ObjectOutputStream( gzos );
+            } // end if: gzip
+            else
+                oos = new java.io.ObjectOutputStream( b64os );
 
-	/**
-	 * Encodes a byte array into Base64 notation.
-	 * &lt;p&gt;
-	 * Valid options:&lt;pre&gt;
-	 *   GZIP: gzip-compresses object before encoding it.
-	 *   DONT_BREAK_LINES: don't break lines at 76 characters
-	 *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
-	 * &lt;/pre&gt;
-	 * &lt;p&gt;
-	 * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
-	 * &lt;p&gt;
-	 * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
-	 *
-	 *
-	 * @param source The data to convert
-	 * @param options Specified options
-	 * @see Base64#GZIP
-	 * @see Base64#DONT_BREAK_LINES
-	 * @since 2.0
-	 */
-	public static String encodeBytes( byte[] source, int options )
-	{
-		return encodeBytes( source, 0, source.length, options );
-	} // end encodeBytes
+            oos.writeObject( serializableObject );
+        } // end try
+        catch ( java.io.IOException e ) {
+            Exceptions.logStackTrace( e );
+            return null;
+        } // end catch
+        finally {
+            try {
+                oos.close();
+            } catch ( Exception e ) {
+            }
+            try {
+                gzos.close();
+            } catch ( Exception e ) {
+            }
+            try {
+                b64os.close();
+            } catch ( Exception e ) {
+            }
+            try {
+                baos.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-	/**
-	 * Encodes a byte array into Base64 notation.
-	 * Does not GZip-compress data.
-	 *
-	 * @param source The data to convert
-	 * @param off Offset in array where conversion should begin
-	 * @param len Length of data to convert
-	 * @since 1.4
-	 */
-	public static String encodeBytes( byte[] source, int off, int len )
-	{
-		return encodeBytes( source, off, len, NO_OPTIONS );
-	} // end encodeBytes
+        // Return value according to relevant encoding.
+        try {
+            return new String( baos.toByteArray(), PREFERRED_ENCODING );
+        } // end try
+        catch ( java.io.UnsupportedEncodingException uue ) {
+            return new String( baos.toByteArray() );
+        } // end catch
 
-	/**
-	 * Encodes a byte array into Base64 notation.
-	 * &lt;p&gt;
-	 * Valid options:&lt;pre&gt;
-	 *   GZIP: gzip-compresses object before encoding it.
-	 *   DONT_BREAK_LINES: don't break lines at 76 characters
-	 *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
-	 * &lt;/pre&gt;
-	 * &lt;p&gt;
-	 * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
-	 * &lt;p&gt;
-	 * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
-	 *
-	 *
-	 * @param source The data to convert
-	 * @param off Offset in array where conversion should begin
-	 * @param len Length of data to convert
-	 * @param options Specified options
-	 * @see Base64#GZIP
-	 * @see Base64#DONT_BREAK_LINES
-	 * @since 2.0
-	 */
-	public static String encodeBytes( byte[] source, int off, int len, int options )
-	{
-		// Isolate options
-		int dontBreakLines = ( options &amp; DONT_BREAK_LINES );
-		int gzip = ( options &amp; GZIP );
+    } // end encode
 
-		// Compress?
-		if ( gzip == GZIP ) {
-			java.io.ByteArrayOutputStream baos = null;
-			java.util.zip.GZIPOutputStream gzos = null;
-			Base64.OutputStream b64os = null;
+    /**
+     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
+     * 
+     * @param source
+     *            The data to convert
+     * @since 1.4
+     */
+    public static String encodeBytes( byte[] source )
+    {
+        return encodeBytes( source, 0, source.length, NO_OPTIONS );
+    } // end encodeBytes
 
-			try {
-				// GZip -&gt; Base64 -&gt; ByteArray
-				baos = new java.io.ByteArrayOutputStream();
-				b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
-				gzos = new java.util.zip.GZIPOutputStream( b64os );
+    /**
+     * Encodes a byte array into Base64 notation.
+     * &lt;p&gt;
+     * Valid options:
+     * 
+     * &lt;pre&gt;
+     *      GZIP: gzip-compresses object before encoding it.
+     *      DONT_BREAK_LINES: don't break lines at 76 characters
+     *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * &lt;/pre&gt;
+     * 
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
+     * &lt;p&gt;
+     * Example:
+     * &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
+     * 
+     * 
+     * @param source
+     *            The data to convert
+     * @param options
+     *            Specified options
+     * @see Base64#GZIP
+     * @see Base64#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeBytes( byte[] source, int options )
+    {
+        return encodeBytes( source, 0, source.length, options );
+    } // end encodeBytes
 
-				gzos.write( source, off, len );
-				gzos.close();
-			} // end try
-			catch ( java.io.IOException e ) {
-				Exceptions.logStackTrace( e );
-				return null;
-			} // end catch
-			finally {
-				try {
-					gzos.close();
-				} catch ( Exception e ) {
-				}
-				try {
-					b64os.close();
-				} catch ( Exception e ) {
-				}
-				try {
-					baos.close();
-				} catch ( Exception e ) {
-				}
-			} // end finally
+    /**
+     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
+     * 
+     * @param source
+     *            The data to convert
+     * @param off
+     *            Offset in array where conversion should begin
+     * @param len
+     *            Length of data to convert
+     * @since 1.4
+     */
+    public static String encodeBytes( byte[] source, int off, int len )
+    {
+        return encodeBytes( source, off, len, NO_OPTIONS );
+    } // end encodeBytes
 
-			// Return value according to relevant encoding.
-			try {
-				return new String( baos.toByteArray(), PREFERRED_ENCODING );
-			} // end try
-			catch ( java.io.UnsupportedEncodingException uue ) {
-				return new String( baos.toByteArray() );
-			} // end catch
-		} // end if: compress
+    /**
+     * Encodes a byte array into Base64 notation.
+     * &lt;p&gt;
+     * Valid options:
+     * 
+     * &lt;pre&gt;
+     *      GZIP: gzip-compresses object before encoding it.
+     *      DONT_BREAK_LINES: don't break lines at 76 characters
+     *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * &lt;/pre&gt;
+     * 
+     * &lt;p&gt;
+     * Example: &lt;code&gt;encodeBytes( myData, Base64.GZIP )&lt;/code&gt; or
+     * &lt;p&gt;
+     * Example:
+     * &lt;code&gt;encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )&lt;/code&gt;
+     * 
+     * 
+     * @param source
+     *            The data to convert
+     * @param off
+     *            Offset in array where conversion should begin
+     * @param len
+     *            Length of data to convert
+     * @param options
+     *            Specified options
+     * @see Base64#GZIP
+     * @see Base64#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeBytes( byte[] source, int off, int len, int options )
+    {
+        // Isolate options
+        int dontBreakLines = (options &amp; DONT_BREAK_LINES);
+        int gzip = (options &amp; GZIP);
 
-		// Else, don't compress. Better not to use streams at all then.
-		else {
-			// Convert option to boolean in way that code likes it.
-			boolean breakLines = dontBreakLines == 0;
+        // Compress?
+        if ( gzip == GZIP ) {
+            java.io.ByteArrayOutputStream baos = null;
+            java.util.zip.GZIPOutputStream gzos = null;
+            Base64.OutputStream b64os = null;
 
-			int len43 = len * 4 / 3;
-			byte[] outBuff = new byte[( len43 ) // Main 4:3
-					+ ( ( len % 3 ) &gt; 0 ? 4 : 0 ) // Account for padding
-					+ ( breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0 )]; // New lines      
-			int d = 0;
-			int e = 0;
-			int len2 = len - 2;
-			int lineLength = 0;
-			for ( ; d &lt; len2; d += 3, e += 4 ) {
-				encode3to4( source, d + off, 3, outBuff, e );
+            try {
+                // GZip -&gt; Base64 -&gt; ByteArray
+                baos = new java.io.ByteArrayOutputStream();
+                b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
+                gzos = new java.util.zip.GZIPOutputStream( b64os );
 
-				lineLength += 4;
-				if ( breakLines &amp;&amp; lineLength == MAX_LINE_LENGTH ) {
-					outBuff[e + 4] = NEW_LINE;
-					e++;
-					lineLength = 0;
-				} // end if: end of line
-			} // en dfor: each piece of array
+                gzos.write( source, off, len );
+                gzos.close();
+            } // end try
+            catch ( java.io.IOException e ) {
+                Exceptions.logStackTrace( e );
+                return null;
+            } // end catch
+            finally {
+                try {
+                    gzos.close();
+                } catch ( Exception e ) {
+                }
+                try {
+                    b64os.close();
+                } catch ( Exception e ) {
+                }
+                try {
+                    baos.close();
+                } catch ( Exception e ) {
+                }
+            } // end finally
 
-			if ( d &lt; len ) {
-				encode3to4( source, d + off, len - d, outBuff, e );
-				e += 4;
-			} // end if: some padding needed
+            // Return value according to relevant encoding.
+            try {
+                return new String( baos.toByteArray(), PREFERRED_ENCODING );
+            } // end try
+            catch ( java.io.UnsupportedEncodingException uue ) {
+                return new String( baos.toByteArray() );
+            } // end catch
+        } // end if: compress
 
-			// Return value according to relevant encoding.
-			try {
-				return new String( outBuff, 0, e, PREFERRED_ENCODING );
-			} // end try
-			catch ( java.io.UnsupportedEncodingException uue ) {
-				return new String( outBuff, 0, e );
-			} // end catch
+        // Else, don't compress. Better not to use streams at all then.
 
-		} // end else: don't compress
+        // Convert option to boolean in way that code likes it.
+        boolean breakLines = dontBreakLines == 0;
 
-	} // end encodeBytes
+        int len43 = len * 4 / 3;
+        byte[] outBuff = new byte[(len43) // Main 4:3
+                + ((len % 3) &gt; 0 ? 4 : 0) // Account for padding
+                + (breakLines ? (len43 / MAX_LINE_LENGTH) : 0)]; // New lines
+        int d = 0;
+        int e = 0;
+        int len2 = len - 2;
+        int lineLength = 0;
+        for ( ; d &lt; len2; d += 3, e += 4 ) {
+            encode3to4( source, d + off, 3, outBuff, e );
 
-	/* ********  D E C O D I N G   M E T H O D S  ******** */
+            lineLength += 4;
+            if ( breakLines &amp;&amp; lineLength == MAX_LINE_LENGTH ) {
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+                lineLength = 0;
+            } // end if: end of line
+        } // en dfor: each piece of array
 
-	/**
-	 * Decodes four bytes from array &lt;var&gt;source&lt;/var&gt;
-	 * and writes the resulting bytes (up to three of them)
-	 * to &lt;var&gt;destination&lt;/var&gt;.
-	 * The source and destination arrays can be manipulated
-	 * anywhere along their length by specifying 
-	 * &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;.
-	 * This method does not check to make sure your arrays
-	 * are large enough to accomodate &lt;var&gt;srcOffset&lt;/var&gt; + 4 for
-	 * the &lt;var&gt;source&lt;/var&gt; array or &lt;var&gt;destOffset&lt;/var&gt; + 3 for
-	 * the &lt;var&gt;destination&lt;/var&gt; array.
-	 * This method returns the actual number of bytes that 
-	 * were converted from the Base64 encoding.
-	 * 
-	 *
-	 * @param source the array to convert
-	 * @param srcOffset the index where conversion begins
-	 * @param destination the array to hold the conversion
-	 * @param destOffset the index where output will be put
-	 * @return the number of decoded bytes converted
-	 * @since 1.3
-	 */
-	private static int decode4to3( byte[] source, int srcOffset, byte[] destination,
-			int destOffset )
-	{
-		// Example: Dk==
-		if ( source[srcOffset + 2] == EQUALS_SIGN ) {
-			// Two ways to do the same thing. Don't know which way I like best.
-			//int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
-			//              | ( ( DECODABET[ source[ srcOffset + 1] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 );
-			int outBuff = ( ( DECODABET[source[srcOffset]] &amp; 0xFF ) &lt;&lt; 18 )
-					| ( ( DECODABET[source[srcOffset + 1]] &amp; 0xFF ) &lt;&lt; 12 );
+        if ( d &lt; len ) {
+            encode3to4( source, d + off, len - d, outBuff, e );
+            e += 4;
+        } // end if: some padding needed
 
-			destination[destOffset] = (byte) ( outBuff &gt;&gt;&gt; 16 );
-			return 1;
-		}
+        // Return value according to relevant encoding.
+        try {
+            return new String( outBuff, 0, e, PREFERRED_ENCODING );
+        } // end try
+        catch ( java.io.UnsupportedEncodingException uue ) {
+            return new String( outBuff, 0, e );
+        } // end catch
 
-		// Example: DkL=
-		else
-			if ( source[srcOffset + 3] == EQUALS_SIGN ) {
-				// Two ways to do the same thing. Don't know which way I like best.
-				//int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
-				//              | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
-				//              | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 );
-				int outBuff = ( ( DECODABET[source[srcOffset]] &amp; 0xFF ) &lt;&lt; 18 )
-						| ( ( DECODABET[source[srcOffset + 1]] &amp; 0xFF ) &lt;&lt; 12 )
-						| ( ( DECODABET[source[srcOffset + 2]] &amp; 0xFF ) &lt;&lt; 6 );
+    } // end encodeBytes
 
-				destination[destOffset] = (byte) ( outBuff &gt;&gt;&gt; 16 );
-				destination[destOffset + 1] = (byte) ( outBuff &gt;&gt;&gt; 8 );
-				return 2;
-			}
+    /* ******** D E C O D I N G M E T H O D S ******** */
 
-			// Example: DkLE
-			else {
-				try {
-					// Two ways to do the same thing. Don't know which way I like best.
-					//int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] &lt;&lt; 24 ) &gt;&gt;&gt;  6 )
-					//              | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
-					//              | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 )
-					//              | ( ( DECODABET[ source[ srcOffset + 3 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 24 );
-					int outBuff = ( ( DECODABET[source[srcOffset]] &amp; 0xFF ) &lt;&lt; 18 )
-							| ( ( DECODABET[source[srcOffset + 1]] &amp; 0xFF ) &lt;&lt; 12 )
-							| ( ( DECODABET[source[srcOffset + 2]] &amp; 0xFF ) &lt;&lt; 6 )
-							| ( ( DECODABET[source[srcOffset + 3]] &amp; 0xFF ) );
+    /**
+     * Decodes four bytes from array &lt;var&gt;source&lt;/var&gt; and writes the resulting
+     * bytes (up to three of them) to &lt;var&gt;destination&lt;/var&gt;. The source and
+     * destination arrays can be manipulated anywhere along their length by
+     * specifying &lt;var&gt;srcOffset&lt;/var&gt; and &lt;var&gt;destOffset&lt;/var&gt;. This method
+     * does not check to make sure your arrays are large enough to accomodate
+     * &lt;var&gt;srcOffset&lt;/var&gt; + 4 for the &lt;var&gt;source&lt;/var&gt; array or
+     * &lt;var&gt;destOffset&lt;/var&gt; + 3 for the &lt;var&gt;destination&lt;/var&gt; array. This
+     * method returns the actual number of bytes that were converted from the
+     * Base64 encoding.
+     * 
+     * 
+     * @param source
+     *            the array to convert
+     * @param srcOffset
+     *            the index where conversion begins
+     * @param destination
+     *            the array to hold the conversion
+     * @param destOffset
+     *            the index where output will be put
+     * @return the number of decoded bytes converted
+     * @since 1.3
+     */
+    private static int decode4to3( byte[] source, int srcOffset, byte[] destination,
+            int destOffset )
+    {
+        // Example: Dk==
+        if ( source[srcOffset + 2] == EQUALS_SIGN ) {
+            // Two ways to do the same thing. Don't know which way I like best.
+            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 6
+            // )
+            // | ( ( DECODABET[ source[ srcOffset + 1] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 );
+            int outBuff = ((DECODABET[source[srcOffset]] &amp; 0xFF) &lt;&lt; 18)
+                    | ((DECODABET[source[srcOffset + 1]] &amp; 0xFF) &lt;&lt; 12);
 
-					destination[destOffset] = (byte) ( outBuff &gt;&gt; 16 );
-					destination[destOffset + 1] = (byte) ( outBuff &gt;&gt; 8 );
-					destination[destOffset + 2] = (byte) ( outBuff );
+            destination[destOffset] = (byte) (outBuff &gt;&gt;&gt; 16);
+            return 1;
+        }
 
-					return 3;
-				} catch ( Exception e ) {
-					System.out.println( &quot;&quot; + source[srcOffset] + &quot;: &quot;
-							+ ( DECODABET[source[srcOffset]] ) );
-					System.out.println( &quot;&quot; + source[srcOffset + 1] + &quot;: &quot;
-							+ ( DECODABET[source[srcOffset + 1]] ) );
-					System.out.println( &quot;&quot; + source[srcOffset + 2] + &quot;: &quot;
-							+ ( DECODABET[source[srcOffset + 2]] ) );
-					System.out.println( &quot;&quot; + source[srcOffset + 3] + &quot;: &quot;
-							+ ( DECODABET[source[srcOffset + 3]] ) );
-					return -1;
-				} //e nd catch
-			}
-	} // end decodeToBytes
+        // Example: DkL=
+        else if ( source[srcOffset + 3] == EQUALS_SIGN ) {
+            // Two ways to do the same thing. Don't know which way I like best.
+            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 6
+            // )
+            // | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
+            // | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 );
+            int outBuff = ((DECODABET[source[srcOffset]] &amp; 0xFF) &lt;&lt; 18)
+                    | ((DECODABET[source[srcOffset + 1]] &amp; 0xFF) &lt;&lt; 12)
+                    | ((DECODABET[source[srcOffset + 2]] &amp; 0xFF) &lt;&lt; 6);
 
-	/**
-	 * Very low-level access to decoding ASCII characters in
-	 * the form of a byte array. Does not support automatically
-	 * gunzipping or any other &quot;fancy&quot; features.
-	 *
-	 * @param source The Base64 encoded data
-	 * @param off    The offset of where to begin decoding
-	 * @param len    The length of characters to decode
-	 * @return decoded data
-	 * @since 1.3
-	 */
-	public static byte[] decode( byte[] source, int off, int len )
-	{
-		int len34 = len * 3 / 4;
-		byte[] outBuff = new byte[len34]; // Upper limit on size of output
-		int outBuffPosn = 0;
+            destination[destOffset] = (byte) (outBuff &gt;&gt;&gt; 16);
+            destination[destOffset + 1] = (byte) (outBuff &gt;&gt;&gt; 8);
+            return 2;
+        }
 
-		byte[] b4 = new byte[4];
-		int b4Posn = 0;
-		int i = 0;
-		byte sbiCrop = 0;
-		byte sbiDecode = 0;
-		for ( i = off; i &lt; off + len; i++ ) {
-			sbiCrop = (byte) ( source[i] &amp; 0x7f ); // Only the low seven bits
-			sbiDecode = DECODABET[sbiCrop];
+        // Example: DkLE
+        else {
+            try {
+                // Two ways to do the same thing. Don't know which way I like
+                // best.
+                // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] &lt;&lt; 24 )
+                // &gt;&gt;&gt; 6 )
+                // | ( ( DECODABET[ source[ srcOffset + 1 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 12 )
+                // | ( ( DECODABET[ source[ srcOffset + 2 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 18 )
+                // | ( ( DECODABET[ source[ srcOffset + 3 ] ] &lt;&lt; 24 ) &gt;&gt;&gt; 24 );
+                int outBuff = ((DECODABET[source[srcOffset]] &amp; 0xFF) &lt;&lt; 18)
+                        | ((DECODABET[source[srcOffset + 1]] &amp; 0xFF) &lt;&lt; 12)
+                        | ((DECODABET[source[srcOffset + 2]] &amp; 0xFF) &lt;&lt; 6)
+                        | ((DECODABET[source[srcOffset + 3]] &amp; 0xFF));
 
-			if ( sbiDecode &gt;= WHITE_SPACE_ENC ) // White space, Equals sign or better
-			{
-				if ( sbiDecode &gt;= EQUALS_SIGN_ENC ) {
-					b4[b4Posn++] = sbiCrop;
-					if ( b4Posn &gt; 3 ) {
-						outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn );
-						b4Posn = 0;
+                destination[destOffset] = (byte) (outBuff &gt;&gt; 16);
+                destination[destOffset + 1] = (byte) (outBuff &gt;&gt; 8);
+                destination[destOffset + 2] = (byte) (outBuff);
 
-						// If that was the equals sign, break out of 'for' loop
-						if ( sbiCrop == EQUALS_SIGN )
-							break;
-					} // end if: quartet built
+                return 3;
+            } catch ( Exception e ) {
+                System.out.println( &quot;&quot; + source[srcOffset] + &quot;: &quot;
+                        + (DECODABET[source[srcOffset]]) );
+                System.out.println( &quot;&quot; + source[srcOffset + 1] + &quot;: &quot;
+                        + (DECODABET[source[srcOffset + 1]]) );
+                System.out.println( &quot;&quot; + source[srcOffset + 2] + &quot;: &quot;
+                        + (DECODABET[source[srcOffset + 2]]) );
+                System.out.println( &quot;&quot; + source[srcOffset + 3] + &quot;: &quot;
+                        + (DECODABET[source[srcOffset + 3]]) );
+                return -1;
+            } // e nd catch
+        }
+    } // end decodeToBytes
 
-				} // end if: equals sign or better
+    /**
+     * Very low-level access to decoding ASCII characters in the form of a byte
+     * array. Does not support automatically gunzipping or any other &quot;fancy&quot;
+     * features.
+     * 
+     * @param source
+     *            The Base64 encoded data
+     * @param off
+     *            The offset of where to begin decoding
+     * @param len
+     *            The length of characters to decode
+     * @return decoded data
+     * @since 1.3
+     */
+    public static byte[] decode( byte[] source, int off, int len )
+    {
+        int len34 = len * 3 / 4;
+        byte[] outBuff = new byte[len34]; // Upper limit on size of output
+        int outBuffPosn = 0;
 
-			} // end if: white space, equals sign or better
-			else {
-				System.err.println( &quot;Bad Base64 input character at &quot; + i + &quot;: &quot;
-						+ source[i] + &quot;(decimal)&quot; );
-				return null;
-			} // end else: 
-		} // each input character
+        byte[] b4 = new byte[4];
+        int b4Posn = 0;
+        int i = 0;
+        byte sbiCrop = 0;
+        byte sbiDecode = 0;
+        for ( i = off; i &lt; off + len; i++ ) {
+            sbiCrop = (byte) (source[i] &amp; 0x7f); // Only the low seven bits
+            sbiDecode = DECODABET[sbiCrop];
 
-		byte[] out = new byte[outBuffPosn];
-		System.arraycopy( outBuff, 0, out, 0, outBuffPosn );
-		return out;
-	} // end decode
+            if ( sbiDecode &gt;= WHITE_SPACE_ENC ) // White space, Equals sign or
+            // better
+            {
+                if ( sbiDecode &gt;= EQUALS_SIGN_ENC ) {
+                    b4[b4Posn++] = sbiCrop;
+                    if ( b4Posn &gt; 3 ) {
+                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn );
+                        b4Posn = 0;
 
-	/**
-	 * Decodes data from Base64 notation, automatically
-	 * detecting gzip-compressed data and decompressing it.
-	 *
-	 * @param s the string to decode
-	 * @return the decoded data
-	 * @since 1.4
-	 */
-	public static byte[] decode( String s )
-	{
-		byte[] bytes;
-		try {
-			bytes = s.getBytes( PREFERRED_ENCODING );
-		} // end try
-		catch ( java.io.UnsupportedEncodingException uee ) {
-			bytes = s.getBytes();
-		} // end catch
-		//&lt;/change&gt;
+                        // If that was the equals sign, break out of 'for' loop
+                        if ( sbiCrop == EQUALS_SIGN )
+                            break;
+                    } // end if: quartet built
 
-		// Decode
-		bytes = decode( bytes, 0, bytes.length );
+                } // end if: equals sign or better
 
-		// Check to see if it's gzip-compressed
-		// GZIP Magic Two-Byte Number: 0x8b1f (35615)
-		if ( bytes != null &amp;&amp; bytes.length &gt;= 4 ) {
+            } // end if: white space, equals sign or better
+            else {
+                System.err.println( &quot;Bad Base64 input character at &quot; + i + &quot;: &quot;
+                        + source[i] + &quot;(decimal)&quot; );
+                return null;
+            } // end else:
+        } // each input character
 
-			int head = ( (int) bytes[0] &amp; 0xff ) | ( ( bytes[1] &lt;&lt; 8 ) &amp; 0xff00 );
-			if ( java.util.zip.GZIPInputStream.GZIP_MAGIC == head ) {
-				java.io.ByteArrayInputStream bais = null;
-				java.util.zip.GZIPInputStream gzis = null;
-				java.io.ByteArrayOutputStream baos = null;
-				byte[] buffer = new byte[2048];
-				int length = 0;
+        byte[] out = new byte[outBuffPosn];
+        System.arraycopy( outBuff, 0, out, 0, outBuffPosn );
+        return out;
+    } // end decode
 
-				try {
-					baos = new java.io.ByteArrayOutputStream();
-					bais = new java.io.ByteArrayInputStream( bytes );
-					gzis = new java.util.zip.GZIPInputStream( bais );
+    /**
+     * Decodes data from Base64 notation, automatically detecting
+     * gzip-compressed data and decompressing it.
+     * 
+     * @param s
+     *            the string to decode
+     * @return the decoded data
+     * @since 1.4
+     */
+    public static byte[] decode( String s )
+    {
+        byte[] bytes;
+        try {
+            bytes = s.getBytes( PREFERRED_ENCODING );
+        } // end try
+        catch ( java.io.UnsupportedEncodingException uee ) {
+            bytes = s.getBytes();
+        } // end catch
+        // &lt;/change&gt;
 
-					while ( ( length = gzis.read( buffer ) ) &gt;= 0 ) {
-						baos.write( buffer, 0, length );
-					} // end while: reading input
+        // Decode
+        bytes = decode( bytes, 0, bytes.length );
 
-					// No error? Get new bytes.
-					bytes = baos.toByteArray();
+        // Check to see if it's gzip-compressed
+        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
+        if ( bytes != null &amp;&amp; bytes.length &gt;= 4 ) {
 
-				} // end try
-				catch ( java.io.IOException e ) {
-					// Just return originally-decoded bytes
-				} // end catch
-				finally {
-					try {
-						baos.close();
-					} catch ( Exception e ) {
-					}
-					try {
-						gzis.close();
-					} catch ( Exception e ) {
-					}
-					try {
-						bais.close();
-					} catch ( Exception e ) {
-					}
-				} // end finally
+            int head = (bytes[0] &amp; 0xff) | ((bytes[1] &lt;&lt; 8) &amp; 0xff00);
+            if ( java.util.zip.GZIPInputStream.GZIP_MAGIC == head ) {
+                java.io.ByteArrayInputStream bais = null;
+                java.util.zip.GZIPInputStream gzis = null;
+                java.io.ByteArrayOutputStream baos = null;
+                byte[] buffer = new byte[2048];
+                int length = 0;
 
-			} // end if: gzipped
-		} // end if: bytes.length &gt;= 2
+                try {
+                    baos = new java.io.ByteArrayOutputStream();
+                    bais = new java.io.ByteArrayInputStream( bytes );
+                    gzis = new java.util.zip.GZIPInputStream( bais );
 
-		return bytes;
-	} // end decode
+                    while ( (length = gzis.read( buffer )) &gt;= 0 ) {
+                        baos.write( buffer, 0, length );
+                    } // end while: reading input
 
-	/**
-	 * Attempts to decode Base64 data and deserialize a Java
-	 * Object within. Returns &lt;tt&gt;null&lt;/tt&gt; if there was an error.
-	 *
-	 * @param encodedObject The Base64 data to decode
-	 * @return The decoded and deserialized object
-	 * @since 1.5
-	 */
-	public static Object decodeToObject( String encodedObject )
-	{
-		// Decode and gunzip if necessary
-		byte[] objBytes = decode( encodedObject );
+                    // No error? Get new bytes.
+                    bytes = baos.toByteArray();
 
-		java.io.ByteArrayInputStream bais = null;
-		java.io.ObjectInputStream ois = null;
-		Object obj = null;
+                } // end try
+                catch ( java.io.IOException e ) {
+                    // Just return originally-decoded bytes
+                } // end catch
+                finally {
+                    try {
+                        baos.close();
+                    } catch ( Exception e ) {
+                    }
+                    try {
+                        gzis.close();
+                    } catch ( Exception e ) {
+                    }
+                    try {
+                        bais.close();
+                    } catch ( Exception e ) {
+                    }
+                } // end finally
 
-		try {
-			bais = new java.io.ByteArrayInputStream( objBytes );
-			ois = new java.io.ObjectInputStream( bais );
+            } // end if: gzipped
+        } // end if: bytes.length &gt;= 2
 
-			obj = ois.readObject();
-		} // end try
-		catch ( java.io.IOException e ) {
-			Exceptions.logStackTrace( e );
-			obj = null;
-		} // end catch
-		catch ( java.lang.ClassNotFoundException e ) {
-			Exceptions.logStackTrace( e );
-			obj = null;
-		} // end catch
-		finally {
-			try {
-				bais.close();
-			} catch ( Exception e ) {
-			}
-			try {
-				ois.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+        return bytes;
+    } // end decode
 
-		return obj;
-	} // end decodeObject
+    /**
+     * Attempts to decode Base64 data and deserialize a Java Object within.
+     * Returns &lt;tt&gt;null&lt;/tt&gt; if there was an error.
+     * 
+     * @param encodedObject
+     *            The Base64 data to decode
+     * @return The decoded and deserialized object
+     * @since 1.5
+     */
+    public static Object decodeToObject( String encodedObject )
+    {
+        // Decode and gunzip if necessary
+        byte[] objBytes = decode( encodedObject );
 
-	/**
-	 * Convenience method for encoding data to a file.
-	 *
-	 * @param dataToEncode byte array of data to encode in base64 form
-	 * @param filename Filename for saving encoded data
-	 * @return &lt;tt&gt;true&lt;/tt&gt; if successful, &lt;tt&gt;false&lt;/tt&gt; otherwise
-	 *
-	 * @since 2.1
-	 */
-	public static boolean encodeToFile( byte[] dataToEncode, String filename )
-	{
-		boolean success = false;
-		Base64.OutputStream bos = null;
-		try {
-			bos = new Base64.OutputStream( new java.io.FileOutputStream( filename ),
-					Base64.ENCODE );
-			bos.write( dataToEncode );
-			success = true;
-		} // end try
-		catch ( java.io.IOException e ) {
+        java.io.ByteArrayInputStream bais = null;
+        java.io.ObjectInputStream ois = null;
+        Object obj = null;
 
-			success = false;
-		} // end catch: IOException
-		finally {
-			try {
-				bos.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+        try {
+            bais = new java.io.ByteArrayInputStream( objBytes );
+            ois = new java.io.ObjectInputStream( bais );
 
-		return success;
-	} // end encodeToFile
+            obj = ois.readObject();
+        } // end try
+        catch ( java.io.IOException e ) {
+            Exceptions.logStackTrace( e );
+            obj = null;
+        } // end catch
+        catch ( java.lang.ClassNotFoundException e ) {
+            Exceptions.logStackTrace( e );
+            obj = null;
+        } // end catch
+        finally {
+            try {
+                bais.close();
+            } catch ( Exception e ) {
+            }
+            try {
+                ois.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-	/**
-	 * Convenience method for decoding data to a file.
-	 *
-	 * @param dataToDecode Base64-encoded data as a string
-	 * @param filename Filename for saving decoded data
-	 * @return &lt;tt&gt;true&lt;/tt&gt; if successful, &lt;tt&gt;false&lt;/tt&gt; otherwise
-	 *
-	 * @since 2.1
-	 */
-	public static boolean decodeToFile( String dataToDecode, String filename )
-	{
-		boolean success = false;
-		Base64.OutputStream bos = null;
-		try {
-			bos = new Base64.OutputStream( new java.io.FileOutputStream( filename ),
-					Base64.DECODE );
-			bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );
-			success = true;
-		} // end try
-		catch ( java.io.IOException e ) {
-			success = false;
-		} // end catch: IOException
-		finally {
-			try {
-				bos.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+        return obj;
+    } // end decodeObject
 
-		return success;
-	} // end decodeToFile
+    /**
+     * Convenience method for encoding data to a file.
+     * 
+     * @param dataToEncode
+     *            byte array of data to encode in base64 form
+     * @param filename
+     *            Filename for saving encoded data
+     * @return &lt;tt&gt;true&lt;/tt&gt; if successful, &lt;tt&gt;false&lt;/tt&gt; otherwise
+     * 
+     * @since 2.1
+     */
+    public static boolean encodeToFile( byte[] dataToEncode, String filename )
+    {
+        boolean success = false;
+        Base64.OutputStream bos = null;
+        try {
+            bos = new Base64.OutputStream( new java.io.FileOutputStream( filename ),
+                    Base64.ENCODE );
+            bos.write( dataToEncode );
+            success = true;
+        } // end try
+        catch ( java.io.IOException e ) {
 
-	/**
-	 * Convenience method for reading a base64-encoded
-	 * file and decoding it.
-	 *
-	 * @param filename Filename for reading encoded data
-	 * @return decoded byte array or null if unsuccessful
-	 *
-	 * @since 2.1
-	 */
-	public static byte[] decodeFromFile( String filename )
-	{
-		byte[] decodedData = null;
-		Base64.InputStream bis = null;
-		try {
-			// Set up some useful variables
-			java.io.File file = new java.io.File( filename );
-			byte[] buffer = null;
-			int length = 0;
-			int numBytes = 0;
+            success = false;
+        } // end catch: IOException
+        finally {
+            try {
+                bos.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-			// Check for size of file
-			if ( file.length() &gt; Integer.MAX_VALUE ) {
-				System.err.println( &quot;File is too big for this convenience method (&quot;
-						+ file.length() + &quot; bytes).&quot; );
-				return null;
-			} // end if: file too big for int index
-			buffer = new byte[(int) file.length()];
+        return success;
+    } // end encodeToFile
 
-			// Open a stream
-			bis = new Base64.InputStream( new java.io.BufferedInputStream(
-					new java.io.FileInputStream( file ) ), Base64.DECODE );
+    /**
+     * Convenience method for decoding data to a file.
+     * 
+     * @param dataToDecode
+     *            Base64-encoded data as a string
+     * @param filename
+     *            Filename for saving decoded data
+     * @return &lt;tt&gt;true&lt;/tt&gt; if successful, &lt;tt&gt;false&lt;/tt&gt; otherwise
+     * 
+     * @since 2.1
+     */
+    public static boolean decodeToFile( String dataToDecode, String filename )
+    {
+        boolean success = false;
+        Base64.OutputStream bos = null;
+        try {
+            bos = new Base64.OutputStream( new java.io.FileOutputStream( filename ),
+                    Base64.DECODE );
+            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );
+            success = true;
+        } // end try
+        catch ( java.io.IOException e ) {
+            success = false;
+        } // end catch: IOException
+        finally {
+            try {
+                bos.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-			// Read until done
-			while ( ( numBytes = bis.read( buffer, length, 4096 ) ) &gt;= 0 )
-				length += numBytes;
+        return success;
+    } // end decodeToFile
 
-			// Save in a variable to return
-			decodedData = new byte[length];
-			System.arraycopy( buffer, 0, decodedData, 0, length );
+    /**
+     * Convenience method for reading a base64-encoded file and decoding it.
+     * 
+     * @param filename
+     *            Filename for reading encoded data
+     * @return decoded byte array or null if unsuccessful
+     * 
+     * @since 2.1
+     */
+    public static byte[] decodeFromFile( String filename )
+    {
+        byte[] decodedData = null;
+        Base64.InputStream bis = null;
+        try {
+            // Set up some useful variables
+            java.io.File file = new java.io.File( filename );
+            byte[] buffer = null;
+            int length = 0;
+            int numBytes = 0;
 
-		} // end try
-		catch ( java.io.IOException e ) {
-			System.err.println( &quot;Error decoding from file &quot; + filename );
-		} // end catch: IOException
-		finally {
-			try {
-				bis.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+            // Check for size of file
+            if ( file.length() &gt; Integer.MAX_VALUE ) {
+                System.err.println( &quot;File is too big for this convenience method (&quot;
+                        + file.length() + &quot; bytes).&quot; );
+                return null;
+            } // end if: file too big for int index
+            buffer = new byte[(int) file.length()];
 
-		return decodedData;
-	} // end decodeFromFile
+            // Open a stream
+            bis = new Base64.InputStream( new java.io.BufferedInputStream(
+                    new java.io.FileInputStream( file ) ), Base64.DECODE );
 
-	/**
-	 * Convenience method for reading a binary file
-	 * and base64-encoding it.
-	 *
-	 * @param filename Filename for reading binary data
-	 * @return base64-encoded string or null if unsuccessful
-	 *
-	 * @since 2.1
-	 */
-	public static String encodeFromFile( String filename )
-	{
-		String encodedData = null;
-		Base64.InputStream bis = null;
-		try {
-			// Set up some useful variables
-			java.io.File file = new java.io.File( filename );
-			byte[] buffer = new byte[(int) ( file.length() * 1.4 )];
-			int length = 0;
-			int numBytes = 0;
+            // Read until done
+            while ( (numBytes = bis.read( buffer, length, 4096 )) &gt;= 0 )
+                length += numBytes;
 
-			// Open a stream
-			bis = new Base64.InputStream( new java.io.BufferedInputStream(
-					new java.io.FileInputStream( file ) ), Base64.ENCODE );
+            // Save in a variable to return
+            decodedData = new byte[length];
+            System.arraycopy( buffer, 0, decodedData, 0, length );
 
-			// Read until done
-			while ( ( numBytes = bis.read( buffer, length, 4096 ) ) &gt;= 0 )
-				length += numBytes;
+        } // end try
+        catch ( java.io.IOException e ) {
+            System.err.println( &quot;Error decoding from file &quot; + filename );
+        } // end catch: IOException
+        finally {
+            try {
+                bis.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-			// Save in a variable to return
-			encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );
+        return decodedData;
+    } // end decodeFromFile
 
-		} // end try
-		catch ( java.io.IOException e ) {
-			System.err.println( &quot;Error encoding from file &quot; + filename );
-		} // end catch: IOException
-		finally {
-			try {
-				bis.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+    /**
+     * Convenience method for reading a binary file and base64-encoding it.
+     * 
+     * @param filename
+     *            Filename for reading binary data
+     * @return base64-encoded string or null if unsuccessful
+     * 
+     * @since 2.1
+     */
+    public static String encodeFromFile( String filename )
+    {
+        String encodedData = null;
+        Base64.InputStream bis = null;
+        try {
+            // Set up some useful variables
+            java.io.File file = new java.io.File( filename );
+            byte[] buffer = new byte[(int) (file.length() * 1.4)];
+            int length = 0;
+            int numBytes = 0;
 
-		return encodedData;
-	} // end encodeFromFile
+            // Open a stream
+            bis = new Base64.InputStream( new java.io.BufferedInputStream(
+                    new java.io.FileInputStream( file ) ), Base64.ENCODE );
 
-	/* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */
+            // Read until done
+            while ( (numBytes = bis.read( buffer, length, 4096 )) &gt;= 0 )
+                length += numBytes;
 
-	/**
-	 * A {@link Base64.InputStream} will read data from another
-	 * &lt;tt&gt;java.io.InputStream&lt;/tt&gt;, given in the constructor,
-	 * and encode/decode to/from Base64 notation on the fly.
-	 *
-	 * @see Base64
-	 * @since 1.3
-	 */
-	public static class InputStream extends java.io.FilterInputStream
-	{
+            // Save in a variable to return
+            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );
 
-		private boolean encode; // Encoding or decoding
-		private int position; // Current position in the buffer
-		private byte[] buffer; // Small buffer holding converted data
-		private int bufferLength; // Length of buffer (3 or 4)
-		private int numSigBytes; // Number of meaningful bytes in the buffer
-		private int lineLength;
-		private boolean breakLines; // Break lines at less than 80 characters
+        } // end try
+        catch ( java.io.IOException e ) {
+            System.err.println( &quot;Error encoding from file &quot; + filename );
+        } // end catch: IOException
+        finally {
+            try {
+                bis.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-		/**
-		 * Constructs a {@link Base64.InputStream} in DECODE mode.
-		 *
-		 * @param in the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read data.
-		 * @since 1.3
-		 */
-		public InputStream( java.io.InputStream in )
-		{
-			this( in, DECODE );
-		} // end constructor
+        return encodedData;
+    } // end encodeFromFile
 
-		/**
-		 * Constructs a {@link Base64.InputStream} in
-		 * either ENCODE or DECODE mode.
-		 * &lt;p&gt;
-		 * Valid options:&lt;pre&gt;
-		 *   ENCODE or DECODE: Encode or Decode as data is read.
-		 *   DONT_BREAK_LINES: don't break lines at 76 characters
-		 *     (only meaningful when encoding)
-		 *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
-		 * &lt;/pre&gt;
-		 * &lt;p&gt;
-		 * Example: &lt;code&gt;new Base64.InputStream( in, Base64.DECODE )&lt;/code&gt;
-		 *
-		 *
-		 * @param in the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read data.
-		 * @param options Specified options
-		 * @see Base64#ENCODE
-		 * @see Base64#DECODE
-		 * @see Base64#DONT_BREAK_LINES
-		 * @since 2.0
-		 */
-		public InputStream( java.io.InputStream in, int options )
-		{
-			super( in );
-			this.breakLines = ( options &amp; DONT_BREAK_LINES ) != DONT_BREAK_LINES;
-			this.encode = ( options &amp; ENCODE ) == ENCODE;
-			this.bufferLength = encode ? 4 : 3;
-			this.buffer = new byte[bufferLength];
-			this.position = -1;
-			this.lineLength = 0;
-		} // end constructor
+    /* ******** I N N E R C L A S S I N P U T S T R E A M ******** */
 
-		/**
-		 * Reads enough of the input stream to convert
-		 * to/from Base64 and returns the next byte.
-		 *
-		 * @return next byte
-		 * @since 1.3
-		 */
-		public int read() throws java.io.IOException
-		{
-			// Do we need to get data?
-			if ( position &lt; 0 ) {
-				if ( encode ) {
-					byte[] b3 = new byte[3];
-					int numBinaryBytes = 0;
-					for ( int i = 0; i &lt; 3; i++ ) {
-						try {
-							int b = in.read();
+    /**
+     * A {@link Base64.InputStream} will read data from another
+     * &lt;tt&gt;java.io.InputStream&lt;/tt&gt;, given in the constructor, and
+     * encode/decode to/from Base64 notation on the fly.
+     * 
+     * @see Base64
+     * @since 1.3
+     */
+    public static class InputStream extends java.io.FilterInputStream
+    {
 
-							// If end of stream, b is -1.
-							if ( b &gt;= 0 ) {
-								b3[i] = (byte) b;
-								numBinaryBytes++;
-							} // end if: not end of stream
+        private boolean encode; // Encoding or decoding
 
-						} // end try: read
-						catch ( java.io.IOException e ) {
-							// Only a problem if we got no data at all.
-							if ( i == 0 )
-								throw e;
+        private int position; // Current position in the buffer
 
-						} // end catch
-					} // end for: each needed input byte
+        private byte[] buffer; // Small buffer holding converted data
 
-					if ( numBinaryBytes &gt; 0 ) {
-						encode3to4( b3, 0, numBinaryBytes, buffer, 0 );
-						position = 0;
-						numSigBytes = 4;
-					} // end if: got data
-					else {
-						return -1;
-					} // end else
-				} // end if: encoding
+        private int bufferLength; // Length of buffer (3 or 4)
 
-				// Else decoding
-				else {
-					byte[] b4 = new byte[4];
-					int i = 0;
-					for ( i = 0; i &lt; 4; i++ ) {
-						// Read four &quot;meaningful&quot; bytes:
-						int b = 0;
-						do {
-							b = in.read();
-						} while ( b &gt;= 0 &amp;&amp; DECODABET[b &amp; 0x7f] &lt;= WHITE_SPACE_ENC );
+        private int numSigBytes; // Number of meaningful bytes in the buffer
 
-						if ( b &lt; 0 )
-							break; // Reads a -1 if end of stream
+        private int lineLength;
 
-						b4[i] = (byte) b;
-					} // end for: each needed input byte
+        private boolean breakLines; // Break lines at less than 80 characters
 
-					if ( i == 4 ) {
-						numSigBytes = decode4to3( b4, 0, buffer, 0 );
-						position = 0;
-					} // end if: got four characters
-					else
-						if ( i == 0 ) {
-							return -1;
-						} // end else if: also padded correctly
-						else {
-							// Must have broken out from above.
-							throw new java.io.IOException(
-									&quot;Improperly padded Base64 input.&quot; );
-						} // end 
+        /**
+         * Constructs a {@link Base64.InputStream} in DECODE mode.
+         * 
+         * @param in
+         *            the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read
+         *            data.
+         * @since 1.3
+         */
+        public InputStream( java.io.InputStream in )
+        {
+            this( in, DECODE );
+        } // end constructor
 
-				} // end else: decode
-			} // end else: get data
+        /**
+         * Constructs a {@link Base64.InputStream} in either ENCODE or DECODE
+         * mode.
+         * &lt;p&gt;
+         * Valid options:
+         * 
+         * &lt;pre&gt;
+         *      ENCODE or DECODE: Encode or Decode as data is read.
+         *      DONT_BREAK_LINES: don't break lines at 76 characters
+         *        (only meaningful when encoding)
+         *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+         * &lt;/pre&gt;
+         * 
+         * &lt;p&gt;
+         * Example: &lt;code&gt;new Base64.InputStream( in, Base64.DECODE )&lt;/code&gt;
+         * 
+         * 
+         * @param in
+         *            the &lt;tt&gt;java.io.InputStream&lt;/tt&gt; from which to read
+         *            data.
+         * @param options
+         *            Specified options
+         * @see Base64#ENCODE
+         * @see Base64#DECODE
+         * @see Base64#DONT_BREAK_LINES
+         * @since 2.0
+         */
+        public InputStream( java.io.InputStream in, int options )
+        {
+            super( in );
+            this.breakLines = (options &amp; DONT_BREAK_LINES) != DONT_BREAK_LINES;
+            this.encode = (options &amp; ENCODE) == ENCODE;
+            this.bufferLength = encode ? 4 : 3;
+            this.buffer = new byte[bufferLength];
+            this.position = -1;
+            this.lineLength = 0;
+        } // end constructor
 
-			// Got data?
-			if ( position &gt;= 0 ) {
-				// End of relevant data?
-				if ( /*!encode &amp;&amp;*/position &gt;= numSigBytes )
-					return -1;
+        /**
+         * Reads enough of the input stream to convert to/from Base64 and
+         * returns the next byte.
+         * 
+         * @return next byte
+         * @since 1.3
+         */
+        @Override
+        public int read() throws java.io.IOException
+        {
+            // Do we need to get data?
+            if ( position &lt; 0 ) {
+                if ( encode ) {
+                    byte[] b3 = new byte[3];
+                    int numBinaryBytes = 0;
+                    for ( int i = 0; i &lt; 3; i++ ) {
+                        try {
+                            int b = in.read();
 
-				if ( encode &amp;&amp; breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH ) {
-					lineLength = 0;
-					return '\n';
-				} // end if
-				else {
-					lineLength++; // This isn't important when decoding
-					// but throwing an extra &quot;if&quot; seems
-					// just as wasteful.
+                            // If end of stream, b is -1.
+                            if ( b &gt;= 0 ) {
+                                b3[i] = (byte) b;
+                                numBinaryBytes++;
+                            } // end if: not end of stream
 
-					int b = buffer[position++];
+                        } // end try: read
+                        catch ( java.io.IOException e ) {
+                            // Only a problem if we got no data at all.
+                            if ( i == 0 )
+                                throw e;
 
-					if ( position &gt;= bufferLength )
-						position = -1;
+                        } // end catch
+                    } // end for: each needed input byte
 
-					return b &amp; 0xFF; // This is how you &quot;cast&quot; a byte that's
-					// intended to be unsigned.
-				} // end else
-			} // end if: position &gt;= 0
+                    if ( numBinaryBytes &gt; 0 ) {
+                        encode3to4( b3, 0, numBinaryBytes, buffer, 0 );
+                        position = 0;
+                        numSigBytes = 4;
+                    } // end if: got data
+                    else {
+                        return -1;
+                    } // end else
+                } // end if: encoding
 
-			// Else error
-			else {
-				// When JDK1.4 is more accepted, use an assertion here.
-				throw new java.io.IOException( &quot;Error in Base64 code reading stream.&quot; );
-			} // end else
-		} // end read
+                // Else decoding
+                else {
+                    byte[] b4 = new byte[4];
+                    int i = 0;
+                    for ( i = 0; i &lt; 4; i++ ) {
+                        // Read four &quot;meaningful&quot; bytes:
+                        int b = 0;
+                        do {
+                            b = in.read();
+                        } while ( b &gt;= 0 &amp;&amp; DECODABET[b &amp; 0x7f] &lt;= WHITE_SPACE_ENC );
 
-		/**
-		 * Calls {@link #read()} repeatedly until the end of stream
-		 * is reached or &lt;var&gt;len&lt;/var&gt; bytes are read.
-		 * Returns number of bytes read into array or -1 if
-		 * end of stream is encountered.
-		 *
-		 * @param dest array to hold values
-		 * @param off offset for array
-		 * @param len max number of bytes to read into array
-		 * @return bytes read into array or -1 if end of stream is encountered.
-		 * @since 1.3
-		 */
-		public int read( byte[] dest, int off, int len ) throws java.io.IOException
-		{
-			int i;
-			int b;
-			for ( i = 0; i &lt; len; i++ ) {
-				b = read();
+                        if ( b &lt; 0 )
+                            break; // Reads a -1 if end of stream
 
-				//if( b &lt; 0 &amp;&amp; i == 0 )
-				//    return -1;
+                        b4[i] = (byte) b;
+                    } // end for: each needed input byte
 
-				if ( b &gt;= 0 )
-					dest[off + i] = (byte) b;
-				else
-					if ( i == 0 )
-						return -1;
-					else
-						break; // Out of 'for' loop
-			} // end for: each byte read
-			return i;
-		} // end read
+                    if ( i == 4 ) {
+                        numSigBytes = decode4to3( b4, 0, buffer, 0 );
+                        position = 0;
+                    } // end if: got four characters
+                    else if ( i == 0 ) {
+                        return -1;
+                    } // end else if: also padded correctly
+                    else {
+                        // Must have broken out from above.
+                        throw new java.io.IOException( &quot;Improperly padded Base64 input.&quot; );
+                    } // end
 
-	} // end inner class InputStream
+                } // end else: decode
+            } // end else: get data
 
-	/* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */
+            // Got data?
+            if ( position &gt;= 0 ) {
+                // End of relevant data?
+                if ( /* !encode &amp;&amp; */position &gt;= numSigBytes )
+                    return -1;
 
-	/**
-	 * A {@link Base64.OutputStream} will write data to another
-	 * &lt;tt&gt;java.io.OutputStream&lt;/tt&gt;, given in the constructor,
-	 * and encode/decode to/from Base64 notation on the fly.
-	 *
-	 * @see Base64
-	 * @since 1.3
-	 */
-	public static class OutputStream extends java.io.FilterOutputStream
-	{
+                if ( encode &amp;&amp; breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH ) {
+                    lineLength = 0;
+                    return '\n';
+                }
 
-		private boolean encode;
-		private int position;
-		private byte[] buffer;
-		private int bufferLength;
-		private int lineLength;
-		private boolean breakLines;
-		private byte[] b4; // Scratch used in a few places
-		private boolean suspendEncoding;
+                lineLength++; // This isn't important when decoding
+                // but throwing an extra &quot;if&quot; seems
+                // just as wasteful.
 
-		/**
-		 * Constructs a {@link Base64.OutputStream} in ENCODE mode.
-		 *
-		 * @param out the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be written.
-		 * @since 1.3
-		 */
-		public OutputStream( java.io.OutputStream out )
-		{
-			this( out, ENCODE );
-		} // end constructor
+                int b = buffer[position++];
 
-		/**
-		 * Constructs a {@link Base64.OutputStream} in
-		 * either ENCODE or DECODE mode.
-		 * &lt;p&gt;
-		 * Valid options:&lt;pre&gt;
-		 *   ENCODE or DECODE: Encode or Decode as data is read.
-		 *   DONT_BREAK_LINES: don't break lines at 76 characters
-		 *     (only meaningful when encoding)
-		 *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
-		 * &lt;/pre&gt;
-		 * &lt;p&gt;
-		 * Example: &lt;code&gt;new Base64.OutputStream( out, Base64.ENCODE )&lt;/code&gt;
-		 *
-		 * @param out the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be written.
-		 * @param options Specified options.
-		 * @see Base64#ENCODE
-		 * @see Base64#DECODE
-		 * @see Base64#DONT_BREAK_LINES
-		 * @since 1.3
-		 */
-		public OutputStream( java.io.OutputStream out, int options )
-		{
-			super( out );
-			this.breakLines = ( options &amp; DONT_BREAK_LINES ) != DONT_BREAK_LINES;
-			this.encode = ( options &amp; ENCODE ) == ENCODE;
-			this.bufferLength = encode ? 3 : 4;
-			this.buffer = new byte[bufferLength];
-			this.position = 0;
-			this.lineLength = 0;
-			this.suspendEncoding = false;
-			this.b4 = new byte[4];
-		} // end constructor
+                if ( position &gt;= bufferLength )
+                    position = -1;
 
-		/**
-		 * Writes the byte to the output stream after
-		 * converting to/from Base64 notation.
-		 * When encoding, bytes are buffered three
-		 * at a time before the output stream actually
-		 * gets a write() call.
-		 * When decoding, bytes are buffered four
-		 * at a time.
-		 *
-		 * @param theByte the byte to write
-		 * @since 1.3
-		 */
-		public void write( int theByte ) throws java.io.IOException
-		{
-			// Encoding suspended?
-			if ( suspendEncoding ) {
-				super.out.write( theByte );
-				return;
-			} // end if: supsended
+                return b &amp; 0xFF; // This is how you &quot;cast&quot; a byte that's
+                // intended to be unsigned.
 
-			// Encode?
-			if ( encode ) {
-				buffer[position++] = (byte) theByte;
-				if ( position &gt;= bufferLength ) // Enough to encode.
-				{
-					out.write( encode3to4( b4, buffer, bufferLength ) );
+            } // end if: position &gt;= 0
 
-					lineLength += 4;
-					if ( breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH ) {
-						out.write( NEW_LINE );
-						lineLength = 0;
-					} // end if: end of line
+            // Else error
 
-					position = 0;
-				} // end if: enough to output
-			} // end if: encoding
+            // When JDK1.4 is more accepted, use an assertion here.
+            throw new java.io.IOException( &quot;Error in Base64 code reading stream.&quot; );
 
-			// Else, Decoding
-			else {
-				// Meaningful Base64 character?
-				if ( DECODABET[theByte &amp; 0x7f] &gt; WHITE_SPACE_ENC ) {
-					buffer[position++] = (byte) theByte;
-					if ( position &gt;= bufferLength ) // Enough to output.
-					{
-						int len = Base64.decode4to3( buffer, 0, b4, 0 );
-						out.write( b4, 0, len );
-						//out.write( Base64.decode4to3( buffer ) );
-						position = 0;
-					} // end if: enough to output
-				} // end if: meaningful base64 character
-				else
-					if ( DECODABET[theByte &amp; 0x7f] != WHITE_SPACE_ENC ) {
-						throw new java.io.IOException(
-								&quot;Invalid character in Base64 data.&quot; );
-					} // end else: not white space either
-			} // end else: decoding
-		} // end write
+        } // end read
 
-		/**
-		 * Calls {@link #write(int)} repeatedly until &lt;var&gt;len&lt;/var&gt; 
-		 * bytes are written.
-		 *
-		 * @param theBytes array from which to read bytes
-		 * @param off offset for array
-		 * @param len max number of bytes to read into array
-		 * @since 1.3
-		 */
-		public void write( byte[] theBytes, int off, int len ) throws java.io.IOException
-		{
-			// Encoding suspended?
-			if ( suspendEncoding ) {
-				super.out.write( theBytes, off, len );
-				return;
-			} // end if: supsended
+        /**
+         * Calls {@link #read()} repeatedly until the end of stream is reached
+         * or &lt;var&gt;len&lt;/var&gt; bytes are read. Returns number of bytes read into
+         * array or -1 if end of stream is encountered.
+         * 
+         * @param dest
+         *            array to hold values
+         * @param off
+         *            offset for array
+         * @param len
+         *            max number of bytes to read into array
+         * @return bytes read into array or -1 if end of stream is encountered.
+         * @since 1.3
+         */
+        @Override
+        public int read( byte[] dest, int off, int len ) throws java.io.IOException
+        {
+            int i;
+            int b;
+            for ( i = 0; i &lt; len; i++ ) {
+                b = read();
 
-			for ( int i = 0; i &lt; len; i++ ) {
-				write( theBytes[off + i] );
-			} // end for: each byte written
+                // if( b &lt; 0 &amp;&amp; i == 0 )
+                // return -1;
 
-		} // end write
+                if ( b &gt;= 0 )
+                    dest[off + i] = (byte) b;
+                else if ( i == 0 )
+                    return -1;
+                else
+                    break; // Out of 'for' loop
+            } // end for: each byte read
+            return i;
+        } // end read
 
-		/**
-		 * Method added by PHIL. [Thanks, PHIL. -Rob]
-		 * This pads the buffer without closing the stream.
-		 */
-		public void flushBase64() throws java.io.IOException
-		{
-			if ( position &gt; 0 ) {
-				if ( encode ) {
-					out.write( encode3to4( b4, buffer, position ) );
-					position = 0;
-				} // end if: encoding
-				else {
-					throw new java.io.IOException( &quot;Base64 input not properly padded.&quot; );
-				} // end else: decoding
-			} // end if: buffer partially full
+    } // end inner class InputStream
 
-		} // end flush
+    /* ******** I N N E R C L A S S O U T P U T S T R E A M ******** */
 
-		/** 
-		 * Flushes and closes (I think, in the superclass) the stream. 
-		 *
-		 * @since 1.3
-		 */
-		public void close() throws java.io.IOException
-		{
-			// 1. Ensure that pending characters are written
-			flushBase64();
+    /**
+     * A {@link Base64.OutputStream} will write data to another
+     * &lt;tt&gt;java.io.OutputStream&lt;/tt&gt;, given in the constructor, and
+     * encode/decode to/from Base64 notation on the fly.
+     * 
+     * @see Base64
+     * @since 1.3
+     */
+    public static class OutputStream extends java.io.FilterOutputStream
+    {
 
-			// 2. Actually close the stream
-			// Base class both flushes and closes.
-			super.close();
+        private boolean encode;
 
-			buffer = null;
-			out = null;
-		} // end close
+        private int position;
 
-		/**
-		 * Suspends encoding of the stream.
-		 * May be helpful if you need to embed a piece of
-		 * base640-encoded data in a stream.
-		 *
-		 * @since 1.5.1
-		 */
-		public void suspendEncoding() throws java.io.IOException
-		{
-			flushBase64();
-			this.suspendEncoding = true;
-		} // end suspendEncoding
+        private byte[] buffer;
 
-		/**
-		 * Resumes encoding of the stream.
-		 * May be helpful if you need to embed a piece of
-		 * base640-encoded data in a stream.
-		 *
-		 * @since 1.5.1
-		 */
-		public void resumeEncoding()
-		{
-			this.suspendEncoding = false;
-		} // end resumeEncoding
+        private int bufferLength;
 
-	} // end inner class OutputStream
+        private int lineLength;
 
+        private boolean breakLines;
+
+        private byte[] b4; // Scratch used in a few places
+
+        private boolean suspendEncoding;
+
+        /**
+         * Constructs a {@link Base64.OutputStream} in ENCODE mode.
+         * 
+         * @param out
+         *            the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be
+         *            written.
+         * @since 1.3
+         */
+        public OutputStream( java.io.OutputStream out )
+        {
+            this( out, ENCODE );
+        } // end constructor
+
+        /**
+         * Constructs a {@link Base64.OutputStream} in either ENCODE or DECODE
+         * mode.
+         * &lt;p&gt;
+         * Valid options:
+         * 
+         * &lt;pre&gt;
+         *      ENCODE or DECODE: Encode or Decode as data is read.
+         *      DONT_BREAK_LINES: don't break lines at 76 characters
+         *        (only meaningful when encoding)
+         *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+         * &lt;/pre&gt;
+         * 
+         * &lt;p&gt;
+         * Example: &lt;code&gt;new Base64.OutputStream( out, Base64.ENCODE )&lt;/code&gt;
+         * 
+         * @param out
+         *            the &lt;tt&gt;java.io.OutputStream&lt;/tt&gt; to which data will be
+         *            written.
+         * @param options
+         *            Specified options.
+         * @see Base64#ENCODE
+         * @see Base64#DECODE
+         * @see Base64#DONT_BREAK_LINES
+         * @since 1.3
+         */
+        public OutputStream( java.io.OutputStream out, int options )
+        {
+            super( out );
+            this.breakLines = (options &amp; DONT_BREAK_LINES) != DONT_BREAK_LINES;
+            this.encode = (options &amp; ENCODE) == ENCODE;
+            this.bufferLength = encode ? 3 : 4;
+            this.buffer = new byte[bufferLength];
+            this.position = 0;
+            this.lineLength = 0;
+            this.suspendEncoding = false;
+            this.b4 = new byte[4];
+        } // end constructor
+
+        /**
+         * Writes the byte to the output stream after converting to/from Base64
+         * notation. When encoding, bytes are buffered three at a time before
+         * the output stream actually gets a write() call. When decoding, bytes
+         * are buffered four at a time.
+         * 
+         * @param theByte
+         *            the byte to write
+         * @since 1.3
+         */
+        @Override
+        public void write( int theByte ) throws java.io.IOException
+        {
+            // Encoding suspended?
+            if ( suspendEncoding ) {
+                super.out.write( theByte );
+                return;
+            } // end if: supsended
+
+            // Encode?
+            if ( encode ) {
+                buffer[position++] = (byte) theByte;
+                if ( position &gt;= bufferLength ) // Enough to encode.
+                {
+                    out.write( encode3to4( b4, buffer, bufferLength ) );
+
+                    lineLength += 4;
+                    if ( breakLines &amp;&amp; lineLength &gt;= MAX_LINE_LENGTH ) {
+                        out.write( NEW_LINE );
+                        lineLength = 0;
+                    } // end if: end of line
+
+                    position = 0;
+                } // end if: enough to output
+            } // end if: encoding
+
+            // Else, Decoding
+            else {
+                // Meaningful Base64 character?
+                if ( DECODABET[theByte &amp; 0x7f] &gt; WHITE_SPACE_ENC ) {
+                    buffer[position++] = (byte) theByte;
+                    if ( position &gt;= bufferLength ) // Enough to output.
+                    {
+                        int len = Base64.decode4to3( buffer, 0, b4, 0 );
+                        out.write( b4, 0, len );
+                        // out.write( Base64.decode4to3( buffer ) );
+                        position = 0;
+                    } // end if: enough to output
+                } // end if: meaningful base64 character
+                else if ( DECODABET[theByte &amp; 0x7f] != WHITE_SPACE_ENC ) {
+                    throw new java.io.IOException( &quot;Invalid character in Base64 data.&quot; );
+                } // end else: not white space either
+            } // end else: decoding
+        } // end write
+
+        /**
+         * Calls {@link #write(int)} repeatedly until &lt;var&gt;len&lt;/var&gt; bytes are
+         * written.
+         * 
+         * @param theBytes
+         *            array from which to read bytes
+         * @param off
+         *            offset for array
+         * @param len
+         *            max number of bytes to read into array
+         * @since 1.3
+         */
+        @Override
+        public void write( byte[] theBytes, int off, int len ) throws java.io.IOException
+        {
+            // Encoding suspended?
+            if ( suspendEncoding ) {
+                super.out.write( theBytes, off, len );
+                return;
+            } // end if: supsended
+
+            for ( int i = 0; i &lt; len; i++ ) {
+                write( theBytes[off + i] );
+            } // end for: each byte written
+
+        } // end write
+
+        /**
+         * Method added by PHIL. [Thanks, PHIL. -Rob] This pads the buffer
+         * without closing the stream.
+         */
+        public void flushBase64() throws java.io.IOException
+        {
+            if ( position &gt; 0 ) {
+                if ( encode ) {
+                    out.write( encode3to4( b4, buffer, position ) );
+                    position = 0;
+                } // end if: encoding
+                else {
+                    throw new java.io.IOException( &quot;Base64 input not properly padded.&quot; );
+                } // end else: decoding
+            } // end if: buffer partially full
+
+        } // end flush
+
+        /**
+         * Flushes and closes (I think, in the superclass) the stream.
+         * 
+         * @since 1.3
+         */
+        @Override
+        public void close() throws java.io.IOException
+        {
+            // 1. Ensure that pending characters are written
+            flushBase64();
+
+            // 2. Actually close the stream
+            // Base class both flushes and closes.
+            super.close();
+
+            buffer = null;
+            out = null;
+        } // end close
+
+        /**
+         * Suspends encoding of the stream. May be helpful if you need to embed
+         * a piece of base640-encoded data in a stream.
+         * 
+         * @since 1.5.1
+         */
+        public void suspendEncoding() throws java.io.IOException
+        {
+            flushBase64();
+            this.suspendEncoding = true;
+        } // end suspendEncoding
+
+        /**
+         * Resumes encoding of the stream. May be helpful if you need to embed a
+         * piece of base640-encoded data in a stream.
+         * 
+         * @since 1.5.1
+         */
+        public void resumeEncoding()
+        {
+            this.suspendEncoding = false;
+        } // end resumeEncoding
+
+    } // end inner class OutputStream
+
 } // end class Base64

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/NetworkInterface.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/NetworkInterface.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/NetworkInterface.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -100,7 +100,7 @@
 				addresses.addAll( getAddresses( networkInterface ) );
 
 			} catch ( Exception e ) {
-				log.error( &quot;Cannot register network interface: &quot; + interfaceName, e );
+				log.error( &quot;Cannot register network interface '{}': {} &quot;, interfaceName, e );
 				return null;
 			}
 		} else {

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Npt.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Npt.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Npt.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -88,9 +88,10 @@
 		return npt;
 	}
 
-	public String toString()
+	@Override
+    public String toString()
 	{
-		StringBuilder s = new StringBuilder();
+		final StringBuilder s = new StringBuilder();
 		s.append( &quot;npt=&quot; );
 		if ( live )
 			s.append( &quot;now-&quot; );
@@ -99,7 +100,7 @@
 				s.append( &quot;0-&quot; );
 			else {
 				s.append( Double.toString( timeStart ) );
-				s.append( &quot;-&quot; );
+				s.append( '-' );
 			}
 
 			if ( timeEnd != 0.0 ) {

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/PortManager.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/PortManager.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/PortManager.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -33,140 +33,140 @@
 public class PortManager
 {
 
-	private static Logger log = LoggerFactory.getLogger( PortManager.class );
+    private static Logger log = LoggerFactory.getLogger( PortManager.class );
 
-	protected static final int minUdpPort = 6790;
-	protected static final int maxUdpPort = 49151;
-	private static Set&lt;Integer&gt; reservedPorts = Collections.synchronizedSet( new HashSet&lt;Integer&gt;() );
+    protected static final int minUdpPort = 6790;
 
-	// TODO: Using custom exceptions
-	public static void reservePort( int port ) throws Exception
-	{
-		if ( reservedPorts.contains( port ) )
-			throw new Exception( &quot;Port &quot; + port + &quot;is reserved&quot; );
+    protected static final int maxUdpPort = 49151;
 
-		reservedPorts.add( port );
-	}
+    private static Set&lt;Integer&gt; reservedPorts = Collections
+            .synchronizedSet( new HashSet&lt;Integer&gt;() );
 
-	public static void removePort( int port )
-	{
-		reservedPorts.remove( port );
-	}
+    // TODO: Using custom exceptions
+    public static void reservePort( int port ) throws Exception
+    {
+        if ( reservedPorts.contains( port ) )
+            throw new Exception( &quot;Port &quot; + port + &quot;is reserved&quot; );
 
-	/**
-	 * @param port
-	 *        To port to be tested
-	 * @return true if the port is already reserved, false if the port can be
-	 *         used.
-	 */
-	public static boolean isPortReserved( int port )
-	{
-		return reservedPorts.contains( port );
-	}
+        reservedPorts.add( port );
+    }
 
-	/**
-	 * Get the first port (starting from &lt;i&gt;start&lt;/i&gt;) that does not appear in
-	 * the reservation list.
-	 * 
-	 * @param start
-	 *        the base port number to start from
-	 * @return the port number if found
-	 */
-	public static int getNextNotReservedPort( int start )
-			throws NoPortAvailableException
-	{
-		int port = start;
-		while ( reservedPorts.contains( port ) ) {
-			if ( port &gt; maxUdpPort ) {
-				// port not found
-				throw new NoPortAvailableException();
-			}
-			port += 1;
-		}
-		return port;
-	}
+    public static void removePort( int port )
+    {
+        reservedPorts.remove( port );
+    }
 
-	public static int[] findAvailablePorts( int nPorts, int startFrom )
-		throws NoPortAvailableException
-	{
-		int dataPort, controlPort, startingPort;
+    /**
+     * @param port
+     *            To port to be tested
+     * @return true if the port is already reserved, false if the port can be
+     *         used.
+     */
+    public static boolean isPortReserved( int port )
+    {
+        return reservedPorts.contains( port );
+    }
 
-		startingPort = startFrom;
+    /**
+     * Get the first port (starting from &lt;i&gt;start&lt;/i&gt;) that does not appear in
+     * the reservation list.
+     * 
+     * @param start
+     *            the base port number to start from
+     * @return the port number if found
+     */
+    public static int getNextNotReservedPort( int start ) throws NoPortAvailableException
+    {
+        int port = start;
+        while ( reservedPorts.contains( port ) ) {
+            if ( port &gt; maxUdpPort ) {
+                // port not found
+                throw new NoPortAvailableException();
+            }
+            port += 1;
+        }
+        return port;
+    }
 
-		while ( true ) {
-			
-			startingPort = getNextNotReservedPort( startingPort );
-			dataPort = getNextPortAvailable( startingPort );
+    public static int[] findAvailablePorts( int nPorts, int startFrom )
+            throws NoPortAvailableException
+    {
+        int dataPort, controlPort, startingPort;
 
-			if ( isPortReserved( dataPort ) ) {
-				// The port is effectively unbound, but reserved in
-				// PortManager.
-				startingPort += nPorts;
-				continue;
-			}
+        startingPort = startFrom;
 
-			if ( nPorts == 1 ) {
-				// There is only the data port
-				int[] a = { dataPort };
-				log.debug( &quot;DataPort: &quot; + dataPort );
-				try {
-					reservePort( dataPort );
-				} catch ( Exception e ) {
-					continue;
-				}
-				return a;
+        while ( true ) {
 
-			} else if ( nPorts == 2 ) {
-				// We have to find 2 consequents free UDP ports.
-				// also: dataPort must be an even number
-				if ( ( dataPort % 2 ) != 0 ) {
-					continue;
+            startingPort = getNextNotReservedPort( startingPort );
+            dataPort = getNextPortAvailable( startingPort );
 
-				} else {
-					controlPort = getNextPortAvailable( dataPort + 1 );
+            if ( isPortReserved( dataPort ) ) {
+                // The port is effectively unbound, but reserved in
+                // PortManager.
+                startingPort += nPorts;
+                continue;
+            }
 
-					if ( controlPort != ( dataPort + 1 ) ) {
-						// port are not consequents
-						continue;
-					} else if ( isPortReserved( controlPort ) ) {
-						continue;
+            if ( nPorts == 1 ) {
+                // There is only the data port
+                int[] a = { dataPort };
+                log.debug( &quot;DataPort: {}&quot;, dataPort );
+                try {
+                    reservePort( dataPort );
+                } catch ( Exception e ) {
+                    continue;
+                }
+                return a;
 
-					} else {
-						try {
-							reservePort( dataPort );
-							reservePort( controlPort );
-						} catch ( Exception e ) {
-							continue;
-						}
+            } else if ( nPorts == 2 ) {
+                // We have to find 2 consequents free UDP ports.
+                // also: dataPort must be an even number
+                if ( (dataPort % 2) != 0 ) {
+                    continue;
+                }
+                controlPort = getNextPortAvailable( dataPort + 1 );
 
-						int[] a = { dataPort, controlPort };
-						log.debug( &quot;DataPort: &quot; + dataPort + &quot; - ControlPort: &quot;
-								+ controlPort );
-						return a;
-					}
-				}
-			}
-		}
-	}
+                if ( controlPort != (dataPort + 1) ) {
+                    // port are not consequents
+                    continue;
+                } else if ( isPortReserved( controlPort ) ) {
+                    continue;
 
-	private static int getNextPortAvailable( int startPort )
-			throws NoPortAvailableException
-	{
+                } else {
+                    try {
+                        reservePort( dataPort );
+                        reservePort( controlPort );
+                    } catch ( Exception e ) {
+                        continue;
+                    }
 
-		for ( int port = startPort; port &lt;= maxUdpPort; port++ ) {
-			DatagramSocket s = null;
-			try {
-				s = new DatagramSocket( port );
-				s.close();
-				return port;
+                    int[] a = { dataPort, controlPort };
+                    log.debug( &quot;DataPort: {} - ControlPort: {}&quot;, dataPort, controlPort );
+                    return a;
+                }
 
-			} catch ( IOException e ) {
-				// Ignore
-			}
-		}
+            }
+        }
+    }
 
-		// No port is available
-		throw new NoPortAvailableException();
-	}
+    private static int getNextPortAvailable( int startPort )
+            throws NoPortAvailableException
+    {
 
+        for ( int port = startPort; port &lt;= maxUdpPort; port++ ) {
+            DatagramSocket s = null;
+            try {
+                s = new DatagramSocket( port );
+                s.close();
+                return port;
+
+            } catch ( IOException e ) {
+                // Ignore
+            }
+        }
+
+        // No port is available
+        throw new NoPortAvailableException();
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -9,37 +9,41 @@
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
  */
 public enum Side {
-	Any,     // filter is meant for any side
-	Client,  // select filters that are applied on the client-side session
-	Server;  // select filters that are applied on the server-side session
-	
-	public String toString() {
-		switch(this) {
-		case Any:
-			return &quot;any&quot;;
-		case Client:
-			return &quot;client&quot;;
-		case Server:
-			return &quot;server&quot;;
-		default:
-			return &quot;unknown&quot;;
-		}
-	}
-	
-	public static Side fromString(String value) throws IllegalArgumentException {
-		Side side;
-		
-		if(value == null || value.length() == 0)
-			side = Any;
-		else if(value.equalsIgnoreCase(&quot;server&quot;))
-			side = Server;
-		else if(value.equalsIgnoreCase(&quot;client&quot;))
-			side = Client;
-		else if(value.equalsIgnoreCase(&quot;any&quot;))
-			side = Any;
-		else
-			throw new IllegalArgumentException(&quot;invalid side value given: &quot; + value);
-		
-		return side;
-	}
-}
\ No newline at end of file
+    Any, // filter is meant for any side
+    Client, // select filters that are applied on the client-side session
+    Server; // select filters that are applied on the server-side session
+
+    @Override
+    public String toString()
+    {
+        switch ( this )
+        {
+        case Any:
+            return &quot;any&quot;;
+        case Client:
+            return &quot;client&quot;;
+        case Server:
+            return &quot;server&quot;;
+        default:
+            return &quot;unknown&quot;;
+        }
+    }
+
+    public static Side fromString( String value ) throws IllegalArgumentException
+    {
+        Side side;
+
+        if ( value == null || value.length() == 0 )
+            side = Any;
+        else if ( value.equalsIgnoreCase( &quot;server&quot; ) )
+            side = Server;
+        else if ( value.equalsIgnoreCase( &quot;client&quot; ) )
+            side = Client;
+        else if ( value.equalsIgnoreCase( &quot;any&quot; ) )
+            side = Any;
+        else
+            throw new IllegalArgumentException( &quot;invalid side value given: &quot; + value );
+
+        return side;
+    }
+}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Singleton.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Singleton.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Singleton.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -47,7 +47,8 @@
 		classMap.put( this.getClass(), this );
 	}
 
-	public void finalize()
+	@Override
+    public void finalize()
 	{
 		classMap.remove( this.getClass() );
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,6 +26,8 @@
  */
 public final class UnsignedInt extends UnsignedNumber {
 	static final long serialVersionUID = 1L;
+    
+    public static final UnsignedInt ZERO = new UnsignedInt( 0 );
 
 	private long value;
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,208 +26,227 @@
  * 
  * @author Matteo Merli
  */
-public final class UnsignedLong extends UnsignedNumber {
+public final class UnsignedLong extends UnsignedNumber
+{
 
-	private static final long serialVersionUID = 1L;
+    private static final long serialVersionUID = 1L;
 
-	private byte[] value = new byte[8];
+    private byte[] value = new byte[8];
 
-	public UnsignedLong(byte c) {
-		Arrays.fill(value, (byte) 0);
-		value[7] = c;
-	}
+    public UnsignedLong( byte c )
+    {
+        Arrays.fill( value, (byte) 0 );
+        value[7] = c;
+    }
 
-	public UnsignedLong(short c) {
-		Arrays.fill(value, (byte) 0);
-		value[6] = (byte) ((c &gt;&gt; 8) &amp; 0xFF);
-		value[7] = (byte) (c &amp; 0xFF);
-	}
+    public UnsignedLong( short c )
+    {
+        Arrays.fill( value, (byte) 0 );
+        value[6] = (byte) ((c &gt;&gt; 8) &amp; 0xFF);
+        value[7] = (byte) (c &amp; 0xFF);
+    }
 
-	public UnsignedLong(int c) {
-		Arrays.fill(value, (byte) 0);
-		value[4] = (byte) ((c &gt;&gt; 24) &amp; 0xFF);
-		value[5] = (byte) ((c &gt;&gt; 16) &amp; 0xFF);
-		value[6] = (byte) ((c &gt;&gt; 8) &amp; 0xFF);
-		value[7] = (byte) (c &amp; 0xFF);
-	}
+    public UnsignedLong( int c )
+    {
+        Arrays.fill( value, (byte) 0 );
+        value[4] = (byte) ((c &gt;&gt; 24) &amp; 0xFF);
+        value[5] = (byte) ((c &gt;&gt; 16) &amp; 0xFF);
+        value[6] = (byte) ((c &gt;&gt; 8) &amp; 0xFF);
+        value[7] = (byte) (c &amp; 0xFF);
+    }
 
-	public UnsignedLong(long c) {
-		value[0] = (byte) ((c &gt;&gt; 56) &amp; 0xFF);
-		value[1] = (byte) ((c &gt;&gt; 48) &amp; 0xFF);
-		value[2] = (byte) ((c &gt;&gt; 40) &amp; 0xFF);
-		value[3] = (byte) ((c &gt;&gt; 32) &amp; 0xFF);
-		value[4] = (byte) ((c &gt;&gt; 24) &amp; 0xFF);
-		value[5] = (byte) ((c &gt;&gt; 16) &amp; 0xFF);
-		value[6] = (byte) ((c &gt;&gt; 8) &amp; 0xFF);
-		value[7] = (byte) (c &amp; 0xFF);
-	}
+    public UnsignedLong( long c )
+    {
+        value[0] = (byte) ((c &gt;&gt; 56) &amp; 0xFF);
+        value[1] = (byte) ((c &gt;&gt; 48) &amp; 0xFF);
+        value[2] = (byte) ((c &gt;&gt; 40) &amp; 0xFF);
+        value[3] = (byte) ((c &gt;&gt; 32) &amp; 0xFF);
+        value[4] = (byte) ((c &gt;&gt; 24) &amp; 0xFF);
+        value[5] = (byte) ((c &gt;&gt; 16) &amp; 0xFF);
+        value[6] = (byte) ((c &gt;&gt; 8) &amp; 0xFF);
+        value[7] = (byte) (c &amp; 0xFF);
+    }
 
-	/**
-	 * Construct a new random UnsignedLong.
-	 * 
-	 * @param random
-	 *            a Random handler
-	 */
-	public UnsignedLong(Random random) {
-		random.nextBytes(value);
-	}
+    /**
+     * Construct a new random UnsignedLong.
+     * 
+     * @param random
+     *            a Random handler
+     */
+    public UnsignedLong( Random random )
+    {
+        random.nextBytes( value );
+    }
 
-	private UnsignedLong() {
-		Arrays.fill(value, (byte) 0);
-	}
+    private UnsignedLong()
+    {
+        Arrays.fill( value, (byte) 0 );
+    }
 
-	public static UnsignedLong fromBytes(byte[] c) {
-		return fromBytes(c, 0);
-	}
+    public static UnsignedLong fromBytes( byte[] c )
+    {
+        return fromBytes( c, 0 );
+    }
 
-	public static UnsignedLong fromBytes(byte[] c, int offset) {
-		UnsignedLong number = new UnsignedLong();
-		if ((c.length - offset) &lt; 8)
-			throw new IllegalArgumentException(
-					&quot;An UnsignedLong number is composed of 8 bytes.&quot;);
+    public static UnsignedLong fromBytes( byte[] c, int offset )
+    {
+        UnsignedLong number = new UnsignedLong();
+        if ( (c.length - offset) &lt; 8 )
+            throw new IllegalArgumentException(
+                    &quot;An UnsignedLong number is composed of 8 bytes.&quot; );
 
-		for (int i = 7; i &gt;= 0; i--)
-			number.value[i] = c[offset + i];
-		return number;
-	}
+        for ( int i = 7; i &gt;= 0; i-- )
+            number.value[i] = c[offset + i];
+        return number;
+    }
 
-	public static UnsignedLong fromString(String c) {
-		return fromString(c, 10);
-	}
+    public static UnsignedLong fromString( String c )
+    {
+        return fromString( c, 10 );
+    }
 
-	public static UnsignedLong fromString(String c, int radix) {
-		UnsignedLong number = new UnsignedLong();
+    public static UnsignedLong fromString( String c, int radix )
+    {
+        UnsignedLong number = new UnsignedLong();
 
-		BigInteger n = new BigInteger(c, radix);
-		byte[] bytes = n.toByteArray();
+        BigInteger n = new BigInteger( c, radix );
+        byte[] bytes = n.toByteArray();
 
-		int len = Math.min(8, bytes.length);
-		for (int i = 0; i &lt; len; i++)
-			number.value[7 - i] = bytes[bytes.length - 1 - i];
-		return number;
-	}
+        int len = Math.min( 8, bytes.length );
+        for ( int i = 0; i &lt; len; i++ )
+            number.value[7 - i] = bytes[bytes.length - 1 - i];
+        return number;
+    }
 
-	@Override
-	public byte[] getBytes() {
-		return value;
-	}
+    @Override
+    public byte[] getBytes()
+    {
+        return value;
+    }
 
-	@Override
-	public String toString() {
-		if ((byte) ((value[0] &gt;&gt; 7) &amp; 0x01) == 1) {
-			value[0] = (byte) (value[0] &amp; 0x7F);
-			BigInteger n = new BigInteger(value);
-			n = n.setBit(63);
-			value[0] = (byte) (value[0] | 0x80);
-			return n.toString();
-		} else {
-			BigInteger n = new BigInteger(value);
-			return n.toString();
-		}
-	}
+    @Override
+    public String toString()
+    {
+        if ( (byte) ((value[0] &gt;&gt; 7) &amp; 0x01) == 1 ) {
+            value[0] = (byte) (value[0] &amp; 0x7F);
+            BigInteger n = new BigInteger( value );
+            n = n.setBit( 63 );
+            value[0] = (byte) (value[0] | 0x80);
+            return n.toString();
+        }
+        
+        BigInteger n = new BigInteger( value );
+        return n.toString();
+    }
 
-	@Override
-	public int intValue() {
-		return (((int) value[4] &lt;&lt; 24) &amp; 0xFF000000 | ((int) value[5] &lt;&lt; 16)
-				&amp; 0xFF0000 | ((int) value[6] &lt;&lt; 8) &amp; 0xFF00 | ((int) value[7] &amp; 0xFF));
-	}
+    @Override
+    public int intValue()
+    {
+        return (((int) value[4] &lt;&lt; 24) &amp; 0xFF000000 | ((int) value[5] &lt;&lt; 16) &amp; 0xFF0000
+                | ((int) value[6] &lt;&lt; 8) &amp; 0xFF00 | ((int) value[7] &amp; 0xFF));
+    }
 
-	@Override
-	public long longValue() {
-		return (((long) value[0] &lt;&lt; 56) &amp; 0xFF00000000000000L
-				| ((long) value[1] &lt;&lt; 48) &amp; 0xFF000000000000L
-				| ((long) value[2] &lt;&lt; 40) &amp; 0xFF0000000000L
-				| ((long) value[3] &lt;&lt; 32) &amp; 0xFF00000000L
-				| ((long) value[4] &lt;&lt; 24) &amp; 0xFF000000L
-				| ((long) value[5] &lt;&lt; 16) &amp; 0xFF0000L | ((long) value[6] &lt;&lt; 8)
-				&amp; 0xFF00L | ((long) (value[7]) &amp; 0xFFL));
-	}
+    @Override
+    public long longValue()
+    {
+        return (((long) value[0] &lt;&lt; 56) &amp; 0xFF00000000000000L | ((long) value[1] &lt;&lt; 48)
+                &amp; 0xFF000000000000L | ((long) value[2] &lt;&lt; 40) &amp; 0xFF0000000000L
+                | ((long) value[3] &lt;&lt; 32) &amp; 0xFF00000000L | ((long) value[4] &lt;&lt; 24)
+                &amp; 0xFF000000L | ((long) value[5] &lt;&lt; 16) &amp; 0xFF0000L
+                | ((long) value[6] &lt;&lt; 8) &amp; 0xFF00L | ((long) (value[7]) &amp; 0xFFL));
+    }
 
-	@Override
-	public float floatValue() {
-		return (float) longValue();
-	}
+    @Override
+    public float floatValue()
+    {
+        return longValue();
+    }
 
-	@Override
-	public double doubleValue() {
-		return (double) longValue();
-	}
+    @Override
+    public double doubleValue()
+    {
+        return longValue();
+    }
 
-	@Override
-	public int compareTo(UnsignedNumber other) {
-		byte[] otherValue = other.getBytes();
-		if (otherValue.length &gt; 8)
-			throw new IllegalArgumentException(
-					&quot;The number is more than 8 bytes.&quot;);
+    @Override
+    public int compareTo( UnsignedNumber other )
+    {
+        byte[] otherValue = other.getBytes();
+        if ( otherValue.length &gt; 8 )
+            throw new IllegalArgumentException( &quot;The number is more than 8 bytes.&quot; );
 
-		byte[] normalValue = new byte[8];
-		Arrays.fill(normalValue, (byte) 0);
-		for (int i = 1; i &lt;= otherValue.length; i++) {
-			normalValue[8 - i] = otherValue[otherValue.length - i];
-		}
+        byte[] normalValue = new byte[8];
+        Arrays.fill( normalValue, (byte) 0 );
+        for ( int i = 1; i &lt;= otherValue.length; i++ ) {
+            normalValue[8 - i] = otherValue[otherValue.length - i];
+        }
 
-		for (int i = 0; i &lt; 8; i++)
-			if ((char) value[i] &gt; (char) normalValue[i])
-				return +1;
-			else if ((char) value[i] &lt; (char) normalValue[i])
-				return -1;
-		return 0;
-	}
+        for ( int i = 0; i &lt; 8; i++ )
+            if ( (char) value[i] &gt; (char) normalValue[i] )
+                return +1;
+            else if ( (char) value[i] &lt; (char) normalValue[i] )
+                return -1;
+        return 0;
+    }
 
-	@Override
-	public boolean equals(Object other) {
-		if (other instanceof UnsignedLong) {
-			// this is a special case
-			byte[] bytes = ((UnsignedLong) other).getBytes();
-			for (int i = 7; i &gt;= 0; i--)
-				if (value[i] != bytes[i])
-					return false;
-			return true;
-		} else if (other instanceof Number)
-			return longValue() == ((Number) other).longValue();
-		else
-			return false;
-	}
-	
-	@Override
-	public int hashCode() {
-		int hashCode = 0;
+    @Override
+    public boolean equals( Object other )
+    {
+        if ( other instanceof UnsignedLong ) {
+            // this is a special case
+            byte[] bytes = ((UnsignedLong) other).getBytes();
+            for ( int i = 7; i &gt;= 0; i-- )
+                if ( value[i] != bytes[i] )
+                    return false;
+            return true;
+        } else if ( other instanceof Number )
+            return longValue() == ((Number) other).longValue();
+        else
+            return false;
+    }
 
-		for (int i=0; i&lt;value.length; i++)
-		    hashCode = (int)(31*hashCode + (value[i] &amp; 0xFFFFFFFFL));
-		
-		return hashCode;
-	}
+    @Override
+    public int hashCode()
+    {
+        int hashCode = 0;
 
-	@Override
-	public void shiftRight(int nBits) {
-		if (nBits &gt; 64 || nBits &lt; 0)
-			throw new IllegalArgumentException(&quot;Cannot right shift &quot; + nBits
-					+ &quot; an UnsignedLong.&quot;);
-		if (nBits % 8 != 0)
-			throw new IllegalArgumentException(&quot;nBits must be a multiple of 8.&quot;);
+        for ( int i = 0; i &lt; value.length; i++ )
+            hashCode = (int) (31 * hashCode + (value[i] &amp; 0xFFFFFFFFL));
 
-		int nBytes = nBits / 8;
-		for (int i = 7; i &gt;= nBytes; i--)
-			value[i] = value[i - nBytes];
-		for (int i = nBytes - 1; i &gt;= 0; i--)
-			value[i] = 0;
-	}
+        return hashCode;
+    }
 
-	@Override
-	public void shiftLeft(int nBits) {
-		if (nBits &gt; 64 || nBits &lt; 0)
-			throw new IllegalArgumentException(&quot;Cannot left shift &quot; + nBits
-					+ &quot; an UnsignedLong.&quot;);
-		if (nBits % 8 != 0)
-			throw new IllegalArgumentException(&quot;nBits must be a multiple of 8.&quot;);
+    @Override
+    public void shiftRight( int nBits )
+    {
+        if ( nBits &gt; 64 || nBits &lt; 0 )
+            throw new IllegalArgumentException( &quot;Cannot right shift &quot; + nBits
+                    + &quot; an UnsignedLong.&quot; );
+        if ( nBits % 8 != 0 )
+            throw new IllegalArgumentException( &quot;nBits must be a multiple of 8.&quot; );
 
-		int nBytes = nBits / 8;
-		for (int i = 0; i &lt;= 7 - nBytes; i++) {
-			value[i] = value[i + nBytes];
-		}
-		for (int i = 8 - nBytes; i &lt; 8; i++) {
-			value[i] = 0;
-		}
-	}
+        int nBytes = nBits / 8;
+        for ( int i = 7; i &gt;= nBytes; i-- )
+            value[i] = value[i - nBytes];
+        for ( int i = nBytes - 1; i &gt;= 0; i-- )
+            value[i] = 0;
+    }
+
+    @Override
+    public void shiftLeft( int nBits )
+    {
+        if ( nBits &gt; 64 || nBits &lt; 0 )
+            throw new IllegalArgumentException( &quot;Cannot left shift &quot; + nBits
+                    + &quot; an UnsignedLong.&quot; );
+        if ( nBits % 8 != 0 )
+            throw new IllegalArgumentException( &quot;nBits must be a multiple of 8.&quot; );
+
+        int nBytes = nBits / 8;
+        for ( int i = 0; i &lt;= 7 - nBytes; i++ ) {
+            value[i] = value[i + nBytes];
+        }
+        for ( int i = 8 - nBytes; i &lt; 8; i++ ) {
+            value[i] = 0;
+        }
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -45,13 +45,16 @@
 	 */
 	public abstract void shiftLeft(int nBits);
 
-	public abstract String toString();
+	@Override
+    public abstract String toString();
 
 	public abstract int compareTo(UnsignedNumber other);
 
-	public abstract boolean equals(Object other);
+	@Override
+    public abstract boolean equals(Object other);
 	
-	public abstract int hashCode();
+	@Override
+    public abstract int hashCode();
 
 	public String toHexString() {
 		return toHexString(false);

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -74,12 +74,12 @@
 
 	@Override
 	public double doubleValue() {
-		return (double) value;
+		return value;
 	}
 
 	@Override
 	public float floatValue() {
-		return (float) value;
+		return value;
 	}
 
 	@Override
@@ -124,7 +124,7 @@
 	
 	@Override
 	public int hashCode() {
-		return (int)value;
+		return value;
 	}
 
 	@Override

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRdtPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRdtPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRdtPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -20,17 +20,14 @@
 
 import java.net.InetSocketAddress;
 
-import org.apache.mina.common.IoFilterChain;
 import org.apache.mina.common.IoHandlerAdapter;
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.TrafficMask;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.lib.Exceptions;
 import rtspproxy.proxy.track.RdtTrack;
 import rtspproxy.proxy.track.Track;
-import rtspproxy.rdt.RdtFilterChainBuilder;
 import rtspproxy.rdt.RdtPacket;
 
 /**
@@ -42,70 +39,67 @@
 public class ClientRdtPacketHandler extends IoHandlerAdapter
 {
 
-	private static Logger log = LoggerFactory.getLogger( ClientRdtPacketHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ClientRdtPacketHandler.class );
 
-	/**
-	 * this sessionCreated method is an ugly hack. It suspends the session for a moment and
-	 * checks the filter chain if the protocol filter has already been applied to the 
-	 * session. If not, it assembles the filter chain. This should have been done by the acceptor
-	 * (which he does not do (in mina 0.9.0))
-	 */
-	@Override
-	public void sessionCreated( IoSession session ) throws Exception
-	{
-		/*
-		log.debug(&quot;new client-side RDT session created&quot;);
+    /**
+     * this sessionCreated method is an ugly hack. It suspends the session for a
+     * moment and checks the filter chain if the protocol filter has already
+     * been applied to the session. If not, it assembles the filter chain. This
+     * should have been done by the acceptor (which he does not do (in mina
+     * 0.9.0))
+     */
+    @Override
+    public void sessionCreated( IoSession session ) throws Exception
+    {
+        /*
+         * log.debug(&quot;new client-side RDT session created&quot;);
+         * 
+         * TrafficMask mask = session.getTrafficMask();
+         * 
+         * try { session.setTrafficMask(TrafficMask.NONE);
+         * 
+         * IoFilterChain chain = session.getFilterChain();
+         * 
+         * if(!chain.contains(RdtFilterChainBuilder.rdtCODEC)) {
+         * log.debug(&quot;hot-patching filter chain&quot;); (new
+         * RdtFilterChainBuilder()).buildFilterChain(chain); } } finally {
+         * session.setTrafficMask(mask); }
+         */
+    }
 
-		TrafficMask mask = session.getTrafficMask();
-		
-		try {
-			session.setTrafficMask(TrafficMask.NONE);
-			
-			IoFilterChain chain = session.getFilterChain();
-			
-			if(!chain.contains(RdtFilterChainBuilder.rdtCODEC)) {
-				log.debug(&quot;hot-patching filter chain&quot;);
-				(new RdtFilterChainBuilder()).buildFilterChain(chain);
-			}
-		} finally {
-			session.setTrafficMask(mask);
-		}
-		*/
-	}
+    @Override
+    public void messageReceived( IoSession session, Object buffer ) throws Exception
+    {
+        if ( buffer instanceof RdtPacket ) {
+            RdtPacket rdtPacket = (RdtPacket) buffer;
 
-	@Override
-	public void messageReceived( IoSession session, Object buffer ) throws Exception
-	{
-		if(buffer instanceof RdtPacket) {
-			RdtPacket rdtPacket = (RdtPacket)buffer;
-			
-			log.debug( &quot;Received RDT packet from client, packet=&quot; + rdtPacket );
+            log.debug( &quot;Received RDT packet from client, packet={}&quot;, rdtPacket );
 
-			RdtTrack track = (RdtTrack) Track.getByClientAddress( (InetSocketAddress) session.getRemoteAddress() );
+            RdtTrack track = (RdtTrack) Track
+                    .getByClientAddress( (InetSocketAddress) session.getRemoteAddress() );
 
-			if ( track == null ) {
-				// drop packet
-				log.debug( &quot;Invalid address: &quot;
-						+ (InetSocketAddress) session.getRemoteAddress()
-						+ &quot; - Class: &quot;
-						+ ( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getClass() );
-				return;
-			}
+            if ( track == null ) {
+                // drop packet
+                log.debug( &quot;Invalid address: {} - Class: {}&quot;, session.getRemoteAddress(),
+                        ((InetSocketAddress) session.getRemoteAddress()).getAddress()
+                                .getClass() );
+                return;
+            }
 
-			track.forwardRdtToServer( rdtPacket );			
-		} else {
-			log.debug(&quot;invalid object passed: &quot; + buffer.getClass().getName());
-			
-			throw new IllegalStateException(&quot;invalid packet on chain&quot;);
-		}
-		
-	}
-	
-	@Override
-	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
-	{
-		log.info( &quot;Exception: &quot; + cause );
-		Exceptions.logStackTrace( cause );
-		session.close();
-	}
+            track.forwardRdtToServer( rdtPacket );
+        } else {
+            log.debug( &quot;invalid object passed: {}&quot;, buffer.getClass().getName() );
+
+            throw new IllegalStateException( &quot;invalid packet on chain&quot; );
+        }
+
+    }
+
+    @Override
+    public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
+    {
+        log.info( &quot;Exception: &quot; + cause );
+        Exceptions.logStackTrace( cause );
+        session.close();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -32,46 +32,50 @@
 import rtspproxy.rtp.rtcp.RtcpPacket;
 
 /**
- * Handles RTCP packets from client and forward them to server. The RTSP 
- * session is obtained using the client IP address and port.
+ * Handles RTCP packets from client and forward them to server. The RTSP session
+ * is obtained using the client IP address and port.
  * 
  * @author Matteo Merli
  */
 public class ClientRtcpPacketHandler extends IoHandlerAdapter
 {
 
-	private static Logger log = LoggerFactory.getLogger( ClientRtcpPacketHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ClientRtcpPacketHandler.class );
 
-	@Override
-	public void sessionCreated( IoSession session ) throws Exception
-	{
-	}
+    @Override
+    public void sessionCreated( IoSession session ) throws Exception
+    {
+    }
 
-	@Override
-	public void messageReceived( IoSession session, Object buffer ) throws Exception
-	{
-		RtcpPacket packet = new RtcpPacket( (ByteBuffer) buffer );
-		// log.debug( &quot;Received RTCP packet: &quot; + packet.getType() );
+    @Override
+    public void messageReceived( IoSession session, Object buffer ) throws Exception
+    {
+        RtcpPacket packet = new RtcpPacket( (ByteBuffer) buffer );
+        // log.debug( &quot;Received RTCP packet: {}&quot;, packet.getType() );
 
-		RtpTrack track = (RtpTrack)Track.getByClientAddress( (InetSocketAddress) session.getRemoteAddress() );
+        RtpTrack track = (RtpTrack) Track.getByClientAddress( (InetSocketAddress) session
+                .getRemoteAddress() );
 
-		if ( track == null ) {
-			// drop packet
-			log.debug( &quot;Invalid address: &quot;
-					+ (InetSocketAddress) session.getRemoteAddress()
-					+ &quot; - Class: &quot;
-					+ ( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getClass() );
-			return;
-		}
+        if ( track == null ) {
+            // drop packet
+            log.debug( &quot;Invalid address: {} - Class: {}&quot;, session.getRemoteAddress(),
+                    ((InetSocketAddress) session.getRemoteAddress()).getAddress()
+                            .getClass() );
+            
+            log.debug( &quot;Known Client Addresses: {}&quot;, Track.clientAddressMap.keySet() );
+            return;
+        }
 
-		track.forwardRtcpToServer( packet );
-	}
+        track.forwardRtcpToServer( packet );
+    }
 
-	@Override
-	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
-	{
-		log.debug( &quot;Exception: &quot; + cause );
-		Exceptions.logStackTrace( cause );
-		session.close();
-	}
+    @Override
+    public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
+    {
+        if ( log.isDebugEnabled() ) {
+            log.debug( &quot;Exception: &quot; + cause );
+            Exceptions.logStackTrace( cause );
+        }
+        session.close();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtpPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -52,13 +52,13 @@
 	public void messageReceived( IoSession session, Object buffer ) throws Exception
 	{
 		RtpPacket packet = new RtpPacket( (ByteBuffer) buffer );
-		log.debug( &quot;Received RTP packet: &quot; + packet.getSequence() );
+		log.debug( &quot;Received RTP packet: {}&quot;, packet.getSequence() );
 
 		RtpTrack track = (RtpTrack)Track.getByClientAddress( (InetSocketAddress) session.getRemoteAddress() );
 
 		if ( track == null ) {
 			// drop packet
-			log.debug( &quot;Packet received from unknown client: &quot; + session.getRemoteAddress() ); 
+			log.debug( &quot;Packet received from unknown client: {}&quot;, session.getRemoteAddress() ); 
 			return;
 		}
 
@@ -68,7 +68,7 @@
 	@Override
 	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
 	{
-		log.debug( &quot;Exception: &quot; + cause );
+		log.debug( &quot;Exception: {}&quot;, cause );
 		Exceptions.logStackTrace( cause );
 		session.close();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientSide.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientSide.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientSide.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -41,7 +41,7 @@
 	@Override
 	public void sessionCreated( IoSession session ) throws Exception
 	{
-		log.info( &quot;New connection from &quot; + session.getRemoteAddress() );
+		log.info( &quot;New connection from {}&quot;, session.getRemoteAddress() );
 		// Creates a new ProxyHandler and saves it
 		// as a Session attribute
 		ProxyHandler proxyHandler = new ProxyHandler( session );
@@ -68,7 +68,7 @@
 			return;
 		}
 		// close all: same as sessionClosed()
-		log.info( &quot;Exception: &quot; + cause );
+		log.info( &quot;Exception: {}&quot;, cause );
 		Exceptions.logStackTrace( cause );
 		sessionClosed( session );
 	}
@@ -219,7 +219,7 @@
 	public void messageReceived( IoSession session, Object message )
 	{
 		RtspMessage rtspMessage = (RtspMessage) message;
-		log.debug( &quot;Received message:\n&quot; + message );
+		log.debug( &quot;Received message:\n{}&quot;, message );
 
 		ProxyHandler proxyHandler = (ProxyHandler) ( session.getAttribute( ProxyHandler.ATTR ) );
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,13 +26,13 @@
 import java.net.UnknownHostException;
 import java.nio.channels.UnresolvedAddressException;
 import java.util.HashMap;
+import java.util.concurrent.ConcurrentHashMap;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.ConnectFuture;
 import org.apache.mina.common.IoSession;
 import org.apache.mina.transport.socket.nio.SocketConnector;
-import org.apache.mina.transport.socket.nio.SocketSession;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.RdtClientService;
 import rtspproxy.RdtServerService;
@@ -42,8 +42,6 @@
 import rtspproxy.RtpServerService;
 import rtspproxy.config.Config;
 import rtspproxy.filter.RtspServerFilters;
-import rtspproxy.lib.number.UnsignedInt;
-import rtspproxy.lib.number.UnsignedLong;
 import rtspproxy.proxy.track.RdtTrack;
 import rtspproxy.proxy.track.RtpTrack;
 import rtspproxy.rtp.range.PortrangeRtpServerSession;
@@ -58,558 +56,562 @@
 import rtspproxy.rtsp.RtspTransport.TransportProtocol;
 
 /**
- * @author mat
+ * @author Matteo Merli
  */
 public class ProxyHandler
 {
 
-	private static Logger log = LoggerFactory.getLogger( ProxyHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ProxyHandler.class );
 
-	/** Used to save a reference to this handler in the IoSession */
-	protected static final String ATTR = ProxyHandler.class.toString() + &quot;Attr&quot;;
+    /** Used to save a reference to this handler in the IoSession */
+    protected static final String ATTR = ProxyHandler.class.toString() + &quot;Attr&quot;;
 
-	protected static final String setupUrlATTR = ProxyHandler.class.toString()
-			+ &quot;setupUrlATTR&quot;;
+    protected static final String setupUrlATTR = ProxyHandler.class.toString()
+            + &quot;setupUrlATTR&quot;;
 
-	protected static final String clientPortsATTR = ProxyHandler.class.toString()
-			+ &quot;clientPortsATTR&quot;;
+    protected static final String clientPortsATTR = ProxyHandler.class.toString()
+            + &quot;clientPortsATTR&quot;;
 
-	protected static final String clientRdtPortATTR = ProxyHandler.class.toString()
-			+ &quot;clientRdtPortATTR&quot;;
+    protected static final String clientRdtPortATTR = ProxyHandler.class.toString()
+            + &quot;clientRdtPortATTR&quot;;
 
-	private IoSession clientSession = null;
+    private IoSession clientSession = null;
 
-	private IoSession serverSession = null;
+    private IoSession serverSession = null;
 
-	private HashMap&lt;String, Object&gt; sharedSessionObjects = new HashMap&lt;String, Object&gt;();
-	
-	/**
-	 * Creates a new ProxyHandler from a client side protocol session.
-	 * 
-	 * @param clientSession
-	 */
-	public ProxyHandler( IoSession clientSession )
-	{
-		this.clientSession = clientSession;
-		this.clientSession.setAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE, sharedSessionObjects);
-	}
+    private ConcurrentHashMap&lt;String, Object&gt; sharedSessionObjects = new ConcurrentHashMap&lt;String, Object&gt;();
 
-	public void passToServer( RtspMessage message )
-	{
-		log.debug( &quot;Pass to server&quot; );
-		if ( message.getHeader( &quot;Session&quot; ) != null ) {
-			ProxySession proxySession = ProxySession.getByClientSessionID( message
-					.getHeader( &quot;Session&quot; ) );
-			if ( proxySession != null ) {
-				// Session is Ok
-				message.setHeader( &quot;Session&quot;, proxySession.getServerSessionId() );
-			} else {
-				// Error. The client specified a session ID but it's
-				// not valid
-				sendResponse( clientSession, RtspResponse
-						.errorResponse( RtspCode.SessionNotFound ) );
-				return;
-			}
-		}
-		if ( serverSession == null &amp;&amp; message.getType() == RtspMessage.Type.TypeResponse ) {
-			log.error( &quot;We can't send a response message to an uninitialized serverSide&quot; );
-			return;
-		} else if ( serverSession == null ) {
-			RtspRequest request = (RtspRequest) message;
-			try {
-				connectServerSide( request.getUrl() );
+    /**
+     * Creates a new ProxyHandler from a client side protocol session.
+     * 
+     * @param clientSession
+     */
+    public ProxyHandler( IoSession clientSession )
+    {
+        this.clientSession = clientSession;
+        this.clientSession.setAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE,
+                sharedSessionObjects );
+    }
 
-			} catch ( IOException e ) {
-				log.error( &quot;I/O exception&quot;, e );
-				// closeAll();
-			} finally {
-				if ( serverSession == null )
-					return;
-			}
-		}
+    public void passToServer( RtspMessage message )
+    {
+        log.debug( &quot;Pass to server&quot; );
+        if ( message.getHeader( &quot;Session&quot; ) != null ) {
+            ProxySession proxySession = ProxySession.getByClientSessionID( message
+                    .getHeader( &quot;Session&quot; ) );
+            if ( proxySession != null ) {
+                // Session is Ok
+                message.setHeader( &quot;Session&quot;, proxySession.getServerSessionId() );
+            } else {
+                // Error. The client specified a session ID but it's
+                // not valid
+                sendResponse( clientSession, RtspResponse
+                        .errorResponse( RtspCode.SessionNotFound ) );
+                return;
+            }
+        }
+        if ( serverSession == null &amp;&amp; message.getType() == RtspMessage.Type.TypeResponse ) {
+            log.error( &quot;We can't send a response message to an uninitialized serverSide&quot; );
+            return;
+        } else if ( serverSession == null ) {
+            RtspRequest request = (RtspRequest) message;
+            try {
+                connectServerSide( request.getUrl() );
 
-		switch ( message.getType() ) {
-		case TypeRequest:
-			serverSession.setAttribute( RtspMessage.lastRequestVerbATTR,
-					((RtspRequest) message).getVerb() );
-			sendRequest( serverSession, (RtspRequest) message );
-			break;
+            } catch ( IOException e ) {
+                log.error( &quot;I/O exception&quot;, e );
+                // closeAll();
+            } finally {
+                if ( serverSession == null )
+                    return;
+            }
+        }
 
-		case TypeResponse:
-			sendResponse( serverSession, (RtspResponse) message );
-			break;
+        switch ( message.getType() )
+        {
+        case TypeRequest:
+            serverSession.setAttribute( RtspMessage.lastRequestVerbATTR,
+                    ((RtspRequest) message).getVerb() );
+            sendRequest( serverSession, (RtspRequest) message );
+            break;
 
-		default:
-			log.error( &quot;Message type not valid: &quot; + message.getType() );
-		}
-	}
+        case TypeResponse:
+            sendResponse( serverSession, (RtspResponse) message );
+            break;
 
-	public void passToClient( RtspMessage message )
-	{
-		log.debug( &quot;Pass to client&quot; );
-		if ( message.getHeader( &quot;Session&quot; ) != null ) {
-			ProxySession proxySession = ProxySession.getByServerSessionID( message
-					.getHeader( &quot;Session&quot; ) );
-			if ( proxySession != null ) {
-				// Session is Ok
-				message.setHeader( &quot;Session&quot;, proxySession.getClientSessionId() );
-			} else {
-				if ( message.getType() == RtspMessage.Type.TypeResponse ) {
-					// create a proxy session on the fly if message is a
-					// response. Certain mobile handset clients
-					// tend to start a RSTP session without its own session id
-					// and wait for the session object from the
-					// remote server
-					proxySession = new ProxySession();
+        default:
+            log.error( &quot;Message type not valid: &quot; + message.getType() );
+        }
+    }
 
-					proxySession.setServerSessionId( message.getHeader( &quot;Session&quot; ) );
-					message.setHeader( &quot;Session&quot;, proxySession.getClientSessionId() );
-					log.debug( &quot;Created a new proxy session on-the-fly.&quot; );
-				} else {
-					// Error. The client specified a session ID but it's
-					// not valid
-					sendResponse( clientSession, RtspResponse
-							.errorResponse( RtspCode.SessionNotFound ) );
-					return;
-				}
-			}
-		}
+    public void passToClient( RtspMessage message )
+    {
+        log.debug( &quot;Pass to client&quot; );
+        if ( message.getHeader( &quot;Session&quot; ) != null ) {
+            ProxySession proxySession = ProxySession.getByServerSessionID( message
+                    .getHeader( &quot;Session&quot; ) );
+            if ( proxySession != null ) {
+                // Session is Ok
+                message.setHeader( &quot;Session&quot;, proxySession.getClientSessionId() );
+            } else {
+                if ( message.getType() == RtspMessage.Type.TypeResponse ) {
+                    // create a proxy session on the fly if message is a
+                    // response. Certain mobile handset clients
+                    // tend to start a RSTP session without its own session id
+                    // and wait for the session object from the
+                    // remote server
+                    proxySession = new ProxySession();
 
-		switch ( message.getType() ) {
-		case TypeRequest:
-			clientSession.setAttribute( RtspMessage.lastRequestVerbATTR,
-					((RtspRequest) message).getVerb() );
-			sendRequest( clientSession, (RtspRequest) message );
-			break;
+                    proxySession.setServerSessionId( message.getHeader( &quot;Session&quot; ) );
+                    message.setHeader( &quot;Session&quot;, proxySession.getClientSessionId() );
+                    log.debug( &quot;Created a new proxy session on-the-fly.&quot; );
+                } else {
+                    // Error. The client specified a session ID but it's
+                    // not valid
+                    sendResponse( clientSession, RtspResponse
+                            .errorResponse( RtspCode.SessionNotFound ) );
+                    return;
+                }
+            }
+        }
 
-		case TypeResponse:
-			sendResponse( clientSession, (RtspResponse) message );
-			break;
+        switch ( message.getType() )
+        {
+        case TypeRequest:
+            clientSession.setAttribute( RtspMessage.lastRequestVerbATTR,
+                    ((RtspRequest) message).getVerb() );
+            sendRequest( clientSession, (RtspRequest) message );
+            break;
 
-		default:
-			log.error( &quot;Message type not valid: &quot; + message.getType() );
-		}
-	}
+        case TypeResponse:
+            sendResponse( clientSession, (RtspResponse) message );
+            break;
 
-	/**
-	 * A SETUP request should treated more carefully tha other RTSP requests.
-	 * The proxy will perform some hijacking on the communication between client
-	 * and server, such as modifying RTP/RTCP port.
-	 * 
-	 * @param request
-	 *            SETUP request message
-	 */
-	public void passSetupRequestToServer( RtspRequest request )
-	{
-		ProxySession proxySession = null;
-		PortrangeRtpServerSession portrangeRtpSession = null;
+        default:
+            log.error( &quot;Message type not valid: &quot; + message.getType() );
+        }
+    }
 
-		if ( request.getHeader( &quot;Session&quot; ) != null ) {
-			// The client already specified a session ID.
-			// Let's validate it
-			proxySession = ProxySession.getByClientSessionID( request
-					.getHeader( &quot;Session&quot; ) );
-			if ( proxySession != null ) {
-				// Session ID is ok
-				request.setHeader( &quot;Session&quot;, proxySession.getServerSessionId() );
-			} else {
-				// Error. The client specified a session ID but it's
-				// not valid
-				log.debug( &quot;Invalid sessionId: &quot; + request.getHeader( &quot;Session&quot; ) );
-				sendResponse( clientSession, RtspResponse
-						.errorResponse( RtspCode.SessionNotFound ) );
-				return;
-			}
-		}
-		
-		if(serverSession == null) {
-			/**
-			 * A mobile handset client may start the RTSP dialogue directly with a 
-			 * SETUP request if it has discovered the streaming media characteristics
-			 * through any other mechanism.
-			 * --&gt; Make sure a server-side session exists in this case.
-			 */
-			try {
-				connectServerSide( request.getUrl() );
-			} catch ( IOException e ) {
-				log.error( &quot;I/O exception&quot;, e );
-				// closeAll();
-			} finally {
-				if ( serverSession == null )
-					return;
-			}
-		}
-		serverSession.setAttribute( RtspMessage.lastRequestVerbATTR, request.getVerb() );
+    /**
+     * A SETUP request should treated more carefully tha other RTSP requests.
+     * The proxy will perform some hijacking on the communication between client
+     * and server, such as modifying RTP/RTCP port.
+     * 
+     * @param request
+     *            SETUP request message
+     */
+    public void passSetupRequestToServer( RtspRequest request )
+    {
+        ProxySession proxySession = null;
+        PortrangeRtpServerSession portrangeRtpSession = null;
 
-		log.debug( &quot;Client Transport:&quot; + request.getHeader( &quot;Transport&quot; ) );
+        if ( request.getHeader( &quot;Session&quot; ) != null ) {
+            // The client already specified a session ID.
+            // Let's validate it
+            proxySession = ProxySession.getByClientSessionID( request
+                    .getHeader( &quot;Session&quot; ) );
+            if ( proxySession != null ) {
+                // Session ID is ok
+                request.setHeader( &quot;Session&quot;, proxySession.getServerSessionId() );
+            } else {
+                // Error. The client specified a session ID but it's
+                // not valid
+                log.debug( &quot;Invalid sessionId: {}&quot;, request.getHeader( &quot;Session&quot; ) );
+                sendResponse( clientSession, RtspResponse
+                        .errorResponse( RtspCode.SessionNotFound ) );
+                return;
+            }
+        }
 
-		RtspTransportList rtspTransportList = new RtspTransportList( request
-				.getHeader( &quot;Transport&quot; ) );
-		log.debug( &quot;Parsed:&quot; + rtspTransportList.toString() );
+        if ( serverSession == null ) {
+            /**
+             * A mobile handset client may start the RTSP dialogue directly with
+             * a SETUP request if it has discovered the streaming media
+             * characteristics through any other mechanism. --&gt; Make sure a
+             * server-side session exists in this case.
+             */
+            try {
+                connectServerSide( request.getUrl() );
+            } catch ( IOException e ) {
+                log.error( &quot;I/O exception&quot;, e );
+                // closeAll();
+            } finally {
+                if ( serverSession == null )
+                    return;
+            }
+        }
+        serverSession.setAttribute( RtspMessage.lastRequestVerbATTR, request.getVerb() );
 
-		if ( rtspTransportList.count() == 0 ) {
-			/**
-			 * If no one of the client specified transports is acceptable by the
-			 * proxy, direct reply with an unsupported transport error. Then the
-			 * client will have the chance to reformule the request with another
-			 * transports set.
-			 */
-			sendResponse( clientSession, RtspResponse
-					.errorResponse( RtspCode.UnsupportedTransport ) );
-			return;
-		}
+        log.debug( &quot;Client Transport:{}&quot;, request.getHeader( &quot;Transport&quot; ) );
 
-		// I'm saving the client Transport header before modifying it,
-		// because I will need to know which port the client will
-		// use for RTP/RTCP connections.
-		clientSession.setAttribute( setupUrlATTR, request.getUrl().toString() );
+        RtspTransportList rtspTransportList = new RtspTransportList( request
+                .getHeader( &quot;Transport&quot; ) );
+        log.debug( &quot;Parsed: {}&quot;, rtspTransportList );
 
-		for ( RtspTransport transport : rtspTransportList.getList() ) {
-			log.debug( &quot;Transport:&quot; + transport );
+        if ( rtspTransportList.count() == 0 ) {
+            /**
+             * If no one of the client specified transports is acceptable by the
+             * proxy, direct reply with an unsupported transport error. Then the
+             * client will have the chance to reformule the request with another
+             * transports set.
+             */
+            sendResponse( clientSession, RtspResponse
+                    .errorResponse( RtspCode.UnsupportedTransport ) );
+            return;
+        }
 
-			if ( transport.getLowerTransport() == LowerTransport.TCP ) {
-				log.debug( &quot;Transport is TCP based.&quot; );
-			} else {
-				if ( transport.getTransportProtocol() == TransportProtocol.RTP ) {
+        // I'm saving the client Transport header before modifying it,
+        // because I will need to know which port the client will
+        // use for RTP/RTCP connections.
+        clientSession.setAttribute( setupUrlATTR, request.getUrl().toString() );
 
-					clientSession.setAttribute( clientPortsATTR, transport
-							.getClientPort() );
-					
-					int proxyRtpPort = RtpServerService.getInstance().getPort();
-					int proxyRtcpPort = RtcpServerService.getInstance().getPort();
-					
-					if(Config.proxyServerRtpMultiplePorts.getValue()) {
-						log.debug(&quot;using RTP port range&quot;);
-						
-						try {
-							portrangeRtpSession = PortrangeRtpServerSessionFactory.getInstance().getSession();
-							
-							proxyRtpPort = portrangeRtpSession.getRtpPort();
-							proxyRtcpPort = portrangeRtpSession.getRtcpPort();
-							
-							log.debug(&quot;setting local server RTP/RTCP ports to &quot;	+ proxyRtpPort + &quot;/&quot; + proxyRtcpPort);
-						} catch(IOException ioe) {
-							log.info(&quot;failed to allocate local RTP/RTCP ports&quot;, ioe);
-							
-							sendResponse( clientSession, RtspResponse
-									.errorResponse( RtspCode.InternalServerError ) );
-							return;
-						}
-					}
-					transport.setClientPort( new int[] { proxyRtpPort, proxyRtcpPort } );
+        for ( RtspTransport transport : rtspTransportList.getList() ) {
+            log.debug( &quot;Transport: {}&quot;, transport );
 
-					// offer a distinguished SSRC to the remote server
-					if(Config.proxyRtspOfferSsrcToServer.getValue()) {
-						String ssrc = ProxySession.newServerSessionID().toHexString();
-						log.debug(&quot;offering generated SSRC to remote server, ssrc=&quot; + ssrc);
-						
-						transport.setSSRC(ssrc);
-					}
-					
-				} else if ( transport.getTransportProtocol() == TransportProtocol.RDT ) {
-					clientSession.setAttribute( clientRdtPortATTR, new Integer( transport
-							.getClientPort()[0] ) );
-					
-					int proxyRdtPort = RdtServerService.getInstance().getPort();
-					transport.setClientPort( proxyRdtPort );
-				}
-				log.debug( &quot;Transport Rewritten: &quot; + transport );
-			}
-		}
+            if ( transport.getLowerTransport() == LowerTransport.TCP ) {
+                log.debug( &quot;Transport is TCP based.&quot; );
+            } else {
+                if ( transport.getTransportProtocol() == TransportProtocol.RTP ) {
 
-		if ( proxySession == null ) {
-			proxySession = new ProxySession();
-			clientSession.setAttribute( ProxySession.ATTR, proxySession );
-		}
-		if(portrangeRtpSession != null)
-			proxySession.setPortrangeRtpServerSession(portrangeRtpSession);
+                    clientSession.setAttribute( clientPortsATTR, transport
+                            .getClientPort() );
 
-		request.setHeader( &quot;Transport&quot;, rtspTransportList.toString() );
+                    int proxyRtpPort = RtpServerService.getInstance().getPort();
+                    int proxyRtcpPort = RtcpServerService.getInstance().getPort();
 
-		log.debug( &quot;Sending SETUP request: \n&quot; + request );
+                    if ( Config.proxyServerRtpMultiplePorts.getValue() ) {
+                        log.debug( &quot;using RTP port range&quot; );
 
-		sendRequest( serverSession, request );
-	}
+                        try {
+                            portrangeRtpSession = PortrangeRtpServerSessionFactory
+                                    .getInstance().getSession();
 
-	/**
-	 * Forward a RTSP SETUP response message to client.
-	 * 
-	 * @param response
-	 *            Setup response message
-	 */
-	public void passSetupResponseToClient( RtspResponse response )
-	{
-		// If there isn't yet a proxySession, create a new one
-		ProxySession proxySession = ProxySession.getByServerSessionID( response
-				.getHeader( &quot;Session&quot; ) );
-		if ( proxySession == null ) {
-			proxySession = (ProxySession) clientSession.getAttribute( ProxySession.ATTR );
-			if ( proxySession == null ) {
-				proxySession = new ProxySession();
-				clientSession.setAttribute( ProxySession.ATTR, proxySession );
-			}
-		}
+                            proxyRtpPort = portrangeRtpSession.getRtpPort();
+                            proxyRtcpPort = portrangeRtpSession.getRtcpPort();
 
-		if ( proxySession.getServerSessionId() == null ) {
-			proxySession.setServerSessionId( response.getHeader( &quot;Session&quot; ) );
-		}
-		
-		// Modify transport parameters for the client.
-		RtspTransportList rtspTransportList = new RtspTransportList( response
-				.getHeader( &quot;Transport&quot; ) );
+                            log.debug( &quot;setting local server RTP/RTCP ports to {}/{}&quot;,
+                                    proxyRtpPort, proxyRtcpPort );
+                        } catch ( IOException ioe ) {
+                            log.info( &quot;failed to allocate local RTP/RTCP ports&quot;, ioe );
 
-		RtspTransport transport = rtspTransportList.getList().get( 0 );
-		log.debug( &quot;Using Transport:&quot; + transport );
+                            sendResponse( clientSession, RtspResponse
+                                    .errorResponse( RtspCode.InternalServerError ) );
+                            return;
+                        }
+                    }
+                    transport.setClientPort( new int[] { proxyRtpPort, proxyRtcpPort } );
 
-		if ( transport.getTransportProtocol() == TransportProtocol.RTP ) {
+                    // offer a distinguished SSRC to the remote server
+                    if ( Config.proxyRtspOfferSsrcToServer.getValue() ) {
+                        String ssrc = ProxySession.newServerSessionID().toHexString();
+                        log.debug( &quot;offering generated SSRC to remote server, ssrc={}&quot;,
+                                ssrc );
 
-			// Create a new Track object
-			RtpTrack track = proxySession.addRtpTrack( (String) clientSession
-					.getAttribute( setupUrlATTR ), transport.getSSRC() );
+                        transport.setSSRC( ssrc );
+                    }
 
-			// Setting client and server info on the track
-			InetAddress serverAddress = null;
-			if ( transport.getSource() != null ) {
-				try {
-					serverAddress = InetAddress.getByName( transport.getSource() );
-				} catch ( UnknownHostException e ) {
-					log.warn( &quot;Unknown host: &quot; + transport.getSource() );
-				}
-			} else {
-				serverAddress = ((InetSocketAddress) serverSession.getRemoteAddress())
-						.getAddress();
-			}
-			int[] serverPorts = transport.getServerPort();
-			track.setServerAddress( serverAddress, serverPorts[0], serverPorts[1] );
+                } else if ( transport.getTransportProtocol() == TransportProtocol.RDT ) {
+                    clientSession.setAttribute( clientRdtPortATTR, new Integer( transport
+                            .getClientPort()[0] ) );
 
-			InetAddress clientAddress = null;
-			try {
-				clientAddress = Inet4Address
-						.getByName( ((InetSocketAddress) clientSession.getRemoteAddress())
-								.getHostName() );
-			} catch ( UnknownHostException e ) {
-				log.warn( &quot;Unknown host: &quot; + clientSession.getRemoteAddress() );
-			}
-			int clientPorts[] = (int[]) clientSession.getAttribute( clientPortsATTR );
-			track.setClientAddress( clientAddress, clientPorts[0], clientPorts[1] );
+                    int proxyRdtPort = RdtServerService.getInstance().getPort();
+                    transport.setClientPort( proxyRdtPort );
+                }
+                log.debug( &quot;Transport Rewritten: {}&quot;, transport );
+            }
+        }
 
-			if ( transport.getLowerTransport() == RtspTransport.LowerTransport.TCP ) {
-				log.debug( &quot;Transport is TCP based.&quot; );
-			} else {
-				transport.setSSRC( track.getProxySSRC().toHexString() );
-				int rtpPort = RtpClientService.getInstance().getPort();
-				int rtcpPort = RtcpClientService.getInstance().getPort();
-				transport.setServerPort( new int[] { rtpPort, rtcpPort } );
-				transport.setSource( RtpClientService.getInstance().getAddress().getHostAddress() );
+        if ( proxySession == null ) {
+            proxySession = new ProxySession();
+            clientSession.setAttribute( ProxySession.ATTR, proxySession );
+        }
+        if ( portrangeRtpSession != null )
+            proxySession.setPortrangeRtpServerSession( portrangeRtpSession );
 
-				// Obtaing client specified ports
-				int ports[] = (int[]) clientSession.getAttribute( clientPortsATTR );
-				transport.setClientPort( ports );
+        request.setHeader( &quot;Transport&quot;, rtspTransportList.toString() );
 
-				log.debug( &quot;Transport Rewritten: &quot; + transport );
-			}
+        log.debug( &quot;Sending SETUP request: \n{}&quot;, request );
 
-		} else if ( transport.getTransportProtocol() == TransportProtocol.RDT ) {
+        sendRequest( serverSession, request );
+    }
 
-			// Create a new Track object
-			RdtTrack track = proxySession.addRdtTrack( (String) clientSession
-					.getAttribute( setupUrlATTR ) );
-			// Setting client and server info on the track
-			InetAddress serverAddress = null;
-			if ( transport.getSource() != null ) {
-				try {
-					serverAddress = InetAddress.getByName( transport.getSource() );
-				} catch ( UnknownHostException e ) {
-					log.warn( &quot;Unknown host: &quot; + transport.getSource() );
-				}
-			} else {
-				serverAddress = ((InetSocketAddress) serverSession.getRemoteAddress())
-						.getAddress();
-			}
-			int[] serverPorts = transport.getServerPort();
-			track.setServerAddress( serverAddress, serverPorts[0] );
+    /**
+     * Forward a RTSP SETUP response message to client.
+     * 
+     * @param response
+     *            Setup response message
+     */
+    public void passSetupResponseToClient( RtspResponse response )
+    {
+        // If there isn't yet a proxySession, create a new one
+        ProxySession proxySession = ProxySession.getByServerSessionID( response
+                .getHeader( &quot;Session&quot; ) );
+        if ( proxySession == null ) {
+            proxySession = (ProxySession) clientSession.getAttribute( ProxySession.ATTR );
+            if ( proxySession == null ) {
+                proxySession = new ProxySession();
+                clientSession.setAttribute( ProxySession.ATTR, proxySession );
+            }
+        }
 
-			InetAddress clientAddress = null;
-			try {
-				clientAddress = Inet4Address
-						.getByName( ((InetSocketAddress) clientSession.getRemoteAddress())
-								.getHostName() );
-			} catch ( UnknownHostException e ) {
-				log.warn( &quot;Unknown host: &quot; + clientSession.getRemoteAddress() );
-			}
-			int clientRdtPort = ((Integer) clientSession.getAttribute( clientRdtPortATTR ))
-					.intValue();
-			track.setClientAddress( clientAddress, clientRdtPort );
+        if ( proxySession.getServerSessionId() == null ) {
+            proxySession.setServerSessionId( response.getHeader( &quot;Session&quot; ) );
+        }
 
-			if ( transport.getLowerTransport() == RtspTransport.LowerTransport.TCP ) {
-				log.debug( &quot;Transport is TCP based.&quot; );
-			} else {
-				int rdtPort = RdtClientService.getInstance().getPort();
-				transport.setServerPort( rdtPort );
-				// transport.setSource( RdtClientService.getInstance().getAddress().getHostAddress() );
+        // Modify transport parameters for the client.
+        RtspTransportList rtspTransportList = new RtspTransportList( response
+                .getHeader( &quot;Transport&quot; ) );
 
-				// Obtaing client specified ports
-				int port = ((Integer) clientSession.getAttribute( clientRdtPortATTR ))
-						.intValue();
-				transport.setClientPort( port );
+        RtspTransport transport = rtspTransportList.getList().get( 0 );
+        log.debug( &quot;Using Transport: {}&quot;, transport );
 
-				log.debug( &quot;Transport Rewritten: &quot; + transport );
-			}
+        if ( transport.getTransportProtocol() == TransportProtocol.RTP ) {
 
-		} else {
-			sendResponse( clientSession, RtspResponse
-					.errorResponse( RtspCode.UnsupportedTransport ) );
-			return;
-		}
+            // Create a new Track object
+            RtpTrack track = proxySession.addRtpTrack( (String) clientSession
+                    .getAttribute( setupUrlATTR ), transport.getSSRC() );
 
-		response.setHeader( &quot;Session&quot;, proxySession.getClientSessionId() );
-		response.setHeader( &quot;Transport&quot;, transport.toString() );
+            // Setting client and server info on the track
+            InetAddress serverAddress = null;
+            if ( transport.getSource() != null ) {
+                try {
+                    serverAddress = InetAddress.getByName( transport.getSource() );
+                } catch ( UnknownHostException e ) {
+                    log.warn( &quot;Unknown host: &quot; + transport.getSource() );
+                }
+            } else {
+                serverAddress = ((InetSocketAddress) serverSession.getRemoteAddress())
+                        .getAddress();
+            }
+            int[] serverPorts = transport.getServerPort();
+            track.setServerAddress( serverAddress, serverPorts[0], serverPorts[1] );
 
-		log.debug( &quot;SENDING RESPONSE TO CLIENT:\n&quot; + response );
+            InetAddress clientAddress = null;
+            try {
+                clientAddress = Inet4Address
+                        .getByName( ((InetSocketAddress) clientSession.getRemoteAddress())
+                                .getHostName() );
+            } catch ( UnknownHostException e ) {
+                log.warn( &quot;Unknown host: &quot; + clientSession.getRemoteAddress() );
+            }
+            int clientPorts[] = (int[]) clientSession.getAttribute( clientPortsATTR );
+            track.setClientAddress( clientAddress, clientPorts[0], clientPorts[1] );
 
-		sendResponse( clientSession, response );
-	}
+            if ( transport.getLowerTransport() == RtspTransport.LowerTransport.TCP ) {
+                log.debug( &quot;Transport is TCP based.&quot; );
+            } else {
+                transport.setSSRC( track.getProxySSRC().toHexString() );
+                int rtpPort = RtpClientService.getInstance().getPort();
+                int rtcpPort = RtcpClientService.getInstance().getPort();
+                transport.setServerPort( new int[] { rtpPort, rtcpPort } );
+                transport.setSource( RtpClientService.getInstance().getAddress()
+                        .getHostAddress() );
 
-	/**
-	 * Tries to connect to remote RTSP server.
-	 * 
-	 * @param url
-	 *            the URI of the server
-	 * @throws IOException
-	 */
-	private void connectServerSide( URL url ) throws IOException
-	{
-		log.debug( &quot;Server url: &quot; + url );
-		String host = url.getHost();
-		int port = url.getPort();
-		if ( port == -1 )
-			port = url.getDefaultPort();
+                // Obtaing client specified ports
+                int ports[] = (int[]) clientSession.getAttribute( clientPortsATTR );
+                transport.setClientPort( ports );
 
-		// Create TCP/IP connector.
-		SocketConnector connector = new SocketConnector();
+                log.debug( &quot;Transport Rewritten: {}&quot;, transport );
+            }
 
-		// Start communication.
-		log.debug( &quot;Trying to connect to '&quot; + host + &quot;' &quot; + port );
-		try {
+        } else if ( transport.getTransportProtocol() == TransportProtocol.RDT ) {
 
-			/*
-			 * TODO: Current implementation wait (future.join()) until the
-			 * connection with server is completed. This could block the thread
-			 * for a long time. Check how to do it in asyncronous way.
-			 */
-			ConnectFuture future = connector.connect(
-					new InetSocketAddress( host, port ), new ServerSide(),
-					new RtspServerFilters() );
-			future.join();
-			serverSession = future.getSession();
+            // Create a new Track object
+            RdtTrack track = proxySession.addRdtTrack( (String) clientSession
+                    .getAttribute( setupUrlATTR ) );
+            // Setting client and server info on the track
+            InetAddress serverAddress = null;
+            if ( transport.getSource() != null ) {
+                try {
+                    serverAddress = InetAddress.getByName( transport.getSource() );
+                } catch ( UnknownHostException e ) {
+                    log.warn( &quot;Unknown host: &quot; + transport.getSource() );
+                }
+            } else {
+                serverAddress = ((InetSocketAddress) serverSession.getRemoteAddress())
+                        .getAddress();
+            }
+            int[] serverPorts = transport.getServerPort();
+            track.setServerAddress( serverAddress, serverPorts[0] );
 
-			if(Config.proxyRtspKeepAlive.getValue())
-				((SocketSession)serverSession).setKeepAlive(true);
-		} catch ( UnresolvedAddressException e ) {
-			log.warn( &quot;Destination unreachable: &quot; + host + &quot;:&quot; + port );
-			sendResponse( clientSession, RtspResponse
-					.errorResponse( RtspCode.DestinationUnreachable ) );
-			clientSession.close();
-			return;
-		}
+            InetAddress clientAddress = null;
+            try {
+                clientAddress = Inet4Address
+                        .getByName( ((InetSocketAddress) clientSession.getRemoteAddress())
+                                .getHostName() );
+            } catch ( UnknownHostException e ) {
+                log.warn( &quot;Unknown host: &quot; + clientSession.getRemoteAddress() );
+            }
+            int clientRdtPort = ((Integer) clientSession.getAttribute( clientRdtPortATTR ))
+                    .intValue();
+            track.setClientAddress( clientAddress, clientRdtPort );
 
-		log.debug( &quot;Connected!&quot; );
+            if ( transport.getLowerTransport() == RtspTransport.LowerTransport.TCP ) {
+                log.debug( &quot;Transport is TCP based.&quot; );
+            } else {
+                int rdtPort = RdtClientService.getInstance().getPort();
+                transport.setServerPort( rdtPort );
+                // transport.setSource(
+                // RdtClientService.getInstance().getAddress().getHostAddress()
+                // );
 
-		// Save current ProxyHandler into the ProtocolSession
-		serverSession.setAttribute( ProxyHandler.ATTR, this );
+                // Obtaing client specified ports
+                int port = ((Integer) clientSession.getAttribute( clientRdtPortATTR ))
+                        .intValue();
+                transport.setClientPort( port );
 
-		serverSession.setAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE, sharedSessionObjects);
-		
-		log.debug( &quot;Server session: &quot; + serverSession.getAttributeKeys() );
-	}
+                log.debug( &quot;Transport Rewritten: {}&quot;, transport );
+            }
 
-	/**
-	 * set an object in the shared objects map
-	 */
-	public static void setSharedSessionAttribute(IoSession session, String name, Object value) {
-		HashMap&lt;String, Object&gt; map = (HashMap&lt;String, Object&gt;)session.getAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE);
-		
-		synchronized (map) {
-			map.put(name, value);
-		}
-	}
-	
-	public static Object getSharedSessionAttribute(IoSession session, String name) {
-		Object v = null;
-		HashMap&lt;String, Object&gt; map = (HashMap&lt;String, Object&gt;)session.getAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE);
-		
-		synchronized (map) {
-			v = map.get(name);
-		}
-		
-		return v;
-	}
-	
-	public static final boolean containsSharedSessionAttribute(IoSession session, String name) {
-		boolean v = false;
-		HashMap&lt;String, Object&gt; map = (HashMap&lt;String, Object&gt;)session.getAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE);
-		
-		synchronized (map) {
-			v = map.containsKey(name);
-		}
-		
-		return v;
-		
-	}
-	
-	/**
-	 * Closes both sides of communication.
-	 */
-	public synchronized void closeAll()
-	{
-		if ( clientSession != null &amp;&amp; clientSession.isConnected() )
-			clientSession.close();
-		if ( serverSession != null &amp;&amp; serverSession.isConnected() )
-			serverSession.close();
+        } else {
+            sendResponse( clientSession, RtspResponse
+                    .errorResponse( RtspCode.UnsupportedTransport ) );
+            return;
+        }
 
-		// Remove ProxySession and Track instances
-		if ( clientSession != null ) {
-			ProxySession proxySession = (ProxySession) clientSession
-					.getAttribute( ProxySession.ATTR );
-			if ( proxySession != null )
-				proxySession.close();
-		}
-	}
+        response.setHeader( &quot;Session&quot;, proxySession.getClientSessionId() );
+        response.setHeader( &quot;Transport&quot;, transport.toString() );
 
-	/**
-	 * Sends an RTSP request message
-	 * 
-	 * @param session
-	 *            current IoSession
-	 * @param request
-	 *            the message
-	 */
-	private void sendRequest( IoSession session, RtspRequest request )
-	{
-		request.setCommonHeaders();
-		try {
-			session.write( request );
-		} catch ( Exception e ) {
-			log.error( &quot;exception sending request&quot;, e.getCause() );
-		}
-	}
+        log.debug( &quot;SENDING RESPONSE TO CLIENT:\n{}&quot;, response );
 
-	/**
-	 * Sends an RTSP response message
-	 * 
-	 * @param session
-	 *            current IoSession
-	 * @param response
-	 *            the message
-	 */
-	private void sendResponse( IoSession session, RtspResponse response )
-	{
-		response.setCommonHeaders();
-		try {
-			session.write( response );
-		} catch ( Exception e ) {
-			log.error( &quot;exception sending response&quot;, e.getCause() );
-		}
-	}
+        sendResponse( clientSession, response );
+    }
 
+    /**
+     * Tries to connect to remote RTSP server.
+     * 
+     * @param url
+     *            the URI of the server
+     * @throws IOException
+     */
+    private void connectServerSide( URL url ) throws IOException
+    {
+        log.debug( &quot;Server url: {}&quot;, url );
+        String host = url.getHost();
+        int port = url.getPort();
+        if ( port == -1 )
+            port = url.getDefaultPort();
+
+        // Create TCP/IP connector.
+        SocketConnector connector = new SocketConnector();
+        connector.setFilterChainBuilder( new RtspServerFilters() );
+
+        // Start communication.
+        log.debug( &quot;Trying to connect to '{}' {}&quot;, host, port );
+        try {
+
+            /*
+             * TODO: Current implementation wait (future.join()) until the
+             * connection with server is completed. This could block the thread
+             * for a long time. Check how to do it in asyncronous way.
+             */
+            ConnectFuture future = connector.connect(
+                    new InetSocketAddress( host, port ), new ServerSide() );
+            future.join();
+            serverSession = future.getSession();
+
+            // TODO: Rtsp Keep Alive
+            // if (Config.proxyRtspKeepAlive.getValue())
+            // ((SocketSession) serverSession).setKeepAlive(true);
+        } catch ( UnresolvedAddressException e ) {
+            log.warn( &quot;Destination unreachable: &quot; + host + &quot;:&quot; + port );
+            sendResponse( clientSession, RtspResponse
+                    .errorResponse( RtspCode.DestinationUnreachable ) );
+            clientSession.close();
+            return;
+        }
+
+        log.debug( &quot;Connected!&quot; );
+
+        // Save current ProxyHandler into the ProtocolSession
+        serverSession.setAttribute( ProxyHandler.ATTR, this );
+
+        serverSession.setAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE,
+                sharedSessionObjects );
+
+        log.debug( &quot;Server session: {}&quot;, serverSession.getAttributeKeys() );
+    }
+
+    /**
+     * set an object in the shared objects map
+     */
+    public static void setSharedSessionAttribute( IoSession session, String name,
+            Object value )
+    {
+        ConcurrentHashMap map = (ConcurrentHashMap) session
+                .getAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE );
+
+        map.put( name, value );
+    }
+
+    public static Object getSharedSessionAttribute( IoSession session, String name )
+    {
+        ConcurrentHashMap map = (ConcurrentHashMap) session
+                .getAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE );
+        return map.get( name );
+    }
+
+    public static final boolean containsSharedSessionAttribute( IoSession session,
+            String name )
+    {
+        HashMap map = (HashMap) session
+                .getAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE );
+        return map.containsKey( name );
+    }
+
+    /**
+     * Closes both sides of communication.
+     */
+    public synchronized void closeAll()
+    {
+        if ( clientSession != null &amp;&amp; clientSession.isConnected() )
+            clientSession.close();
+        if ( serverSession != null &amp;&amp; serverSession.isConnected() )
+            serverSession.close();
+
+        // Remove ProxySession and Track instances
+        if ( clientSession != null ) {
+            ProxySession proxySession = (ProxySession) clientSession
+                    .getAttribute( ProxySession.ATTR );
+            if ( proxySession != null )
+                proxySession.close();
+        }
+    }
+
+    /**
+     * Sends an RTSP request message
+     * 
+     * @param session
+     *            current IoSession
+     * @param request
+     *            the message
+     */
+    private void sendRequest( IoSession session, RtspRequest request )
+    {
+        request.setCommonHeaders();
+        try {
+            session.write( request );
+        } catch ( Exception e ) {
+            log.error( &quot;exception sending request&quot;, e.getCause() );
+        }
+    }
+
+    /**
+     * Sends an RTSP response message
+     * 
+     * @param session
+     *            current IoSession
+     * @param response
+     *            the message
+     */
+    private void sendResponse( IoSession session, RtspResponse response )
+    {
+        response.setCommonHeaders();
+        try {
+            session.write( response );
+        } catch ( Exception e ) {
+            log.error( &quot;exception sending response&quot;, e.getCause() );
+        }
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxySession.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxySession.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxySession.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -44,296 +44,305 @@
 public class ProxySession
 {
 
-	private static Logger log = LoggerFactory.getLogger( ProxySession.class );
+    private static Logger log = LoggerFactory.getLogger( ProxySession.class );
 
-	protected static final String ATTR = ProxySession.class.toString() + &quot;Attr&quot;;
+    protected static final String ATTR = ProxySession.class.toString() + &quot;Attr&quot;;
 
-	/** Map IDs for RTSP session with servers to ProxySession objects. */
-	private static Map&lt;String, ProxySession&gt; serverSessionIds = new ConcurrentHashMap&lt;String, ProxySession&gt;();
+    /** Map IDs for RTSP session with servers to ProxySession objects. */
+    private static Map&lt;String, ProxySession&gt; serverSessionIds = new ConcurrentHashMap&lt;String, ProxySession&gt;();
 
-	/** Map IDs for RTSP session with clients to ProxySession objects. */
-	private static Map&lt;String, ProxySession&gt; clientSessionIds = new ConcurrentHashMap&lt;String, ProxySession&gt;();
+    /** Map IDs for RTSP session with clients to ProxySession objects. */
+    private static Map&lt;String, ProxySession&gt; clientSessionIds = new ConcurrentHashMap&lt;String, ProxySession&gt;();
 
-	/**
-	 * Retrieve the ProxySession associated with the given session ID used by
-	 * the client.
-	 * 
-	 * @param clientSessionId
-	 *        a string containing the RTSP session ID
-	 * @return the associated ProxySession or null if not found
-	 */
-	public static ProxySession getByClientSessionID( String clientSessionId )
-	{
-		if ( clientSessionId == null )
-			return null;
-		else
-			return clientSessionIds.get( clientSessionId );
-	}
+    /**
+     * Retrieve the ProxySession associated with the given session ID used by
+     * the client.
+     * 
+     * @param clientSessionId
+     *            a string containing the RTSP session ID
+     * @return the associated ProxySession or null if not found
+     */
+    public static ProxySession getByClientSessionID( String clientSessionId )
+    {
+        if ( clientSessionId == null )
+            return null;
 
-	/**
-	 * Retrieve the ProxySession associated with the given session ID used by
-	 * the server.
-	 * 
-	 * @param serverSessionId
-	 *        a string containing the RTSP session ID
-	 * @return the associated ProxySession or null if not found
-	 */
-	public static ProxySession getByServerSessionID( String serverSessionId )
-	{
-		if ( serverSessionId == null )
-			return null;
-		else
-			return serverSessionIds.get( serverSessionId );
-	}
+        return clientSessionIds.get( clientSessionId );
+    }
 
-	/**
-	 * This is the session ID generated by the proxy and used for the
-	 * communication with the client.
-	 */
-	private String clientSessionId = null;
+    /**
+     * Retrieve the ProxySession associated with the given session ID used by
+     * the server.
+     * 
+     * @param serverSessionId
+     *            a string containing the RTSP session ID
+     * @return the associated ProxySession or null if not found
+     */
+    public static ProxySession getByServerSessionID( String serverSessionId )
+    {
+        if ( serverSessionId == null )
+            return null;
 
-	/**
-	 * This is the session ID assigned by the server. RTSP messages with the
-	 * server must use this ID.
-	 */
-	private String serverSessionId = null;
+        return serverSessionIds.get( serverSessionId );
+    }
 
-	/** Tells whether the proxySession has already been closed. */
-	private boolean closedFlag = false;
+    /**
+     * This is the session ID generated by the proxy and used for the
+     * communication with the client.
+     */
+    private String clientSessionId = null;
 
-	/**
-	 * Collection of Track associated with this ProxySession.
-	 */
-	private Map&lt;String, Track&gt; trackList = new ConcurrentHashMap&lt;String, Track&gt;();
+    /**
+     * This is the session ID assigned by the server. RTSP messages with the
+     * server must use this ID.
+     */
+    private String serverSessionId = null;
 
-	/**
-	 * object name of proxy session
-	 */
-	private ObjectName objectName;
+    /** Tells whether the proxySession has already been closed. */
+    private boolean closedFlag = false;
 
-	/**
-	 * the special server-side session which handles RTP sessions with different local source ports
-	 */
-	private PortrangeRtpServerSession portrangeRtpServerSession;
+    /**
+     * Collection of Track associated with this ProxySession.
+     */
+    private Map&lt;String, Track&gt; trackList = new ConcurrentHashMap&lt;String, Track&gt;();
 
-	/**
-	 * @return Returns the objectName.
-	 */
-	public ObjectName getObjectName() {
-		return objectName;
-	}
+    /**
+     * object name of proxy session
+     */
+    private ObjectName objectName;
 
-	/**
-	 * @param objectName The objectName to set.
-	 */
-	public void setObjectName(ObjectName objectName) {
-		this.objectName = objectName;
-	}
+    /**
+     * the special server-side session which handles RTP sessions with different
+     * local source ports
+     */
+    private PortrangeRtpServerSession portrangeRtpServerSession;
 
-	/**
-	 * Construct a new ProxySession. The session ID that will be used when
-	 * communicating with the client will be generated.
-	 */
-	public ProxySession()
-	{
-		setClientSessionId( newSessionID() );
-		log.debug( &quot;\n----------\nCreated new proxy session: &quot; + clientSessionId
-				+ &quot; \n----------&quot; );
-	}
+    /**
+     * @return Returns the objectName.
+     */
+    public ObjectName getObjectName()
+    {
+        return objectName;
+    }
 
-	/**
-	 * Adds a new Track associated with this ProxySession.
-	 * 
-	 * @param url
-	 *        The URL used as a control reference for the Track
-	 * @param serverSsrc
-	 *        the SSRC id given by the server or null if not provided
-	 * @return a reference to the newly created Track
-	 */
-	public synchronized RtpTrack addRtpTrack( String url, String serverSsrc )
-	{
-		RtpTrack track = new RtpTrack( url );
-		if ( serverSsrc != null )
-			track.setServerSSRC( serverSsrc );
-		if(portrangeRtpServerSession != null)
-			track.setPortrangeRtpServerSession(this.portrangeRtpServerSession);
-		
-		trackList.put( url, track );
-		log.debug( &quot;ProxySession: &quot; + clientSessionId + &quot; Added track. TrackList: &quot;
-				+ trackList );
-		return track;
-	}
-	
-	/**
-	 * Adds a new Track associated with this ProxySession.
-	 * 
-	 * @param url
-	 *        The URL used as a control reference for the Track
-	 * @param serverSsrc
-	 *        the SSRC id given by the server or null if not provided
-	 * @return a reference to the newly created Track
-	 */
-	public synchronized RdtTrack addRdtTrack( String url )
-	{
-		RdtTrack track = new RdtTrack( url );
-		trackList.put( url, track );
-		log.debug( &quot;ProxySession: &quot; + clientSessionId + &quot; Added track. TrackList: &quot;
-				+ trackList );
-		return track;
-	}
+    /**
+     * @param objectName
+     *            The objectName to set.
+     */
+    public void setObjectName( ObjectName objectName )
+    {
+        this.objectName = objectName;
+    }
 
-	/**
-	 * @return the RTSP session id used by the client in this session.
-	 */
-	public String getClientSessionId()
-	{
-		return clientSessionId;
-	}
+    /**
+     * Construct a new ProxySession. The session ID that will be used when
+     * communicating with the client will be generated.
+     */
+    public ProxySession()
+    {
+        setClientSessionId( newSessionID() );
+        log.debug( &quot;\n----------\nCreated new proxy session: {} \n----------&quot;,
+                clientSessionId );
+    }
 
-	/**
-	 * @return the RTSP session id used by the server in this session.
-	 */
-	public String getServerSessionId()
-	{
-		return serverSessionId;
-	}
+    /**
+     * Adds a new Track associated with this ProxySession.
+     * 
+     * @param url
+     *            The URL used as a control reference for the Track
+     * @param serverSsrc
+     *            the SSRC id given by the server or null if not provided
+     * @return a reference to the newly created Track
+     */
+    public synchronized RtpTrack addRtpTrack( String url, String serverSsrc )
+    {
+        RtpTrack track = new RtpTrack( url );
+        if ( serverSsrc != null )
+            track.setServerSSRC( serverSsrc );
+        if ( portrangeRtpServerSession != null )
+            track.setPortrangeRtpServerSession( this.portrangeRtpServerSession );
 
-	/**
-	 * Sets the RTSP session id for the client.
-	 * 
-	 * @param clientSessionId
-	 *        a string containing the session id
-	 */
-	public synchronized void setClientSessionId( String clientSessionId )
-	{
-		this.clientSessionId = clientSessionId;
-		clientSessionIds.put( clientSessionId, this );
-		makeManaged();
-	}
+        trackList.put( url, track );
+        log.debug( &quot;ProxySession: {} Added track. TrackList: {}&quot;, clientSessionId,
+                trackList );
+        return track;
+    }
 
-	/**
-	 * Sets the RTSP session id for the client.
-	 * 
-	 * @param clientSessionId
-	 *        a string containing the session id
-	 */
-	public synchronized void setServerSessionId( String serverSessionId )
-	{
-		this.serverSessionId = serverSessionId;
-		if ( serverSessionId != null )
-			serverSessionIds.put( serverSessionId, this );
-		makeManaged();
-	}
+    /**
+     * Adds a new Track associated with this ProxySession.
+     * 
+     * @param url
+     *            The URL used as a control reference for the Track
+     * @param serverSsrc
+     *            the SSRC id given by the server or null if not provided
+     * @return a reference to the newly created Track
+     */
+    public synchronized RdtTrack addRdtTrack( String url )
+    {
+        RdtTrack track = new RdtTrack( url );
+        trackList.put( url, track );
+        log.debug( &quot;ProxySession: {} Added track. TrackList: {}&quot;, clientSessionId,
+                trackList );
+        return track;
+    }
 
-	/**
-	 * check if both client and server session id's are set and register proxy session 
-	 * facade MBean
-	 */
-	private void makeManaged() {
-		if(this.clientSessionId != null &amp;&amp; this.serverSessionId != null)
-			JmxAgent.getInstance().registerProxySession(this);
-	}
-	
-	/**
-	 * Closes the entire proxy session and frees all associated resources.
-	 */
-	public synchronized void close()
-	{
-		if ( closedFlag )
-			return;
+    /**
+     * @return the RTSP session id used by the client in this session.
+     */
+    public String getClientSessionId()
+    {
+        return clientSessionId;
+    }
 
-		log.debug( &quot;TrackList: &quot; + trackList );
+    /**
+     * @return the RTSP session id used by the server in this session.
+     */
+    public String getServerSessionId()
+    {
+        return serverSessionId;
+    }
 
-		// close all associated tracks
-		for ( Map.Entry&lt;String, Track&gt; entry : trackList.entrySet() ) {
-			entry.getValue().close();
-		}
+    /**
+     * Sets the RTSP session id for the client.
+     * 
+     * @param clientSessionId
+     *            a string containing the session id
+     */
+    public synchronized void setClientSessionId( String clientSessionId )
+    {
+        this.clientSessionId = clientSessionId;
+        clientSessionIds.put( clientSessionId, this );
+        makeManaged();
+    }
 
-		closedFlag = true;
-		log.debug( &quot;Closed proxySession: &quot; + clientSessionId );
+    /**
+     * Sets the RTSP session id for the client.
+     * 
+     * @param clientSessionId
+     *            a string containing the session id
+     */
+    public synchronized void setServerSessionId( String serverSessionId )
+    {
+        this.serverSessionId = serverSessionId;
+        if ( serverSessionId != null )
+            serverSessionIds.put( serverSessionId, this );
+        makeManaged();
+    }
 
-		String s = &quot;&quot;;
-		for ( String a : clientSessionIds.keySet() ) {
-			s += a + &quot; &quot;;
-		}
-		log.debug( &quot;Clients: &quot; + s );
-		s = &quot;&quot;;
-		for ( String a : serverSessionIds.keySet() ) {
-			s += a + &quot; &quot;;
-		}
-		log.debug( &quot;Servers: &quot; + s );
+    /**
+     * check if both client and server session id's are set and register proxy
+     * session facade MBean
+     */
+    private void makeManaged()
+    {
+        if ( this.clientSessionId != null &amp;&amp; this.serverSessionId != null )
+            JmxAgent.getInstance().registerProxySession( this );
+    }
 
-		if ( clientSessionId != null )
-			clientSessionIds.remove( clientSessionId );
-		if ( serverSessionId != null )
-			serverSessionIds.remove( serverSessionId );
-		
-		if(this.portrangeRtpServerSession != null)
-			PortrangeRtpServerSessionFactory.getInstance().releaseSession(this.portrangeRtpServerSession);
-		
-		// unregister session facade in MBean server
-		JmxAgent.getInstance().unregisterProxySession(this);
-	}
+    /**
+     * Closes the entire proxy session and frees all associated resources.
+     */
+    public synchronized void close()
+    {
+        if ( closedFlag )
+            return;
 
-	// ///////////////////
-	// Session ID generation
+        log.debug( &quot;TrackList: {}&quot;, trackList );
 
-	/** Used for Session IDs generation */
-	private static Random random = new Random();
+        // close all associated tracks
+        for ( Map.Entry&lt;String, Track&gt; entry : trackList.entrySet() ) {
+            entry.getValue().close();
+        }
 
-	/**
-	 * Creates a unique session ID that is a 64 bit number.
-	 * 
-	 * @return the session ID string.
-	 */
-	private static String newSessionID()
-	{
-		String id;
-		while ( true ) {
-			// Create a 64 bit random number
-			synchronized ( random ) {
-				id = new UnsignedLong( random ).toString();
-			}
+        closedFlag = true;
+        log.debug( &quot;Closed proxySession: {}&quot;, clientSessionId );
 
-			if ( clientSessionIds.get( id ) == null ) {
-				// Ok, the id is unique
-				return id;
-			}
-			// try with another id
-		}
-	}
+        String s = &quot;&quot;;
+        for ( String a : clientSessionIds.keySet() ) {
+            s += a + &quot; &quot;;
+        }
+        log.debug( &quot;Clients: {}&quot;, s );
+        s = &quot;&quot;;
+        for ( String a : serverSessionIds.keySet() ) {
+            s += a + &quot; &quot;;
+        }
+        log.debug( &quot;Servers: {}&quot;, s );
 
-	/**
-	 * Creates a unique session ID that is a 64 bit number.
-	 * 
-	 * @return the session ID string.
-	 */
-	public static UnsignedInt newServerSessionID()
-	{
-		UnsignedInt id;
-		while ( true ) {
-			// Create a 64 bit random number
-			synchronized ( random ) {
-				id = new UnsignedInt( random );
-			}
+        if ( clientSessionId != null )
+            clientSessionIds.remove( clientSessionId );
+        if ( serverSessionId != null )
+            serverSessionIds.remove( serverSessionId );
 
-			if ( serverSessionIds.get( id.toString() ) == null ) {
-				// Ok, the id is unique
-				return id;
-			}
-			// try with another id
-		}
-	}
+        if ( this.portrangeRtpServerSession != null )
+            PortrangeRtpServerSessionFactory.getInstance().releaseSession(
+                    this.portrangeRtpServerSession );
 
-	/**
-	 * @return Returns the closedFlag.
-	 */
-	public boolean isClosed() {
-		return closedFlag;
-	}
+        // unregister session facade in MBean server
+        JmxAgent.getInstance().unregisterProxySession( this );
+    }
 
-	public void setPortrangeRtpServerSession(PortrangeRtpServerSession portrangeRtpSession) {
-		this.portrangeRtpServerSession = portrangeRtpSession;
-	}
+    // ///////////////////
+    // Session ID generation
 
+    /** Used for Session IDs generation */
+    private static Random random = new Random();
+
+    /**
+     * Creates a unique session ID that is a 64 bit number.
+     * 
+     * @return the session ID string.
+     */
+    private static String newSessionID()
+    {
+        String id;
+        while ( true ) {
+            // Create a 64 bit random number
+            synchronized ( random ) {
+                id = new UnsignedLong( random ).toString();
+            }
+
+            if ( clientSessionIds.get( id ) == null ) {
+                // Ok, the id is unique
+                return id;
+            }
+            // try with another id
+        }
+    }
+
+    /**
+     * Creates a unique session ID that is a 64 bit number.
+     * 
+     * @return the session ID string.
+     */
+    public static UnsignedInt newServerSessionID()
+    {
+        UnsignedInt id;
+        while ( true ) {
+            // Create a 64 bit random number
+            synchronized ( random ) {
+                id = new UnsignedInt( random );
+            }
+
+            if ( serverSessionIds.get( id.toString() ) == null ) {
+                // Ok, the id is unique
+                return id;
+            }
+            // try with another id
+        }
+    }
+
+    /**
+     * @return Returns the closedFlag.
+     */
+    public boolean isClosed()
+    {
+        return closedFlag;
+    }
+
+    public void setPortrangeRtpServerSession(
+            PortrangeRtpServerSession portrangeRtpSession )
+    {
+        this.portrangeRtpServerSession = portrangeRtpSession;
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRdtPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRdtPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRdtPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -20,20 +20,15 @@
 
 import java.net.InetSocketAddress;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.apache.mina.common.ByteBuffer;
-import org.apache.mina.common.IoFilterChain;
 import org.apache.mina.common.IoHandlerAdapter;
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.TrafficMask;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.lib.Exceptions;
 import rtspproxy.proxy.track.RdtTrack;
 import rtspproxy.proxy.track.Track;
-import rtspproxy.rdt.RdtFilterChainBuilder;
 import rtspproxy.rdt.RdtPacket;
-import rtspproxy.rdt.RdtPacketDecoder;
 
 /**
  * Handles RDT packets from server and forward them to client. The RTSP 
@@ -81,22 +76,21 @@
 		if(buffer instanceof RdtPacket) {
 			RdtPacket rdtPacket = (RdtPacket)buffer;
 			
-			log.debug( &quot;Received RDT packet from server, packet=&quot; + rdtPacket );
+			log.debug( &quot;Received RDT packet from server, packet={}&quot;, rdtPacket );
 
 			RdtTrack track = (RdtTrack)Track.getByServerAddress( (InetSocketAddress) session.getRemoteAddress() );
 
 			if ( track == null ) {
 				// drop packet
-				log.debug( &quot;Invalid address: &quot;
-						+ (InetSocketAddress) session.getRemoteAddress()
-						+ &quot; - Class: &quot;
-						+ ( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getClass() );
+				log.debug( &quot;Invalid address: {} - Class: {}&quot;,
+						session.getRemoteAddress(),
+						( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getClass() );
 				return;
 			}
 
 			track.forwardRdtToClient( rdtPacket );			
 		} else {
-			log.debug(&quot;invalid object passed: &quot; + buffer.getClass().getName());
+			log.debug(&quot;invalid object passed: {}&quot;,  buffer.getClass().getName());
 			
 			throw new IllegalStateException(&quot;invalid packet on chain&quot;);
 		}
@@ -105,7 +99,7 @@
 	@Override
 	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
 	{
-		log.info( &quot;Exception: &quot; + cause );
+		log.info( &quot;Exception: {}&quot;, cause );
 		Exceptions.logStackTrace( cause );
 		session.close();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtcpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtcpPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtcpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -38,52 +38,54 @@
 public class ServerRtcpPacketHandler extends IoHandlerAdapter
 {
 
-	private static Logger log = LoggerFactory.getLogger( ServerRtcpPacketHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ServerRtcpPacketHandler.class );
 
-	@Override
-	public void messageReceived( IoSession session, Object buffer ) throws Exception
-	{
-		RtcpPacket packet = new RtcpPacket( (ByteBuffer) buffer );
-		// log.debug( &quot;Receive RTCP packet: &quot; + packet.getType() );
-		RtpTrack track = null;
-		
-		if(!Config.proxyServerRtpSsrcUnreliable.getValue())
-			track = RtpTrack.getByServerSSRC( packet.getSsrc() );
+    @Override
+    public void messageReceived( IoSession session, Object buffer ) throws Exception
+    {
+        RtcpPacket packet = new RtcpPacket( (ByteBuffer) buffer );
+        // log.debug( &quot;Receive RTCP packet: &quot; + packet.getType() );
+        RtpTrack track = null;
 
-		if ( track == null ) {
-			if(Config.proxyServerRtpMultiplePorts.getValue())
-				track = (RtpTrack)Track.getByLocalRemoteServerAddress((InetSocketAddress)session.getLocalAddress(),
-						(InetSocketAddress)session.getRemoteAddress());
-			else
-				track = (RtpTrack)Track.getByServerAddress( (InetSocketAddress) session.getRemoteAddress() );
+        if ( !Config.proxyServerRtpSsrcUnreliable.getValue() )
+            track = RtpTrack.getByServerSSRC( packet.getSsrc() );
 
-			if ( track == null ) {
-				// drop packet
-				log.debug( &quot;Invalid SSRC identifier: &quot; + packet.getSsrc().toHexString() );
-				return;
-			} else {
-				// hot-wire the ssrc into the track
-				log.debug( &quot;Adding SSRC identifier: &quot; + packet.getSsrc().toHexString() );
-				track.setServerSSRC( packet.getSsrc() );
-			}
-		}
+        if ( track == null ) {
+            if ( Config.proxyServerRtpMultiplePorts.getValue() )
+                track = (RtpTrack) Track.getByLocalRemoteServerAddress(
+                        (InetSocketAddress) session.getLocalAddress(),
+                        (InetSocketAddress) session.getRemoteAddress() );
+            else
+                track = (RtpTrack) Track.getByServerAddress( (InetSocketAddress) session
+                        .getRemoteAddress() );
 
-		track.setRtcpServerSession( session );
-		track.forwardRtcpToClient( packet );
-	}
+            if ( track == null ) {
+                // drop packet
+                log.debug( &quot;Invalid SSRC identifier: {}&quot;, packet.getSsrc().toHexString() );
+                return;
+            }
+            
+            // hot-wire the ssrc into the track
+            log.debug( &quot;Adding SSRC identifier: {}&quot;, packet.getSsrc().toHexString() );
+            track.setServerSSRC( packet.getSsrc() );
+        }
 
-	@Override
-	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
-	{
-		log.debug( &quot;Exception: &quot; + cause );
-		Exceptions.logStackTrace( cause );
-		session.close();
-	}
+        track.setRtcpServerSession( session );
+        track.forwardRtcpToClient( packet );
+    }
 
-	@Override
-	public void sessionCreated( IoSession session ) throws Exception
-	{
+    @Override
+    public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
+    {
+        log.debug( &quot;Exception: &quot;, cause );
+        Exceptions.logStackTrace( cause );
+        session.close();
+    }
 
-	}
+    @Override
+    public void sessionCreated( IoSession session ) throws Exception
+    {
 
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtpPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -28,6 +28,7 @@
 
 import rtspproxy.config.Config;
 import rtspproxy.lib.Exceptions;
+import rtspproxy.lib.number.UnsignedInt;
 import rtspproxy.proxy.track.RtpTrack;
 import rtspproxy.proxy.track.Track;
 import rtspproxy.rtp.RtpPacket;
@@ -38,72 +39,77 @@
 public class ServerRtpPacketHandler extends IoHandlerAdapter
 {
 
-	private static Logger log = LoggerFactory.getLogger( ServerRtpPacketHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ServerRtpPacketHandler.class );
 
-	/*
-	 * @see org.apache.mina.io.IoHandlerAdapter#dataRead(org.apache.mina.io.IoSession,
-	 *      org.apache.mina.common.ByteBuffer)
-	 */
-	@Override
-	public void messageReceived( IoSession session, Object buffer ) throws Exception
-	{
-		// log.debug( &quot;Received RTP packet&quot; );
-		RtpPacket packet = new RtpPacket( (ByteBuffer) buffer );
-		RtpTrack track = null;
+    /*
+     * @see org.apache.mina.io.IoHandlerAdapter#dataRead(org.apache.mina.io.IoSession,
+     *      org.apache.mina.common.ByteBuffer)
+     */
+    @Override
+    public void messageReceived( IoSession session, Object buffer ) throws Exception
+    {
+        // log.debug( &quot;Received RTP packet&quot; );
+        RtpPacket packet = new RtpPacket( (ByteBuffer) buffer );
+        RtpTrack track = null;
 
-		if(!Config.proxyServerRtpSsrcUnreliable.getValue())
-			track = RtpTrack.getByServerSSRC( packet.getSsrc() );
-		
-		log.debug(&quot;recevied server RTP packet, SSRC=&quot; + packet.getSsrc() + &quot;, CSRC=&quot; + packet.getCsrc()
-				+ &quot;, server=&quot; + session.getRemoteAddress() + &quot;, local=&quot; + session.getLocalAddress());
-		
-		if ( track == null ) {
-			if(Config.proxyServerRtpMultiplePorts.getValue())
-				track = (RtpTrack)Track.getByLocalRemoteServerAddress((InetSocketAddress)session.getLocalAddress(),
-						(InetSocketAddress)session.getRemoteAddress());
-			else
-				track = (RtpTrack)Track.getByServerAddress( (InetSocketAddress) session.getRemoteAddress() );
+        if ( !Config.proxyServerRtpSsrcUnreliable.getValue() )
+            track = RtpTrack.getByServerSSRC( packet.getSsrc() );
 
-			if ( track == null ) {
-				// drop packet
-				log.debug( &quot;Invalid SSRC identifier: &quot;
-						+ packet.getSsrc().toHexString() );
-				return;
-			} else {
-				// hot-wire the ssrc into the track
-				log.debug( &quot;Adding SSRC identifier: &quot;
-						+ packet.getSsrc().toHexString() );
-				track.setServerSSRC( packet.getSsrc() );
-			}
+        /*
+         * if ( log.isDebugEnabled() ) { log.debug( &quot;recevied server RTP packet,
+         * SSRC=&quot; + packet.getSsrc() + &quot;, CSRC=&quot; + packet.getCsrc() + &quot;,
+         * server=&quot; + session.getRemoteAddress() + &quot;, local=&quot; +
+         * session.getLocalAddress() ); }
+         */
 
-		}
+        if ( track == null ) {
+            if ( Config.proxyServerRtpMultiplePorts.getValue() )
+                track = (RtpTrack) Track.getByLocalRemoteServerAddress(
+                        (InetSocketAddress) session.getLocalAddress(),
+                        (InetSocketAddress) session.getRemoteAddress() );
+            else
+                track = (RtpTrack) Track.getByServerAddress( (InetSocketAddress) session
+                        .getRemoteAddress() );
 
-		track.setRtpServerSession( session );
-		track.forwardRtpToClient( packet );
-	}
+            if ( track == null ) {
+                // drop packet
+                log.debug( &quot;Invalid SSRC identifier: {}&quot;, packet.getSsrc().toHexString() );
+                return;
+            }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.mina.io.IoHandlerAdapter#exceptionCaught(org.apache.mina.io.IoSession,
-	 *      java.lang.Throwable)
-	 */
-	@Override
-	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
-	{
-		log.debug( &quot;Exception: &quot; + cause );
-		Exceptions.logStackTrace( cause );
-		session.close();
-	}
+            // hot-wire the ssrc into the track
+            if ( track.getServerSSRC() == UnsignedInt.ZERO ) {
+                log.debug( &quot;Adding SSRC identifier: {}&quot;, packet.getSsrc().toHexString() );
+                track.setServerSSRC( packet.getSsrc() );
+            }
+        }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.mina.io.IoHandlerAdapter#sessionCreated(org.apache.mina.io.IoSession)
-	 */
-	@Override
-	public void sessionCreated( IoSession session ) throws Exception
-	{
-	}
+        track.setRtpServerSession( session );
+        track.forwardRtpToClient( packet );
+    }
 
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.io.IoHandlerAdapter#exceptionCaught(org.apache.mina.io.IoSession,
+     *      java.lang.Throwable)
+     */
+    @Override
+    public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
+    {
+        log.debug( &quot;Exception: {}&quot;, cause );
+        Exceptions.logStackTrace( cause );
+        session.close();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.io.IoHandlerAdapter#sessionCreated(org.apache.mina.io.IoSession)
+     */
+    @Override
+    public void sessionCreated( IoSession session ) throws Exception
+    {
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerSide.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerSide.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerSide.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -13,12 +13,10 @@
 
 package rtspproxy.proxy;
 
-import java.util.HashMap;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.IoHandlerAdapter;
 import org.apache.mina.common.IoSession;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.lib.Exceptions;
 import rtspproxy.rtsp.RtspCode;
@@ -37,7 +35,7 @@
 	@Override
 	public void sessionCreated( IoSession session ) throws Exception
 	{
-		log.info( &quot;Created session to server: &quot; + session.getRemoteAddress() );
+		log.info( &quot;Created session to server: {}&quot;, session.getRemoteAddress() );
 	}
 
 	@Override
@@ -198,7 +196,7 @@
 	public void messageReceived( IoSession session, Object message )
 	{
 		RtspMessage rtspMessage = (RtspMessage) message;
-		log.debug( &quot;Received message:\n&quot; + message );
+		log.debug( &quot;Received message:\n{}&quot;, message );
 
 		ProxyHandler proxyHandler = (ProxyHandler) ( session.getAttribute( ProxyHandler.ATTR ) );
 		if ( proxyHandler == null ) {

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RdtTrack.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RdtTrack.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RdtTrack.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,10 +3,9 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 
+import org.apache.mina.common.IoSession;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.apache.mina.common.ByteBuffer;
-import org.apache.mina.common.IoSession;
 
 import rtspproxy.RdtClientService;
 import rtspproxy.RdtServerService;
@@ -15,136 +14,138 @@
 public class RdtTrack extends Track
 {
 
-	private static Logger log = LoggerFactory.getLogger( RdtTrack.class );
+    private static Logger log = LoggerFactory.getLogger( RdtTrack.class );
 
-	/**
-	 * Cached references to IoSession objects used to send packets to server and
-	 * client.
-	 */
-	private IoSession rdtClientSession = null;
+    /**
+     * Cached references to IoSession objects used to send packets to server and
+     * client.
+     */
+    private IoSession rdtClientSession = null;
 
-	private IoSession rdtServerSession = null;
+    private IoSession rdtServerSession = null;
 
-	private int clientRdtPort;
+    private int clientRdtPort;
 
-	private int serverRdtPort;
+    private int serverRdtPort;
 
-	/**
-	 * Construct a new Track.
-	 * 
-	 * @param url
-	 *            the control name for this track.
-	 */
-	public RdtTrack( String url )
-	{
-		super( url );
-	}
+    /**
+     * Construct a new Track.
+     * 
+     * @param url
+     *            the control name for this track.
+     */
+    public RdtTrack( String url )
+    {
+        super( url );
+    }
 
-	/**
-	 * Forwards a RDT packet to client. The packet will be set to the address
-	 * indicated by the client at RDT port.
-	 * &lt;p&gt;
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param packet
-	 *            a buffer containing a RDT packet
-	 */
-	public void forwardRdtToClient( RdtPacket packet )
-	{
-		// modify the SSRC for the client
-		// packet.setSsrc( proxySSRC );
+    /**
+     * Forwards a RDT packet to client. The packet will be set to the address
+     * indicated by the client at RDT port.
+     * &lt;p&gt;
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param packet
+     *            a buffer containing a RDT packet
+     */
+    public void forwardRdtToClient( RdtPacket packet )
+    {
+        // modify the SSRC for the client
+        // packet.setSsrc( proxySSRC );
 
-		if ( rdtClientSession == null ) {
-			rdtClientSession = RdtClientService.getInstance().newSession(
-					new InetSocketAddress( clientAddress, clientRdtPort ) );
-		}
+        if ( rdtClientSession == null ) {
+            rdtClientSession = RdtClientService.getInstance().newSession(
+                    new InetSocketAddress( clientAddress, clientRdtPort ) );
+        }
 
-		log.debug( &quot;Packet: &quot; + packet );
-		rdtClientSession.write( packet );
-	}
+        log.debug( &quot;Packet: {}&quot;, packet );
+        rdtClientSession.write( packet );
+    }
 
-	/**
-	 * Forwards a RDT packet to server. The packet will be set to the address
-	 * indicated by the server at RDT port.
-	 * 
-	 * @param packet
-	 *            a RDT packet
-	 */
-	public void forwardRdtToServer( RdtPacket packet )
-	{
-		if ( rdtServerSession == null || !rdtServerSession.isConnected() ) {
-			InetSocketAddress remoteAddress = new InetSocketAddress( serverAddress,
-					serverRdtPort );
-			log.debug( &quot;Creating RDT session to: &quot; + remoteAddress );
-			rdtServerSession = RdtServerService.getInstance().newSession( remoteAddress );
-		}
+    /**
+     * Forwards a RDT packet to server. The packet will be set to the address
+     * indicated by the server at RDT port.
+     * 
+     * @param packet
+     *            a RDT packet
+     */
+    public void forwardRdtToServer( RdtPacket packet )
+    {
+        if ( rdtServerSession == null || !rdtServerSession.isConnected() ) {
+            InetSocketAddress remoteAddress = new InetSocketAddress( serverAddress,
+                    serverRdtPort );
+            log.debug( &quot;Creating RDT session to: {}&quot;, remoteAddress );
+            rdtServerSession = RdtServerService.getInstance().newSession( remoteAddress );
+        }
 
-		// log.debug( &quot;Packet: &quot; + packet );
-		// packet.reset();
-		// log.debug(&quot;Packet: &quot; + packet );
-		// log.debug( &quot;Written bytes1: &quot; + rdtServerSession.getWrittenBytes() );
-		
-		rdtServerSession.write( packet );
-		// log.debug( &quot;Written bytes2: &quot; + rdtServerSession.getWrittenBytes() );
-	}
+        // log.debug( &quot;Packet: {}&quot;, packet );
+        // packet.reset();
+        // log.debug(&quot;Packet: {}&quot;, packet );
+        // log.debug( &quot;Written bytes1: {}&quot;, rdtServerSession.getWrittenBytes() );
 
-	/**
-	 * Set the address of the server associated with this track.
-	 * &lt;p&gt;
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param serverHost
-	 *            The serverHost to set.
-	 * @param rdtpPort
-	 *            the port number used for RDT packets
-	 */
-	public synchronized void setClientAddress( InetAddress clientAddress, int rdtPort )
-	{
-		this.clientAddress = clientAddress;
-		this.clientRdtPort = rdtPort;
+        rdtServerSession.write( packet );
+        // log.debug( &quot;Written bytes2: {}&quot;, rdtServerSession.getWrittenBytes() );
+    }
 
-		InetSocketAddress clientAddr = new InetSocketAddress( clientAddress, rdtPort );
+    /**
+     * Set the address of the server associated with this track.
+     * &lt;p&gt;
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param serverHost
+     *            The serverHost to set.
+     * @param rdtpPort
+     *            the port number used for RDT packets
+     */
+    public synchronized void setClientAddress( InetAddress clientAddress, int rdtPort )
+    {
+        this.clientAddress = clientAddress;
+        this.clientRdtPort = rdtPort;
 
-		/*
-		log.debug( &quot;Creating RDT server session to: &quot; + clientAddr );
-		rdtClientSession = RdtClientService.getInstance().newSession( clientAddr );
-		*/
-		
-		clientAddressMap.put( clientAddr , this );
-	}
+        InetSocketAddress clientAddr = new InetSocketAddress( clientAddress, rdtPort );
 
-	/**
-	 * Set the address of the server associated with this track.
-	 * 
-	 * @param serverHost
-	 *            The serverHost to set.
-	 * @param rdtPort
-	 *            the port number used for RDT packets
-	 */
-	public synchronized void setServerAddress( InetAddress serverAddress, int rdtPort )
-	{
-		this.serverAddress = serverAddress;
-		this.serverRdtPort = rdtPort;
+        /*
+         * log.debug( &quot;Creating RDT server session to: {}&quot;, clientAddr );
+         * rdtClientSession = RdtClientService.getInstance().newSession(
+         * clientAddr );
+         */
 
-		InetSocketAddress remoteAddress = new InetSocketAddress( serverAddress,
-				serverRdtPort );
-		
-		/*
-		log.debug( &quot;Creating RDT server session to: &quot; + remoteAddress );
-		rdtServerSession = RdtServerService.getInstance().newSession( remoteAddress );
-		*/
-		
-		serverAddressMap.put( remoteAddress, this );
-	}
+        clientAddressMap.put( clientAddr, this );
+    }
 
-	public synchronized void close()
-	{
-		serverAddressMap.remove( new InetSocketAddress( serverAddress, serverRdtPort ) );
-		clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRdtPort ) );
+    /**
+     * Set the address of the server associated with this track.
+     * 
+     * @param serverHost
+     *            The serverHost to set.
+     * @param rdtPort
+     *            the port number used for RDT packets
+     */
+    public synchronized void setServerAddress( InetAddress serverAddress, int rdtPort )
+    {
+        this.serverAddress = serverAddress;
+        this.serverRdtPort = rdtPort;
 
-		
-		log.debug( &quot;Closed track &quot; + url );
-	}
+        InetSocketAddress remoteAddress = new InetSocketAddress( serverAddress,
+                serverRdtPort );
+
+        /*
+         * log.debug( &quot;Creating RDT server session to: {}&quot;, remoteAddress );
+         * rdtServerSession = RdtServerService.getInstance().newSession(
+         * remoteAddress );
+         */
+
+        serverAddressMap.put( remoteAddress, this );
+    }
+
+    @Override
+    public synchronized void close()
+    {
+        serverAddressMap.remove( new InetSocketAddress( serverAddress, serverRdtPort ) );
+        clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRdtPort ) );
+
+        log.debug( &quot;Closed track {}&quot;, url );
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RtpTrack.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RtpTrack.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RtpTrack.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -25,345 +25,355 @@
 public class RtpTrack extends Track
 {
 
-	private static Logger log = LoggerFactory.getLogger( RtpTrack.class );
+    private static Logger log = LoggerFactory.getLogger( RtpTrack.class );
 
-	/** Maps a server SSRC id to a Track */
-	private static Map&lt;UnsignedInt, RtpTrack&gt; serverSsrcMap = new ConcurrentHashMap&lt;UnsignedInt, RtpTrack&gt;();
+    /** Maps a server SSRC id to a Track */
+    private static Map&lt;UnsignedInt, RtpTrack&gt; serverSsrcMap = new ConcurrentHashMap&lt;UnsignedInt, RtpTrack&gt;();
 
-	/** Keeps track of the SSRC IDs used by the proxy, to avoid collisions. */
-	private static Set&lt;UnsignedInt&gt; proxySsrcList = Collections
-			.synchronizedSet( new HashSet&lt;UnsignedInt&gt;() );
+    /** Keeps track of the SSRC IDs used by the proxy, to avoid collisions. */
+    private static Set&lt;UnsignedInt&gt; proxySsrcList = Collections
+            .synchronizedSet( new HashSet&lt;UnsignedInt&gt;() );
 
-	/**
-	 * Get the track by looking at server SSRC id.
-	 * 
-	 * @return a Track instance if a matching SSRC is found or null
-	 */
-	public static RtpTrack getByServerSSRC( UnsignedInt serverSsrc )
-	{
-		return serverSsrcMap.get( serverSsrc );
-	}
+    /**
+     * Get the track by looking at server SSRC id.
+     * 
+     * @return a Track instance if a matching SSRC is found or null
+     */
+    public static RtpTrack getByServerSSRC( UnsignedInt serverSsrc )
+    {
+        return serverSsrcMap.get( serverSsrc );
+    }
 
-	/** SSRC id given by the server */
-	private UnsignedInt serverSSRC = new UnsignedInt( 0 );
+    /** SSRC id given by the server */
+    private UnsignedInt serverSSRC = UnsignedInt.ZERO;
 
-	/** SSRC id selected by the proxy */
-	private UnsignedInt proxySSRC = new UnsignedInt( 0 );
+    /** SSRC id selected by the proxy */
+    private UnsignedInt proxySSRC = UnsignedInt.ZERO;
 
-	/**
-	 * Cached references to IoSession objects used to send packets to server and
-	 * client.
-	 */
-	private IoSession rtpServerSession = null;
+    /**
+     * Cached references to IoSession objects used to send packets to server and
+     * client.
+     */
+    private IoSession rtpServerSession = null;
 
-	private IoSession rtcpServerSession = null;
+    private IoSession rtcpServerSession = null;
 
-	private IoSession rtpClientSession = null;
+    private IoSession rtpClientSession = null;
 
-	private IoSession rtcpClientSession = null;
+    private IoSession rtcpClientSession = null;
 
-	private int clientRtpPort;
+    private int clientRtpPort;
 
-	private int clientRtcpPort;
+    private int clientRtcpPort;
 
-	private int serverRtpPort;
+    private int serverRtpPort;
 
-	private int serverRtcpPort;
-	
-	private PortrangeRtpServerSession portrangeRtpServerSession;
+    private int serverRtcpPort;
 
-	/**
-	 * Construct a new Track.
-	 * 
-	 * @param url
-	 *            the control name for this track.
-	 */
-	public RtpTrack( String url )
-	{
-		super( url );
-		setProxySSRC( newSSRC() );
-	}
+    private PortrangeRtpServerSession portrangeRtpServerSession;
 
-	/**
-	 * @return the SSRC id used byt the proxy
-	 */
-	public UnsignedInt getProxySSRC()
-	{
-		return proxySSRC;
-	}
+    /**
+     * Construct a new Track.
+     * 
+     * @param url
+     *            the control name for this track.
+     */
+    public RtpTrack( String url )
+    {
+        super( url );
+        setProxySSRC( newSSRC() );
+    }
 
-	/**
-	 * Sets the proxy SSRC id.
-	 * 
-	 * @param proxySSRC
-	 */
-	public void setProxySSRC( String proxySSRC )
-	{
-		try {
-			this.proxySSRC = UnsignedInt.fromString( proxySSRC, 16 );
+    /**
+     * @return the SSRC id used byt the proxy
+     */
+    public UnsignedInt getProxySSRC()
+    {
+        return proxySSRC;
+    }
 
-			proxySsrcList.add( this.proxySSRC );
-		} catch ( NumberFormatException nfe ) {
-			log.debug( &quot;Cannot convert &quot; + proxySSRC + &quot; to integer.&quot; );
-			throw nfe;
-		}
-	}
+    /**
+     * Sets the proxy SSRC id.
+     * 
+     * @param proxySSRC
+     */
+    public void setProxySSRC( String proxySSRC )
+    {
+        try {
+            this.proxySSRC = UnsignedInt.fromString( proxySSRC, 16 );
 
-	/**
-	 * @return the server SSRC id
-	 */
-	public UnsignedInt getServerSSRC()
-	{
-		return serverSSRC;
-	}
+            proxySsrcList.add( this.proxySSRC );
+        } catch ( NumberFormatException nfe ) {
+            log.debug( &quot;Cannot convert {} to integer.&quot;, proxySSRC );
+            throw nfe;
+        }
+    }
 
-	/**
-	 * Sets the server SSRC id.
-	 * 
-	 * @param serverSSRC
-	 */
-	public void setServerSSRC( String serverSSRC )
-	{
-		this.serverSSRC = UnsignedInt.fromString( serverSSRC, 16 );
-		serverSsrcMap.put( this.serverSSRC, this );
-	}
+    /**
+     * @return the server SSRC id
+     */
+    public UnsignedInt getServerSSRC()
+    {
+        return serverSSRC;
+    }
 
-	/**
-	 * Sets the server SSRC id.
-	 * 
-	 * @param serverSSRC
-	 */
-	public void setServerSSRC( UnsignedInt serverSSRC )
-	{
-		this.serverSSRC = serverSSRC;
-		serverSsrcMap.put( this.serverSSRC, this );
-	}
+    /**
+     * Sets the server SSRC id.
+     * 
+     * @param serverSSRC
+     */
+    public void setServerSSRC( String serverSSRC )
+    {
+        this.serverSSRC = UnsignedInt.fromString( serverSSRC, 16 );
+        serverSsrcMap.put( this.serverSSRC, this );
+    }
 
-	public void setRtcpClientSession( IoSession rtcpClientSession )
-	{
-		this.rtcpClientSession = rtcpClientSession;
-	}
+    /**
+     * Sets the server SSRC id.
+     * 
+     * @param serverSSRC
+     */
+    public void setServerSSRC( UnsignedInt serverSSRC )
+    {
+        this.serverSSRC = serverSSRC;
+        serverSsrcMap.put( this.serverSSRC, this );
+    }
 
-	public void setRtcpServerSession( IoSession rtcpServerSession )
-	{
-		this.rtcpServerSession = rtcpServerSession;
-	}
+    public void setRtcpClientSession( IoSession rtcpClientSession )
+    {
+        this.rtcpClientSession = rtcpClientSession;
+    }
 
-	public void setRtpClientSession( IoSession rtpClientSession )
-	{
-		this.rtpClientSession = rtpClientSession;
-	}
+    public void setRtcpServerSession( IoSession rtcpServerSession )
+    {
+        this.rtcpServerSession = rtcpServerSession;
+    }
 
-	public void setRtpServerSession( IoSession rtpServerSession )
-	{
-		this.rtpServerSession = rtpServerSession;
-	}
+    public void setRtpClientSession( IoSession rtpClientSession )
+    {
+        this.rtpClientSession = rtpClientSession;
+    }
 
-	/**
-	 * Forwards a RTP packet to server. The packet will be set to the address
-	 * indicated by the server at RTP (even) port.
-	 * 
-	 * @param packet
-	 *            a RTP packet
-	 */
-	public void forwardRtpToServer( RtpPacket packet )
-	{
-		// modify the SSRC for the server
-		packet.setSsrc( proxySSRC );
+    public void setRtpServerSession( IoSession rtpServerSession )
+    {
+        this.rtpServerSession = rtpServerSession;
+    }
 
-		if ( rtpServerSession == null ) {
-			if(this.portrangeRtpServerSession != null) {
-				rtpServerSession = this.portrangeRtpServerSession.newRtpSession(new InetSocketAddress( serverAddress, 
-						serverRtpPort ));
-			} else {
-				rtpServerSession = RtpServerService.getInstance().newSession(
-						new InetSocketAddress( serverAddress, serverRtpPort ) );
-			}
-		}
+    /**
+     * Forwards a RTP packet to server. The packet will be set to the address
+     * indicated by the server at RTP (even) port.
+     * 
+     * @param packet
+     *            a RTP packet
+     */
+    public void forwardRtpToServer( RtpPacket packet )
+    {
+        // modify the SSRC for the server
+        packet.setSsrc( proxySSRC );
 
-		rtpServerSession.write( packet.toByteBuffer() );
-	}
+        if ( rtpServerSession == null ) {
+            if ( this.portrangeRtpServerSession != null ) {
+                rtpServerSession = this.portrangeRtpServerSession
+                        .newRtpSession( new InetSocketAddress( serverAddress,
+                                serverRtpPort ) );
+            } else {
+                rtpServerSession = RtpServerService.getInstance().newSession(
+                        new InetSocketAddress( serverAddress, serverRtpPort ) );
+            }
+        }
 
-	/**
-	 * Forwards a RTCP packet to server. The packet will be set to the address
-	 * indicated by the server at RTCP (odd) port.
-	 * 
-	 * @param packet
-	 *            a RTCP packet
-	 */
-	public void forwardRtcpToServer( RtcpPacket packet )
-	{
-		// modify the SSRC for the server
-		packet.setSsrc( proxySSRC );
+        rtpServerSession.write( packet.toByteBuffer() );
+    }
 
-		if ( rtcpServerSession == null ) {
-			if(this.portrangeRtpServerSession != null) {
-				rtcpServerSession = this.portrangeRtpServerSession.newRtcpSession(new InetSocketAddress( serverAddress, 
-						serverRtcpPort ));
-			} else {
-				rtcpServerSession = RtcpServerService.getInstance().newSession(
-						new InetSocketAddress( serverAddress, serverRtcpPort ) );
-			}
-		}
-		rtcpServerSession.write( packet.toByteBuffer() );
-	}
+    /**
+     * Forwards a RTCP packet to server. The packet will be set to the address
+     * indicated by the server at RTCP (odd) port.
+     * 
+     * @param packet
+     *            a RTCP packet
+     */
+    public void forwardRtcpToServer( RtcpPacket packet )
+    {
+        // modify the SSRC for the server
+        packet.setSsrc( proxySSRC );
 
-	/**
-	 * Forwards a RTP packet to client. The packet will be set to the address
-	 * indicated by the client at RTP (even) port.
-	 * &lt;p&gt;
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param packet
-	 *            a RTP packet
-	 */
-	public void forwardRtpToClient( RtpPacket packet )
-	{
-		// modify the SSRC for the client
-		packet.setSsrc( proxySSRC );
+        if ( rtcpServerSession == null ) {
+            if ( this.portrangeRtpServerSession != null ) {
+                rtcpServerSession = this.portrangeRtpServerSession
+                        .newRtcpSession( new InetSocketAddress( serverAddress,
+                                serverRtcpPort ) );
+            } else {
+                rtcpServerSession = RtcpServerService.getInstance().newSession(
+                        new InetSocketAddress( serverAddress, serverRtcpPort ) );
+            }
+        }
+        rtcpServerSession.write( packet.toByteBuffer() );
+    }
 
-		if ( rtpClientSession == null ) {
-			rtpClientSession = RtpClientService.getInstance().newSession(
-					new InetSocketAddress( clientAddress, clientRtpPort ) );
-		}
+    /**
+     * Forwards a RTP packet to client. The packet will be set to the address
+     * indicated by the client at RTP (even) port.
+     * &lt;p&gt;
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param packet
+     *            a RTP packet
+     */
+    public void forwardRtpToClient( RtpPacket packet )
+    {
+        // modify the SSRC for the client
+        packet.setSsrc( proxySSRC );
 
-		log.debug(&quot;forwarding RTP packet, SSRC=&quot; + packet.getSsrc() + &quot;, CSRC=&quot; + packet.getCsrc()
-				+ &quot;, client=&quot; + rtpClientSession.getRemoteAddress());
-		rtpClientSession.write( packet.toByteBuffer() );
-	}
+        if ( rtpClientSession == null ) {
+            rtpClientSession = RtpClientService.getInstance().newSession(
+                    new InetSocketAddress( clientAddress, clientRtpPort ) );
+        }
 
-	/**
-	 * Forwards a RTCP packet to client. The packet will be set to the address
-	 * indicated by the client at RTCP (odd) port.
-	 * &lt;p&gt;
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param packet
-	 *            a RTCP packet
-	 */
-	public void forwardRtcpToClient( RtcpPacket packet )
-	{
-		// modify the SSRC for the client
-		packet.setSsrc( proxySSRC );
+        /*
+        if ( log.isDebugEnabled() ) 
+            log.debug( &quot;forwarding RTP packet, SSRC=&quot; + packet.getSsrc() + &quot;, CSRC=&quot;
+                    + packet.getCsrc() + &quot;, client=&quot; + rtpClientSession.getRemoteAddress() );
+        */
+        rtpClientSession.write( packet.toByteBuffer() );
+    }
 
-		if ( rtcpClientSession == null ) {
-			rtcpClientSession = RtcpClientService.getInstance().newSession(
-					new InetSocketAddress( clientAddress, clientRtcpPort ) );
-		}
+    /**
+     * Forwards a RTCP packet to client. The packet will be set to the address
+     * indicated by the client at RTCP (odd) port.
+     * &lt;p&gt;
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param packet
+     *            a RTCP packet
+     */
+    public void forwardRtcpToClient( RtcpPacket packet )
+    {
+        // modify the SSRC for the client
+        packet.setSsrc( proxySSRC );
 
-		rtcpClientSession.write( packet.toByteBuffer() );
-	}
+        if ( rtcpClientSession == null ) {
+            rtcpClientSession = RtcpClientService.getInstance().newSession(
+                    new InetSocketAddress( clientAddress, clientRtcpPort ) );
+        }
 
-	/**
-	 * Set the address of the server associated with this track.
-	 * &lt;p&gt;
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param serverHost
-	 *            The serverHost to set.
-	 * @param rtpPort
-	 *            the port number used for RTP packets
-	 * @param rtcpPort
-	 *            the port number used for RTCP packets
-	 */
-	public synchronized void setClientAddress( InetAddress clientAddress, int rtpPort,
-			int rtcpPort )
-	{
-		this.clientAddress = clientAddress;
-		this.clientRtpPort = rtpPort;
-		this.clientRtcpPort = rtcpPort;
+        rtcpClientSession.write( packet.toByteBuffer() );
+    }
 
-		clientAddressMap.put( new InetSocketAddress( clientAddress, rtpPort ), this );
-		clientAddressMap.put( new InetSocketAddress( clientAddress, rtcpPort ), this );
-	}
+    /**
+     * Set the address of the server associated with this track.
+     * &lt;p&gt;
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param serverHost
+     *            The serverHost to set.
+     * @param rtpPort
+     *            the port number used for RTP packets
+     * @param rtcpPort
+     *            the port number used for RTCP packets
+     */
+    public synchronized void setClientAddress( InetAddress clientAddress, int rtpPort,
+            int rtcpPort )
+    {
+        this.clientAddress = clientAddress;
+        this.clientRtpPort = rtpPort;
+        this.clientRtcpPort = rtcpPort;
 
-	/**
-	 * Set the address of the server associated with this track.
-	 * 
-	 * @param serverHost
-	 *            The serverHost to set.
-	 * @param rtpPort
-	 *            the port number used for RTP packets
-	 * @param rtcpPort
-	 *            the port number used for RTCP packets
-	 */
-	public synchronized void setServerAddress( InetAddress serverAddress, int rtpPort,
-			int rtcpPort )
-	{
-		this.serverAddress = serverAddress;
-		this.serverRtpPort = rtpPort;
-		this.serverRtcpPort = rtcpPort;
+        clientAddressMap.put( new InetSocketAddress( clientAddress, rtpPort ), this );
+        clientAddressMap.put( new InetSocketAddress( clientAddress, rtcpPort ), this );
+    }
 
-		InetSocketAddress rtpSockAddr = new InetSocketAddress( serverAddress, rtpPort );
-		InetSocketAddress rtcpSockAddr = new InetSocketAddress( serverAddress, rtcpPort ); 
-		
-		serverAddressMap.put( rtpSockAddr, this );
-		serverAddressMap.put( rtcpSockAddr, this );
-		
-		if(this.portrangeRtpServerSession != null) {
-			localRemoteServerAddressMap.put(
-					new LocalRemoteAddressPair(this.portrangeRtpServerSession.getRtpSocketAddress(), rtpSockAddr), 
-					this);
-			localRemoteServerAddressMap.put(
-					new LocalRemoteAddressPair(this.portrangeRtpServerSession.getRtcpSocketAddress(), rtcpSockAddr), 
-					this);
-		}
-	}
+    /**
+     * Set the address of the server associated with this track.
+     * 
+     * @param serverHost
+     *            The serverHost to set.
+     * @param rtpPort
+     *            the port number used for RTP packets
+     * @param rtcpPort
+     *            the port number used for RTCP packets
+     */
+    public synchronized void setServerAddress( InetAddress serverAddress, int rtpPort,
+            int rtcpPort )
+    {
+        this.serverAddress = serverAddress;
+        this.serverRtpPort = rtpPort;
+        this.serverRtcpPort = rtcpPort;
 
-	public synchronized void close()
-	{
-		if ( serverSSRC != null )
-			serverSsrcMap.remove( serverSSRC );
-		
-		InetSocketAddress rtpSockAddr = new InetSocketAddress(serverAddress, serverRtpPort);
-		InetSocketAddress rtcpSockAddr = new InetSocketAddress(serverAddress, serverRtcpPort);
-		
-		serverAddressMap.remove( rtpSockAddr );
-		serverAddressMap.remove( rtcpSockAddr );
-		if(this.portrangeRtpServerSession != null) {
-			localRemoteServerAddressMap.remove(
-					new LocalRemoteAddressPair(this.portrangeRtpServerSession.getRtpSocketAddress(), rtpSockAddr));
-			localRemoteServerAddressMap.remove(
-					new LocalRemoteAddressPair(this.portrangeRtpServerSession.getRtcpSocketAddress(), rtcpSockAddr));
-		}		
-		
-		clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRtpPort ) );
-		clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRtcpPort ) );
+        InetSocketAddress rtpSockAddr = new InetSocketAddress( serverAddress, rtpPort );
+        InetSocketAddress rtcpSockAddr = new InetSocketAddress( serverAddress, rtcpPort );
 
-		if ( proxySSRC != null )
-			proxySsrcList.remove( proxySSRC );
-		log.debug( &quot;Closed track &quot; + url );
-	}
+        serverAddressMap.put( rtpSockAddr, this );
+        serverAddressMap.put( rtcpSockAddr, this );
 
-	// ////////////////
+        if ( this.portrangeRtpServerSession != null ) {
+            localRemoteServerAddressMap.put( new LocalRemoteAddressPair(
+                    this.portrangeRtpServerSession.getRtpSocketAddress(), rtpSockAddr ),
+                    this );
+            localRemoteServerAddressMap.put(
+                    new LocalRemoteAddressPair( this.portrangeRtpServerSession
+                            .getRtcpSocketAddress(), rtcpSockAddr ), this );
+        }
+    }
 
-	/** Used in SSRC id generation */
-	private static Random random = new Random();
+    @Override
+    public synchronized void close()
+    {
+        if ( serverSSRC != null )
+            serverSsrcMap.remove( serverSSRC );
 
-	/**
-	 * Creates a new SSRC id that is unique in the proxy.
-	 * 
-	 * @return the session ID
-	 */
-	private static String newSSRC()
-	{
-		long id;
-		while ( true ) {
-			id = random.nextLong() &amp; 0xFFFFFFFFL;
+        final InetSocketAddress rtpSockAddr = new InetSocketAddress( serverAddress,
+                serverRtpPort );
+        final InetSocketAddress rtcpSockAddr = new InetSocketAddress( serverAddress,
+                serverRtcpPort );
 
-			if ( !proxySsrcList.contains( id ) ) {
-				// Ok, the id is unique
-				String ids = Long.toString( id, 16 );
-				return ids;
-			}
-			// try with another id
-		}
-	}
+        serverAddressMap.remove( rtpSockAddr );
+        serverAddressMap.remove( rtcpSockAddr );
+        if ( this.portrangeRtpServerSession != null ) {
+            localRemoteServerAddressMap.remove( new LocalRemoteAddressPair(
+                    this.portrangeRtpServerSession.getRtpSocketAddress(), rtpSockAddr ) );
+            localRemoteServerAddressMap
+                    .remove( new LocalRemoteAddressPair( this.portrangeRtpServerSession
+                            .getRtcpSocketAddress(), rtcpSockAddr ) );
+        }
 
-	public void setPortrangeRtpServerSession(PortrangeRtpServerSession session) {
-		this.portrangeRtpServerSession = session;
-	}
+        clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRtpPort ) );
+        clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRtcpPort ) );
+
+        if ( proxySSRC != null )
+            proxySsrcList.remove( proxySSRC );
+        log.debug( &quot;Closed track {}&quot;, url );
+    }
+
+    // ////////////////
+
+    /** Used in SSRC id generation */
+    private static Random random = new Random();
+
+    /**
+     * Creates a new SSRC id that is unique in the proxy.
+     * 
+     * @return the session ID
+     */
+    private static String newSSRC()
+    {
+        long id;
+        while ( true ) {
+            id = random.nextLong() &amp; 0xFFFFFFFFL;
+
+            if ( !proxySsrcList.contains( id ) ) {
+                // Ok, the id is unique
+                String ids = Long.toString( id, 16 );
+                return ids;
+            }
+            // try with another id
+        }
+    }
+
+    public void setPortrangeRtpServerSession( PortrangeRtpServerSession session )
+    {
+        this.portrangeRtpServerSession = session;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -36,136 +36,151 @@
 public abstract class Track
 {
 
-	protected static class LocalRemoteAddressPair {
-		private InetSocketAddress local;
-		private InetSocketAddress remote;
-		
-		public LocalRemoteAddressPair(InetSocketAddress local, InetSocketAddress remote) {
-			this.local = local;
-			this.remote = remote;
-		}
+    protected static class LocalRemoteAddressPair
+    {
 
-		/* (non-Javadoc)
-		 * @see java.lang.Object#equals(java.lang.Object)
-		 */
-		@Override
-		public boolean equals(Object obj) {
-			boolean equal = false;
-			
-			if(obj instanceof LocalRemoteAddressPair) {
-				LocalRemoteAddressPair o = (LocalRemoteAddressPair)obj;
-				
-				equal = (this.local.equals(o.local) &amp;&amp; this.remote.equals(o.remote));
-			}
-			return equal;
-		}
+        private InetSocketAddress local;
 
-		/* (non-Javadoc)
-		 * @see java.lang.Object#hashCode()
-		 */
-		@Override
-		public int hashCode() {
-			return (this.local.hashCode() ^ this.remote.hashCode());
-		}
-		
-		
-	}
-	
-	protected static final String ATTR = Track.class.toString() + &quot;Attr&quot;;
+        private InetSocketAddress remote;
 
-	/** Maps a client address to a Track */
-	protected static Map&lt;InetSocketAddress, Track&gt; clientAddressMap = new ConcurrentHashMap&lt;InetSocketAddress, Track&gt;();
+        public LocalRemoteAddressPair( InetSocketAddress local, InetSocketAddress remote )
+        {
+            this.local = local;
+            this.remote = remote;
+        }
 
-	/** Maps a server address to a Track */
-	protected static Map&lt;InetSocketAddress, Track&gt; serverAddressMap = new ConcurrentHashMap&lt;InetSocketAddress, Track&gt;();
+        /*
+         * (non-Javadoc)
+         * 
+         * @see java.lang.Object#equals(java.lang.Object)
+         */
+        @Override
+        public boolean equals( Object obj )
+        {
+            boolean equal = false;
 
-	/** Maps a local server address/port and a remote address/port to a Track */
-	protected static Map&lt;LocalRemoteAddressPair, Track&gt; localRemoteServerAddressMap = 
-		new ConcurrentHashMap&lt;LocalRemoteAddressPair, Track&gt;();
-	
-	/**
-	 * Control Url of the track. This is the url handle given by the server to
-	 * control different tracks in a RTSP session.
-	 */
-	protected String url;
+            if ( obj instanceof LocalRemoteAddressPair ) {
+                LocalRemoteAddressPair o = (LocalRemoteAddressPair) obj;
 
-	/**
-	 * IP address of client and server.
-	 * &lt;p&gt;
-	 * TODO: When using reflection, there will be more than one connected client
-	 * at a time to the same Track. So the track should keep a list of connected
-	 * clients and forward packets to each of them.
-	 */
-	protected InetAddress clientAddress;
+                equal = (this.local.equals( o.local ) &amp;&amp; this.remote.equals( o.remote ));
+            }
+            return equal;
+        }
 
-	protected InetAddress serverAddress;
+        /*
+         * (non-Javadoc)
+         * 
+         * @see java.lang.Object#hashCode()
+         */
+        @Override
+        public int hashCode()
+        {
+            return (this.local.hashCode() ^ this.remote.hashCode());
+        }
 
-	/**
-	 * Construct a new Track.
-	 * 
-	 * @param url
-	 *            the control name for this track.
-	 */
-	public Track( String url )
-	{
-		this.url = url;
-	}
+    }
 
-	/**
-	 * Get the track by looking at client socket address.
-	 * 
-	 * @return a Track instance if a matching pair is found or null
-	 */
-	public static Track getByClientAddress( InetSocketAddress clientAddress )
-	{
-		return clientAddressMap.get( clientAddress );
-	}
+    protected static final String ATTR = Track.class.toString() + &quot;Attr&quot;;
 
-	/**
-	 * Get the track by looking at server socket address.
-	 * &lt;p&gt;
-	 * Used as a workaround for streaming servers which do not hand out a ssrc
-	 * in the setup handshake.
-	 * 
-	 * @return a Track instance if a matching pair is found or null
-	 */
-	public static Track getByServerAddress( InetSocketAddress serverAddress )
-	{
-		return serverAddressMap.get( serverAddress );
-	}
+    /** Maps a client address to a Track */
+    // TODO: bring back to protected
+    public static Map&lt;InetSocketAddress, Track&gt; clientAddressMap = new ConcurrentHashMap&lt;InetSocketAddress, Track&gt;();
 
-	/**
-	 * Get the track by looking at server socket address.
-	 * &lt;p&gt;
-	 * Used as a workaround for streaming servers which do not hand out a ssrc
-	 * in the setup handshake.
-	 * 
-	 * @return a Track instance if a matching pair is found or null
-	 */
-	public static Track getByLocalRemoteServerAddress( InetSocketAddress localServerAddress,
-			InetSocketAddress remoteServerAddress)
-	{
-		LocalRemoteAddressPair pair = new LocalRemoteAddressPair(localServerAddress, remoteServerAddress);
-		
-		return localRemoteServerAddressMap.get( pair );
-	}
+    /** Maps a server address to a Track */
+    protected static Map&lt;InetSocketAddress, Track&gt; serverAddressMap = new ConcurrentHashMap&lt;InetSocketAddress, Track&gt;();
 
-	// /// Member methods
+    /** Maps a local server address/port and a remote address/port to a Track */
+    protected static Map&lt;LocalRemoteAddressPair, Track&gt; localRemoteServerAddressMap = new ConcurrentHashMap&lt;LocalRemoteAddressPair, Track&gt;();
 
-	public String getUrl()
-	{
-		return url;
-	}
+    /**
+     * Control Url of the track. This is the url handle given by the server to
+     * control different tracks in a RTSP session.
+     */
+    protected String url;
 
-	public void setUrl( String url )
-	{
-		this.url = url;
-	}
+    /**
+     * IP address of client and server.
+     * &lt;p&gt;
+     * TODO: When using reflection, there will be more than one connected client
+     * at a time to the same Track. So the track should keep a list of connected
+     * clients and forward packets to each of them.
+     */
+    protected InetAddress clientAddress;
 
-	public abstract void close();
+    protected InetAddress serverAddress;
 
-	public String toString()
-	{
-		return &quot;Track(url=\&quot;&quot; + url + &quot;\&quot;&quot;;
-	}
+    /**
+     * Construct a new Track.
+     * 
+     * @param url
+     *            the control name for this track.
+     */
+    public Track( String url )
+    {
+        this.url = url;
+    }
+
+    /**
+     * Get the track by looking at client socket address.
+     * 
+     * @return a Track instance if a matching pair is found or null
+     */
+    public static Track getByClientAddress( InetSocketAddress clientAddress )
+    {
+        return clientAddressMap.get( clientAddress );
+    }
+
+    /**
+     * Get the track by looking at server socket address.
+     * &lt;p&gt;
+     * Used as a workaround for streaming servers which do not hand out a ssrc
+     * in the setup handshake.
+     * 
+     * @return a Track instance if a matching pair is found or null
+     */
+    public static Track getByServerAddress( InetSocketAddress serverAddress )
+    {
+        return serverAddressMap.get( serverAddress );
+    }
+
+    /**
+     * Get the track by looking at server socket address.
+     * &lt;p&gt;
+     * Used as a workaround for streaming servers which do not hand out a ssrc
+     * in the setup handshake.
+     * 
+     * @return a Track instance if a matching pair is found or null
+     */
+    public static Track getByLocalRemoteServerAddress(
+            InetSocketAddress localServerAddress, InetSocketAddress remoteServerAddress )
+    {
+        LocalRemoteAddressPair pair = new LocalRemoteAddressPair( localServerAddress,
+                remoteServerAddress );
+
+        return localRemoteServerAddressMap.get( pair );
+    }
+
+    // /// Member methods
+
+    public String getUrl()
+    {
+        return url;
+    }
+
+    public void setUrl( String url )
+    {
+        this.url = url;
+    }
+
+    public abstract void close();
+
+    @Override
+    public String toString()
+    {
+        StringBuilder sb = new StringBuilder();
+        sb.append( &quot;Track(url=\&quot;&quot; );
+        sb.append( url );
+        sb.append( &quot;\&quot;)&quot; );
+        return sb.toString();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -7,8 +7,6 @@
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.filter.codec.ProtocolCodecFilter;
 
-import rtspproxy.ProxyServiceRegistry;
-
 /**
  * Builds filter chain operating on RDT connection.
  * 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -191,7 +191,8 @@
 	/**
 	 * debug output
 	 */
-	public final String toString() {
+	@Override
+    public final String toString() {
 		StringBuffer buf = new StringBuffer();
 
 		buf.append(&quot;packet[id=&quot; + id +&quot; type=&quot; + type);

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,271 +3,286 @@
  */
 package rtspproxy.rdt;
 
-import java.lang.reflect.Array;
-
 import org.apache.mina.common.ByteBuffer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-
 /**
  * Decoder for RDT packets.
+ * 
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
  */
-public class RdtPacketDecoder {
+public class RdtPacketDecoder
+{
 
-	// logger
-	private static Logger logger = LoggerFactory.getLogger(RdtPacketDecoder.class);
-	
-	/**
-	 * not instaniable
-	 */
-	private RdtPacketDecoder() {}
-	
-	/**
-	 * decode packet
-	 * @param buffer the byte buffer to decode packet from
-	 */
-	public static RdtPacket decode(ByteBuffer buffer) {
-		byte[] data = new byte[buffer.limit()];
+    // logger
+    private static Logger log = LoggerFactory.getLogger( RdtPacketDecoder.class );
 
-		// copy buffer content into temp array
-		buffer.rewind();
-		buffer.get(data);
+    /**
+     * not instaniable
+     */
+    private RdtPacketDecoder()
+    {
+    }
 
-		return decode(data, 0);
-	}
+    /**
+     * decode packet
+     * 
+     * @param buffer
+     *            the byte buffer to decode packet from
+     */
+    public static RdtPacket decode( ByteBuffer buffer )
+    {
+        byte[] data = new byte[buffer.limit()];
 
-	/**
-	 * decode packet
-	 * @param buffer the byte buffer to decode packet from
-	 */
-	public static RdtPacket decode(byte[] data, int ind) {
-		RdtPacket packet = null;
-		byte markerByte;
-		byte seqLo, seqHi;
-		short sequence;
-		boolean lengthIncluded = false;
-		short packetLength = -1;
-		int payloadSize = -1;
+        // copy buffer content into temp array
+        buffer.rewind();
+        buffer.get( data );
 
-		/*
-		if(logger.isDebugEnabled()) 
-			logger.debug(&quot;decoding packet data: &quot; + formatByteArray(data));
-		*/
-		
-		// process marker byte
-		markerByte = data[ind++];
-		lengthIncluded = ((markerByte &amp; (1&lt;&lt;7)) &gt; 0);
+        return decode( data, 0 );
+    }
 
-		// process sequence / type field
-		seqHi = data[ind++];
-		seqLo = data[ind++];
-		sequence = decodeShort(seqHi, seqLo);
-		logger.debug(&quot;decoded sequence: &quot; + Integer.toHexString(sequence));
-		
-		if((seqHi &amp; 0xff) == 0xff ) {
-			logger.debug(&quot;decoding control packet&quot;);
+    /**
+     * decode packet
+     * 
+     * @param buffer
+     *            the byte buffer to decode packet from
+     */
+    public static RdtPacket decode( byte[] data, int ind )
+    {
+        RdtPacket packet = null;
+        byte markerByte;
+        byte seqLo, seqHi;
+        short sequence;
+        boolean lengthIncluded = false;
+        short packetLength = -1;
+        int payloadSize = -1;
 
-			// extract streamid from marker byte
-			byte streamId = (byte)((markerByte &amp; 0x7c) &gt;&gt; 2);
+        /*
+         * if(logger.isDebugEnabled()) logger.debug(&quot;decoding packet data: {}&quot;,
+         * formatByteArray(data));
+         */
 
-			// control packet
-			RdtPacket.Type type = RdtPacket.Type.fromCode(sequence);
-			
-			switch(type) {
-			case RttRequest:
-				// process packet length (if included)
-				if(lengthIncluded) {
-					packetLength = (short)(decodeShort(data, ind) - 5);
-					ind += 2;
-				}
-				
-				packet = new RdtRttRequestPacket();
-				break;
-			case RttResponse:
-				// process packet length (if included)
-				if(lengthIncluded) {
-					packetLength = (short)(decodeShort(data, ind) - 5);
-					ind += 2;
-				}
-				
-				int roundtripTimestampSeconds = decodeInt(data, ind);
-				int roundtripTimestampMicroeconds = decodeInt(data, ind+4);
-				
-				ind += 8;
-				packet = new RdtRttResponsePacket(roundtripTimestampSeconds, roundtripTimestampMicroeconds);
-				
-				payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
-				
-				if(payloadSize &gt; 0)
-					ind = attachPayload(packet, data, ind, payloadSize);
-				
-				break;
-			case LatencyReport:
-				// process packet length (if included)
-				if(lengthIncluded) {
-					packetLength = (short)(decodeShort(data, ind) - 5);
-					ind += 2;
-				}
-				
-				int serverTimeout = decodeInt(data, ind);
-				ind += 4;
-				if(lengthIncluded)
-					packetLength -= 4;
-				packet = new RdtLatencyReportPacket(serverTimeout);
-				break;
-			case Ack:
-				// process packet length (if included)
-				if(lengthIncluded) {
-					packetLength = (short)(decodeShort(data, ind) -  5);
-					ind += 2;
-				}
-				
-				boolean lostHigh = ((markerByte &amp; (1&lt;&lt;6)) &gt; 0);
-				payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
+        // process marker byte
+        markerByte = data[ind++];
+        lengthIncluded = ((markerByte &amp; (1 &lt;&lt; 7)) &gt; 0);
 
-				packet = new RdtAckPacket(lostHigh);
-				if(payloadSize &gt; 0)
-					ind = attachPayload(packet, data, ind, payloadSize);
-				
-				break;
-			case StreamEnd:
-				// in the stream end packet, the length-included serves as need reliable field
-				boolean packetSent = ((markerByte &amp; (1&lt;&lt;1)) &gt; 0);
-				boolean extFlag = ((markerByte &amp; (1&lt;&lt;0)) &gt; 0);
-				short streamEndSequenceNumber = decodeShort(data, ind);
-				int timeout = decodeInt(data, ind+2);
-				short totalReliable = decodeShort(data, ind+6);
-				
-				ind += 8;
-				
-				// length included servers as need reliable (speical case)
-				packet = new RdtStreamEndPacket(lengthIncluded, streamId, packetSent, extFlag, 
-						streamEndSequenceNumber, timeout, totalReliable);
-				
-				payloadSize = (data.length - ind);
-				if(payloadSize &gt; 0)
-					ind = attachPayload(packet, data, ind, payloadSize);
-				break;
-			default:
-				logger.error(&quot;unknown control packet received, code=&quot; + sequence 
-						+ &quot;, full packet dump: &quot; + formatByteArray(data));
-			}
-		} else {
-			logger.debug(&quot;decoding data packet&quot;);
-			
-			// data packet
-			// process packet length (if included)
-			if(lengthIncluded) {
-				packetLength = (short)(decodeShort(data, ind) - 5);
-				ind += 2;
-			}
-			
-			// process marker byte
-			boolean needReliable = ((markerByte &amp; (1&lt;&lt;6)) &gt; 0);
-			boolean isReliable = ((markerByte &amp; (1&lt;&lt;0)) &gt; 0);
-			byte streamId = (byte)((markerByte &amp; 0x3e) &gt;&gt; 1);
-			
-			// process next control byte
-			if(lengthIncluded)
-				packetLength--;
-			byte controlByte = data[ind++];
-			boolean backToBack = ((controlByte &amp; (1&lt;&lt;7)) &gt; 0);
-			boolean slowData = ((controlByte &amp; (1&lt;&lt;6)) &gt; 0);
-			byte asmRule = (byte)(controlByte &amp; 0x3f);
-			
-			// process timestamp
-			if(lengthIncluded)
-				packetLength -= 4;
-			int timestamp = decodeInt(data, ind);
-			ind += 4;
-			
-			// process total reliable count
-			/*
-			if(lengthIncluded)
-				packetLength -= 2;
-				*/
-			packet = new RdtDataPacket(lengthIncluded, needReliable, isReliable, streamId,
-					sequence, backToBack, slowData, asmRule, timestamp);
-			if(needReliable) {
-				short totalReliable = decodeShort(data, ind);
+        // process sequence / type field
+        seqHi = data[ind++];
+        seqLo = data[ind++];
+        sequence = decodeShort( seqHi, seqLo );
+        log.debug( &quot;decoded sequence: {}&quot;, Integer.toHexString( sequence ) );
 
-				ind += 2;
-				if(lengthIncluded)
-					packetLength -= 2;
-				((RdtDataPacket)packet).setTotalReliable(totalReliable);
-			}
+        if ( (seqHi &amp; 0xff) == 0xff ) {
+            log.debug( &quot;decoding control packet&quot; );
 
-			payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
-			if(payloadSize &gt; 0)
-				ind = attachPayload(packet, data, ind, payloadSize);
-		}
-		
-		if(ind != data.length) {
-			// handle attached subpacket
-			logger.debug(&quot;handling attached sub-packet&quot;);
-			
-			packet.setSubPacket(decode(data, ind));
-		}
-		
-		if(logger.isDebugEnabled())
-			logger.debug(&quot;decoded packet: &quot; + packet);
-		
-		return packet;
-	}
-	
-	/**
-	 * attach payload to packet
-	 */
-	private static int attachPayload(RdtPacket packet, byte[] data, int ind, int size) {
-		byte[] buf = new byte[size];
-		
-		System.arraycopy(data, ind, buf, 0, size);
-		packet.setPayload(buf);
-		
-		return (ind + size);
-	}
-	
-	/**
-	 * decode a short from a byte array
-	 */
-	private static final short decodeShort(byte[] bytes, int ind) {
-		return decodeShort(bytes[ind], bytes[ind+1]);
-	}
+            // extract streamid from marker byte
+            byte streamId = (byte) ((markerByte &amp; 0x7c) &gt;&gt; 2);
 
-	private static final short decodeShort(byte hi, byte lo) {
-		return (short)((hi &amp; 0xff) * 256 + (lo &amp; 0xff));
-	}
-	
-	/**
-	 * decode an int 
-	 */
-	private static final int decodeInt(byte[] bytes, int ind) {
-		return decodeInt(bytes[ind], bytes[ind+1], bytes[ind+2], bytes[ind+3]);
-	}
-	
-	private static final int decodeInt(byte b3, byte b2, byte b1, byte b0) {
-		return ((b3 &amp; 0xff) * 16777216) + ((b2 &amp; 0xff) * 65536) + ((b1 &amp; 0xff) * 256) + (b0 &amp; 0xff);
-	}
+            // control packet
+            RdtPacket.Type type = RdtPacket.Type.fromCode( sequence );
 
-	private static final char[] digits = new char[] { 
-		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
-		'a', 'b', 'c', 'd', 'e', 'f'
-	};
-	private static final String formatByteArray(byte[] data) {
-		StringBuffer buf = new StringBuffer();
-		
-		for(int i=0; i&lt;data.length; i++) {
-			if((i % 16) == 0)
-				buf.append('\n');
-			
-			buf.append(digits[(data[i] &amp; 0xff) / 16]);
-			buf.append(digits[(data[i] &amp; 0xff) % 16]);
-			if((i % 16) != 0)
-				buf.append(' ');
-		}
- 		
-		return buf.toString();
-	}
+            switch ( type )
+            {
+            case RttRequest:
+                // process packet length (if included)
+                if ( lengthIncluded ) {
+                    packetLength = (short) (decodeShort( data, ind ) - 5);
+                    ind += 2;
+                }
+
+                packet = new RdtRttRequestPacket();
+                break;
+            case RttResponse:
+                // process packet length (if included)
+                if ( lengthIncluded ) {
+                    packetLength = (short) (decodeShort( data, ind ) - 5);
+                    ind += 2;
+                }
+
+                int roundtripTimestampSeconds = decodeInt( data, ind );
+                int roundtripTimestampMicroeconds = decodeInt( data, ind + 4 );
+
+                ind += 8;
+                packet = new RdtRttResponsePacket( roundtripTimestampSeconds,
+                        roundtripTimestampMicroeconds );
+
+                payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
+
+                if ( payloadSize &gt; 0 )
+                    ind = attachPayload( packet, data, ind, payloadSize );
+
+                break;
+            case LatencyReport:
+                // process packet length (if included)
+                if ( lengthIncluded ) {
+                    packetLength = (short) (decodeShort( data, ind ) - 5);
+                    ind += 2;
+                }
+
+                int serverTimeout = decodeInt( data, ind );
+                ind += 4;
+                if ( lengthIncluded )
+                    packetLength -= 4;
+                packet = new RdtLatencyReportPacket( serverTimeout );
+                break;
+            case Ack:
+                // process packet length (if included)
+                if ( lengthIncluded ) {
+                    packetLength = (short) (decodeShort( data, ind ) - 5);
+                    ind += 2;
+                }
+
+                boolean lostHigh = ((markerByte &amp; (1 &lt;&lt; 6)) &gt; 0);
+                payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
+
+                packet = new RdtAckPacket( lostHigh );
+                if ( payloadSize &gt; 0 )
+                    ind = attachPayload( packet, data, ind, payloadSize );
+
+                break;
+            case StreamEnd:
+                // in the stream end packet, the length-included serves as need
+                // reliable field
+                boolean packetSent = ((markerByte &amp; (1 &lt;&lt; 1)) &gt; 0);
+                boolean extFlag = ((markerByte &amp; (1 &lt;&lt; 0)) &gt; 0);
+                short streamEndSequenceNumber = decodeShort( data, ind );
+                int timeout = decodeInt( data, ind + 2 );
+                short totalReliable = decodeShort( data, ind + 6 );
+
+                ind += 8;
+
+                // length included servers as need reliable (speical case)
+                packet = new RdtStreamEndPacket( lengthIncluded, streamId, packetSent,
+                        extFlag, streamEndSequenceNumber, timeout, totalReliable );
+
+                payloadSize = (data.length - ind);
+                if ( payloadSize &gt; 0 )
+                    ind = attachPayload( packet, data, ind, payloadSize );
+                break;
+            default:
+                log.error(
+                        &quot;unknown control packet received, code={}, full packet dump: {}&quot;,
+                        sequence, formatByteArray( data ) );
+            }
+        } else {
+            log.debug( &quot;decoding data packet&quot; );
+
+            // data packet
+            // process packet length (if included)
+            if ( lengthIncluded ) {
+                packetLength = (short) (decodeShort( data, ind ) - 5);
+                ind += 2;
+            }
+
+            // process marker byte
+            boolean needReliable = ((markerByte &amp; (1 &lt;&lt; 6)) &gt; 0);
+            boolean isReliable = ((markerByte &amp; (1 &lt;&lt; 0)) &gt; 0);
+            byte streamId = (byte) ((markerByte &amp; 0x3e) &gt;&gt; 1);
+
+            // process next control byte
+            if ( lengthIncluded )
+                packetLength--;
+            byte controlByte = data[ind++];
+            boolean backToBack = ((controlByte &amp; (1 &lt;&lt; 7)) &gt; 0);
+            boolean slowData = ((controlByte &amp; (1 &lt;&lt; 6)) &gt; 0);
+            byte asmRule = (byte) (controlByte &amp; 0x3f);
+
+            // process timestamp
+            if ( lengthIncluded )
+                packetLength -= 4;
+            int timestamp = decodeInt( data, ind );
+            ind += 4;
+
+            // process total reliable count
+            /*
+             * if(lengthIncluded) packetLength -= 2;
+             */
+            packet = new RdtDataPacket( lengthIncluded, needReliable, isReliable,
+                    streamId, sequence, backToBack, slowData, asmRule, timestamp );
+            if ( needReliable ) {
+                short totalReliable = decodeShort( data, ind );
+
+                ind += 2;
+                if ( lengthIncluded )
+                    packetLength -= 2;
+                ((RdtDataPacket) packet).setTotalReliable( totalReliable );
+            }
+
+            payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
+            if ( payloadSize &gt; 0 )
+                ind = attachPayload( packet, data, ind, payloadSize );
+        }
+
+        if ( ind != data.length ) {
+            // handle attached subpacket
+            log.debug( &quot;handling attached sub-packet&quot; );
+
+            packet.setSubPacket( decode( data, ind ) );
+        }
+
+        log.debug( &quot;decoded packet: {}&quot;, packet );
+
+        return packet;
+    }
+
+    /**
+     * attach payload to packet
+     */
+    private static int attachPayload( RdtPacket packet, byte[] data, int ind, int size )
+    {
+        byte[] buf = new byte[size];
+
+        System.arraycopy( data, ind, buf, 0, size );
+        packet.setPayload( buf );
+
+        return (ind + size);
+    }
+
+    /**
+     * decode a short from a byte array
+     */
+    private static final short decodeShort( byte[] bytes, int ind )
+    {
+        return decodeShort( bytes[ind], bytes[ind + 1] );
+    }
+
+    private static final short decodeShort( byte hi, byte lo )
+    {
+        return (short) ((hi &amp; 0xff) * 256 + (lo &amp; 0xff));
+    }
+
+    /**
+     * decode an int
+     */
+    private static final int decodeInt( byte[] bytes, int ind )
+    {
+        return decodeInt( bytes[ind], bytes[ind + 1], bytes[ind + 2], bytes[ind + 3] );
+    }
+
+    private static final int decodeInt( byte b3, byte b2, byte b1, byte b0 )
+    {
+        return ((b3 &amp; 0xff) * 16777216) + ((b2 &amp; 0xff) * 65536) + ((b1 &amp; 0xff) * 256)
+                + (b0 &amp; 0xff);
+    }
+
+    private static final char[] digits = new char[] { '0', '1', '2', '3', '4', '5', '6',
+            '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+    private static final String formatByteArray( byte[] data )
+    {
+        StringBuffer buf = new StringBuffer();
+
+        for ( int i = 0; i &lt; data.length; i++ ) {
+            if ( (i % 16) == 0 )
+                buf.append( '\n' );
+
+            buf.append( digits[(data[i] &amp; 0xff) / 16] );
+            buf.append( digits[(data[i] &amp; 0xff) % 16] );
+            if ( (i % 16) != 0 )
+                buf.append( ' ' );
+        }
+
+        return buf.toString();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -9,165 +9,184 @@
 import javax.management.ObjectName;
 
 import org.apache.mina.common.IoSession;
+import org.apache.mina.transport.socket.nio.DatagramAcceptor;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import rtspproxy.transport.socket.nio.DatagramAcceptor;
-
 /**
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
- *
+ * 
  */
-public class PortrangeRtpServerSession {
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory
-			.getLogger(PortrangeRtpServerSession.class);
-		
-	// session attribute name
-	public static final String ATTR = PortrangeRtpServerSession.class.getName() + &quot;.ATTR&quot;;
-	
-	// connection number
-	private int connectionNumber;
-	
-	// flag if session is passive
-	private boolean activeIfTrue;
-	
-	// time when object was passivated
-	private long lastPassiveCheckpoint; 
-	
-	// RTP acceptor
-	private DatagramAcceptor rtpAcceptor;
-	
-	// RTP socket address
-	private InetSocketAddress rtpSockAddr;
-	
-	// RCTP acceptor
-	private DatagramAcceptor rtcpAcceptor;
-	
-	// RTCP socket address
-	private InetSocketAddress rtcpSockAddr;
-	
-	// opened sessions
-	private LinkedList&lt;IoSession&gt; openSessions = new LinkedList&lt;IoSession&gt;();
-	
-	// MBean name
-	private ObjectName objectName;
-	
-	/**
-	 * create a sever session
-	 */
-	PortrangeRtpServerSession(int conNum) {
-		this.connectionNumber = conNum;
-	}
+public class PortrangeRtpServerSession
+{
 
-	public void setLocalBinding(DatagramAcceptor rtpAcceptor, InetSocketAddress rtpSockAddr, 
-			DatagramAcceptor rtcpAcceptor, InetSocketAddress rtcpSockAddr) {
-		this.rtpAcceptor = rtpAcceptor;
-		this.rtpSockAddr = rtpSockAddr;
-		this.rtcpAcceptor = rtcpAcceptor;
-		this.rtcpSockAddr = rtcpSockAddr;
-	}
-	
-	/**
-	 * get the RTP port number
-	 */
-	public int getRtpPort() {
-		return this.rtpSockAddr.getPort();
-	}
+    /**
+     * Logger for this class
+     */
+    private static Logger log = LoggerFactory.getLogger( PortrangeRtpServerSession.class );
 
-	/**
-	 * get the RTP port number
-	 */
-	public int getRtcpPort() {
-		return this.rtcpSockAddr.getPort();
-	}
+    // session attribute name
+    public static final String ATTR = PortrangeRtpServerSession.class.getName() + &quot;.ATTR&quot;;
 
-	/**
-	 * get the connection number
-	 */
-	public int getConnectionNumber() {
-		return this.connectionNumber;
-	}
+    // connection number
+    private int connectionNumber;
 
-	void unbind() {
-		this.rtpAcceptor.unbind(this.rtpSockAddr);
-		this.rtcpAcceptor.unbind(this.rtcpSockAddr);
-	}
+    // flag if session is passive
+    private boolean activeIfTrue;
 
-	void closeOpenSessions() {
-			for (IoSession session : this.openSessions)
-			session.close();
-		this.openSessions.clear();
-	}
-	
-	public IoSession newRtpSession(InetSocketAddress remote) {
-		IoSession session = this.rtpAcceptor.newSession(remote, this.rtpSockAddr);
-		
-		logger.debug(&quot;opened new RTP session to &quot; + remote);
-		this.openSessions.add(session);
-		
-		return session;
-	}
+    // time when object was passivated
+    private long lastPassiveCheckpoint;
 
-	public IoSession newRtcpSession(InetSocketAddress remote) {
-		IoSession session = this.rtcpAcceptor.newSession(remote, this.rtcpSockAddr);
+    // RTP acceptor
+    private DatagramAcceptor rtpAcceptor;
 
-		logger.debug(&quot;opened new RTCP session to &quot; + remote);
-		this.openSessions.add(session);
-		
-		return session;
-	}
+    // RTP socket address
+    private InetSocketAddress rtpSockAddr;
 
-	void setActive(boolean state) {
-		this.activeIfTrue = state;
-		
-		if(!this.activeIfTrue)
-			this.lastPassiveCheckpoint = System.currentTimeMillis();
-	}
+    // RCTP acceptor
+    private DatagramAcceptor rtcpAcceptor;
 
-	/**
-	 * @return Returns the lastPassiveCheckpoint.
-	 */
-	public long getLastPassiveCheckpoint() {
-		return lastPassiveCheckpoint;
-	}
+    // RTCP socket address
+    private InetSocketAddress rtcpSockAddr;
 
-	public boolean isActive() {
-		return this.activeIfTrue;
-	}
+    // opened sessions
+    private LinkedList&lt;IoSession&gt; openSessions = new LinkedList&lt;IoSession&gt;();
 
-	/**
-	 * @return Returns the rtpSockAddr.
-	 */
-	public InetSocketAddress getRtpSocketAddress() {
-		return rtpSockAddr;
-	}
+    // MBean name
+    private ObjectName objectName;
 
-	/**
-	 * @return Returns the rtpSockAddr.
-	 */
-	public InetSocketAddress getRtcpSocketAddress() {
-		return rtcpSockAddr;
-	}
+    /**
+     * create a sever session
+     */
+    PortrangeRtpServerSession( int conNum )
+    {
+        this.connectionNumber = conNum;
+    }
 
-	/**
-	 * @return Returns the objectName.
-	 */
-	public ObjectName getObjectName() {
-		return objectName;
-	}
+    public void setLocalBinding( DatagramAcceptor rtpAcceptor,
+            InetSocketAddress rtpSockAddr, DatagramAcceptor rtcpAcceptor,
+            InetSocketAddress rtcpSockAddr )
+    {
+        this.rtpAcceptor = rtpAcceptor;
+        this.rtpSockAddr = rtpSockAddr;
+        this.rtcpAcceptor = rtcpAcceptor;
+        this.rtcpSockAddr = rtcpSockAddr;
+    }
 
-	/**
-	 * @param objectName The objectName to set.
-	 */
-	public void setObjectName(ObjectName objectName) {
-		this.objectName = objectName;
-	}
+    /**
+     * get the RTP port number
+     */
+    public int getRtpPort()
+    {
+        return this.rtpSockAddr.getPort();
+    }
 
-	public int getNumOpenSessions() {
-		return this.openSessions.size();
-	}
+    /**
+     * get the RTP port number
+     */
+    public int getRtcpPort()
+    {
+        return this.rtcpSockAddr.getPort();
+    }
 
+    /**
+     * get the connection number
+     */
+    public int getConnectionNumber()
+    {
+        return this.connectionNumber;
+    }
+
+    void unbind()
+    {
+        this.rtpAcceptor.unbind( this.rtpSockAddr );
+        this.rtcpAcceptor.unbind( this.rtcpSockAddr );
+    }
+
+    void closeOpenSessions()
+    {
+        for ( IoSession session : this.openSessions )
+            session.close();
+        this.openSessions.clear();
+    }
+
+    public IoSession newRtpSession( InetSocketAddress remote )
+    {
+        IoSession session = this.rtpAcceptor.newSession( remote, this.rtpSockAddr );
+
+        log.debug( &quot;opened new RTP session to {}&quot;, remote );
+        this.openSessions.add( session );
+
+        return session;
+    }
+
+    public IoSession newRtcpSession( InetSocketAddress remote )
+    {
+        IoSession session = this.rtcpAcceptor.newSession( remote, this.rtcpSockAddr );
+
+        log.debug( &quot;opened new RTCP session to {}&quot;, remote );
+        this.openSessions.add( session );
+
+        return session;
+    }
+
+    void setActive( boolean state )
+    {
+        this.activeIfTrue = state;
+
+        if ( !this.activeIfTrue )
+            this.lastPassiveCheckpoint = System.currentTimeMillis();
+    }
+
+    /**
+     * @return Returns the lastPassiveCheckpoint.
+     */
+    public long getLastPassiveCheckpoint()
+    {
+        return lastPassiveCheckpoint;
+    }
+
+    public boolean isActive()
+    {
+        return this.activeIfTrue;
+    }
+
+    /**
+     * @return Returns the rtpSockAddr.
+     */
+    public InetSocketAddress getRtpSocketAddress()
+    {
+        return rtpSockAddr;
+    }
+
+    /**
+     * @return Returns the rtpSockAddr.
+     */
+    public InetSocketAddress getRtcpSocketAddress()
+    {
+        return rtcpSockAddr;
+    }
+
+    /**
+     * @return Returns the objectName.
+     */
+    public ObjectName getObjectName()
+    {
+        return objectName;
+    }
+
+    /**
+     * @param objectName
+     *            The objectName to set.
+     */
+    public void setObjectName( ObjectName objectName )
+    {
+        this.objectName = objectName;
+    }
+
+    public int getNumOpenSessions()
+    {
+        return this.openSessions.size();
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -5,11 +5,9 @@
 
 import java.io.IOException;
 import java.net.InetAddress;
-import java.util.NoSuchElementException;
 import java.util.Observable;
 import java.util.Observer;
 
-import org.apache.commons.pool.PoolableObjectFactory;
 import org.apache.commons.pool.impl.GenericObjectPool;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -21,144 +19,165 @@
 
 /**
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
- *
+ * 
  */
-public class PortrangeRtpServerSessionFactory extends Singleton implements Observer {
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory
-			.getLogger(PortrangeRtpServerSessionFactory.class);
-	
-	// connection pool
-	private GenericObjectPool pool;
-	
-	// local addr
-	private InetAddress localAddress;
-	
-	/**
-	 * constructor 
-	 */
-	public PortrangeRtpServerSessionFactory() {
-		
-	}
-	
-	/**
-	 * get the singleton instance
-	 */
-	public static PortrangeRtpServerSessionFactory getInstance() {
-		return (PortrangeRtpServerSessionFactory)Singleton.getInstance(PortrangeRtpServerSessionFactory.class);
-	}
-	
-	/**
-	 * get a RTP server session
-	 */
-	public PortrangeRtpServerSession getSession() throws IOException {
-		try {
-			return (PortrangeRtpServerSession)this.pool.borrowObject();
-		} catch(Exception e) {
-			logger.info(&quot;failed to obtain RTP server session&quot;, e);
-			
-			throw new IOException(&quot;cant obtain RTP server session&quot;);
-		}
-	}
-	
-	/**
-	 * release a server session
-	 */
-	public void releaseSession(PortrangeRtpServerSession session) {
-		try {
-			session.closeOpenSessions();
-			this.pool.returnObject(session);
-		} catch(Exception e) {
-			logger.info(&quot;failed to release session&quot;, e);
-		}
-	}
-	
-	/**
-	 * initialise the factory
-	 */
-	public void start() throws Exception {
-		if(Config.proxyServerRtpMultiplePorts.getValue()) {
-			int minPort = Config.proxyServerRtpMinPort.getValue();
-			int maxPort = Config.proxyServerRtpMaxPort.getValue();
-			int rtpSessionIdleTimeout = Config.proxyServerRtpIdleTimeout.getValue();
-			int poolSize = Config.proxyServerRtpThreadPoolSize.getValue();
-			int idleScanInterval = Config.proxyServerRtpIdleScanInterval.getValue() * 1000;
-			
-			if(minPort &lt;= 0 || minPort &gt;= 65536)
-				throw new IllegalArgumentException(&quot;RTP min port out of range: &quot; + minPort);
-			if(maxPort &lt;= 0 || maxPort &gt;= 65536)
-				throw new IllegalArgumentException(&quot;RTP max port out of range: &quot; + maxPort);
-			
-			minPort = minPort + (minPort % 2);
-			maxPort = maxPort - (maxPort % 2);
-			logger.debug(&quot;RTP min port=&quot; + minPort + &quot;, max port=&quot; + maxPort);
-			
-			if(minPort &gt;= maxPort)
-				throw new IllegalArgumentException(&quot;RTP min port too high, min=&quot; + minPort + &quot;, max=&quot; + maxPort);
-			int maxConn = (maxPort -minPort) / 2;
-			
-			GenericObjectPool.Config config = new GenericObjectPool.Config();
-			
-			config.maxActive = maxConn;
-			config.maxIdle = maxConn / 2;
-			config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
-			config.testOnBorrow = false;
-			config.testOnReturn = false;
-			config.testWhileIdle = true;
-			config.minEvictableIdleTimeMillis = rtpSessionIdleTimeout*1000;
-			config.timeBetweenEvictionRunsMillis = idleScanInterval;
-			
-			this.pool = new GenericObjectPool(new RtpServerSessionFactory(this.localAddress, minPort, maxConn,
-					rtpSessionIdleTimeout, poolSize), config);
-			
-			Config.proxyServerRtpIdleScanInterval.addObserver(this);
-			Config.proxyServerRtpIdleTimeout.addObserver(this);
-			
-			JmxAgent.getInstance().registerPortRangeRtpServerSessionfactory(this);
-		}
-	}
-	
-	/**
-	 * shutdown the session factory
-	 */
-	public void stop() {
-		if(Config.proxyServerRtpMultiplePorts.getValue()) {
-			try {
-				this.pool.close();
-			} catch(Exception e) {
-				logger.info(&quot;exception while closing RTP port pool&quot;, e);
-			}
-			
-			JmxAgent.getInstance().unregisterPortRangeRtpServerSessionfactory();
-		}		
-	}
+public class PortrangeRtpServerSessionFactory extends Singleton implements Observer
+{
 
-	public void setLocalAddress(InetAddress address) {
-		this.localAddress = address;
-	}
+    /**
+     * Logger for this class
+     */
+    private final Logger log = LoggerFactory
+            .getLogger( PortrangeRtpServerSessionFactory.class );
 
-	public void update(Observable o, Object arg) {
-		if(o instanceof Parameter) {
-			Parameter p = (Parameter)o;
-			
-			if(p.equals(Config.proxyServerRtpIdleScanInterval))
-				this.pool.setTimeBetweenEvictionRunsMillis(Config.proxyServerRtpIdleScanInterval.getValue());
-			else if(p.equals(Config.proxyServerRtpIdleTimeout))
-				this.pool.setMinEvictableIdleTimeMillis(Config.proxyServerRtpIdleTimeout.getValue() * 1000);
-		}
-	}
+    // connection pool
+    private GenericObjectPool pool;
 
-	public int getMaxConnections() {
-		return this.pool.getMaxActive();
-	}
+    // local addr
+    private InetAddress localAddress;
 
-	public int getCurrentIdleConnections() {
-		return this.pool.getNumIdle();
-	}
+    /**
+     * constructor
+     */
+    public PortrangeRtpServerSessionFactory()
+    {
 
-	public int getCurrentActiveConnections() {
-		return this.pool.getNumActive();
-	}
+    }
+
+    /**
+     * get the singleton instance
+     */
+    public static PortrangeRtpServerSessionFactory getInstance()
+    {
+        return (PortrangeRtpServerSessionFactory) Singleton
+                .getInstance( PortrangeRtpServerSessionFactory.class );
+    }
+
+    /**
+     * get a RTP server session
+     */
+    public PortrangeRtpServerSession getSession() throws IOException
+    {
+        try {
+            return (PortrangeRtpServerSession) this.pool.borrowObject();
+        } catch ( Exception e ) {
+            log.info( &quot;failed to obtain RTP server session&quot;, e );
+
+            throw new IOException( &quot;cant obtain RTP server session&quot; );
+        }
+    }
+
+    /**
+     * release a server session
+     */
+    public void releaseSession( PortrangeRtpServerSession session )
+    {
+        try {
+            session.closeOpenSessions();
+            this.pool.returnObject( session );
+        } catch ( Exception e ) {
+            log.info( &quot;failed to release session&quot;, e );
+        }
+    }
+
+    /**
+     * initialise the factory
+     */
+    public void start() throws Exception
+    {
+        if ( Config.proxyServerRtpMultiplePorts.getValue() ) {
+            int minPort = Config.proxyServerRtpMinPort.getValue();
+            int maxPort = Config.proxyServerRtpMaxPort.getValue();
+            int rtpSessionIdleTimeout = Config.proxyServerRtpIdleTimeout.getValue();
+            int poolSize = Config.proxyServerRtpThreadPoolSize.getValue();
+            int idleScanInterval = Config.proxyServerRtpIdleScanInterval.getValue() * 1000;
+
+            if ( minPort &lt;= 0 || minPort &gt;= 65536 )
+                throw new IllegalArgumentException( &quot;RTP min port out of range: &quot;
+                        + minPort );
+            if ( maxPort &lt;= 0 || maxPort &gt;= 65536 )
+                throw new IllegalArgumentException( &quot;RTP max port out of range: &quot;
+                        + maxPort );
+
+            minPort = minPort + (minPort % 2);
+            maxPort = maxPort - (maxPort % 2);
+            log.debug( &quot;RTP min port={}, max port={}&quot;, minPort, maxPort );
+
+            if ( minPort &gt;= maxPort )
+                throw new IllegalArgumentException( &quot;RTP min port too high, min=&quot;
+                        + minPort + &quot;, max=&quot; + maxPort );
+            int maxConn = (maxPort - minPort) / 2;
+
+            GenericObjectPool.Config config = new GenericObjectPool.Config();
+
+            config.maxActive = maxConn;
+            config.maxIdle = maxConn / 2;
+            config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
+            config.testOnBorrow = false;
+            config.testOnReturn = false;
+            config.testWhileIdle = true;
+            config.minEvictableIdleTimeMillis = rtpSessionIdleTimeout * 1000;
+            config.timeBetweenEvictionRunsMillis = idleScanInterval;
+
+            this.pool = new GenericObjectPool(
+                    new RtpServerSessionFactory( this.localAddress, minPort, maxConn,
+                            rtpSessionIdleTimeout, poolSize ), config );
+
+            Config.proxyServerRtpIdleScanInterval.addObserver( this );
+            Config.proxyServerRtpIdleTimeout.addObserver( this );
+
+            JmxAgent.getInstance().registerPortRangeRtpServerSessionfactory( this );
+        }
+    }
+
+    /**
+     * shutdown the session factory
+     */
+    public void stop()
+    {
+        if ( Config.proxyServerRtpMultiplePorts.getValue() ) {
+            try {
+                this.pool.close();
+            } catch ( Exception e ) {
+                log.info( &quot;exception while closing RTP port pool&quot;, e );
+            }
+
+            JmxAgent.getInstance().unregisterPortRangeRtpServerSessionfactory();
+        }
+    }
+
+    public void setLocalAddress( InetAddress address )
+    {
+        this.localAddress = address;
+    }
+
+    public void update( Observable o, Object arg )
+    {
+        if ( o instanceof Parameter ) {
+            Parameter p = (Parameter) o;
+
+            if ( p.equals( Config.proxyServerRtpIdleScanInterval ) )
+                this.pool
+                        .setTimeBetweenEvictionRunsMillis( Config.proxyServerRtpIdleScanInterval
+                                .getValue() );
+            else if ( p.equals( Config.proxyServerRtpIdleTimeout ) )
+                this.pool.setMinEvictableIdleTimeMillis( Config.proxyServerRtpIdleTimeout
+                        .getValue() * 1000 );
+        }
+    }
+
+    public int getMaxConnections()
+    {
+        return this.pool.getMaxActive();
+    }
+
+    public int getCurrentIdleConnections()
+    {
+        return this.pool.getNumIdle();
+    }
+
+    public int getCurrentActiveConnections()
+    {
+        return this.pool.getNumActive();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,9 +3,6 @@
  */
 package rtspproxy.rtp.range;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -14,173 +11,189 @@
 import java.util.Observer;
 
 import org.apache.commons.pool.PoolableObjectFactory;
+import org.apache.mina.transport.socket.nio.DatagramAcceptor;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;
 import rtspproxy.jmx.JmxAgent;
 import rtspproxy.proxy.ServerRtcpPacketHandler;
 import rtspproxy.proxy.ServerRtpPacketHandler;
-import rtspproxy.transport.socket.nio.DatagramAcceptor;
-import sun.security.krb5.internal.s;
 
 /**
  * @author Rainer Bieniek (<A HREF="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">Rainer.Bieniek at vodafone.com</A>)
  */
-class RtpServerSessionFactory implements PoolableObjectFactory, Observer {
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory
-			.getLogger(RtpServerSessionFactory.class);
+class RtpServerSessionFactory implements PoolableObjectFactory, Observer
+{
 
-	// local bind address
-	private InetAddress localAddress;
-	
-	// mark used connections
-	private BitSet usedConnections;
-	
-	// base port (RTP)
-	private int basePort;
-	
-	// max connections
-	private int maxConnections;
-	
-	// RTP acceptor
-	private DatagramAcceptor rtpAcceptor = new DatagramAcceptor();
-	
-	// RTCP acceptor
-	private DatagramAcceptor rtcpAcceptor = new DatagramAcceptor();
+    /**
+     * Logger for this class
+     */
+    private static Logger log = LoggerFactory.getLogger( RtpServerSessionFactory.class );
 
-	// Filter chain builder
-	private RtpRtcpFilterChainBuilder chainBuilder = new RtpRtcpFilterChainBuilder();
-	
-	private long idleTimeout;
+    // local bind address
+    private InetAddress localAddress;
 
-	/**
-	 * constructor
-	 * @param address 
-	 * @param maxConn 
-	 */
-	RtpServerSessionFactory(InetAddress address, int basePort, int maxConn, long idleTimeout, int threadPoolSize) {
-		this.localAddress = address;
-		this.usedConnections = new BitSet(maxConn);
-		this.maxConnections = maxConn;
-		this.basePort = basePort;
-		this.idleTimeout = idleTimeout;
+    // mark used connections
+    private BitSet usedConnections;
 
-		this.chainBuilder.setPoolSize(threadPoolSize);
-		this.rtpAcceptor.setFilterChainBuilder(this.chainBuilder);
-		this.rtcpAcceptor.setFilterChainBuilder(this.chainBuilder);
-		
-		Config.proxyServerRtpThreadPoolSize.addObserver(this);
-		Config.proxyServerRtpIdleTimeout.addObserver(this);
-	}
+    // base port (RTP)
+    private int basePort;
 
-	public Object makeObject() throws Exception {
-		PortrangeRtpServerSession serverSession = null;
-		int nextCon = 0;
+    // max connections
+    private int maxConnections;
 
-		do {
-			nextCon = this.usedConnections.nextClearBit(0);
-			logger.debug(&quot;found next free slot at &quot; + nextCon);
-			
-			if(nextCon &gt;= this.maxConnections) {
-				logger.debug(&quot;failed to allocate a free slot&quot;);
-				throw new IOException(&quot;no local ports available&quot;);
-			}
-			int rtpPort = this.basePort + 2*nextCon;
-			
-			this.usedConnections.set(nextCon);
-			serverSession = new PortrangeRtpServerSession(nextCon);
-			
-			// try to bind local ports
-			InetSocketAddress rtpSockAddr = new InetSocketAddress(this.localAddress, rtpPort);
-			InetSocketAddress rtcpSockAddr = new InetSocketAddress(this.localAddress, rtpPort+1);
-			
-			boolean rtpBound = false;
-			boolean rtcpBound = false;
-			
-			try {
-				this.rtpAcceptor.bind(rtpSockAddr, new ServerRtpPacketHandler());
-				rtpBound = true;
-			} catch(IOException ie) {
-				logger.info(&quot;failed to bind RTP socket &quot; + rtpSockAddr, ie);
-			}
-			try {
-				this.rtcpAcceptor.bind(rtcpSockAddr, new ServerRtcpPacketHandler());
-				rtcpBound = true;
-			} catch(IOException ie) {
-				logger.info(&quot;failed to bind RTCP socket &quot; + rtpSockAddr, ie);
-			}
-			if(rtpBound == false || rtcpBound == false) {
-				logger.debug(&quot;failed to allocate RTP/RTCP port port&quot;);
-				
-				serverSession = null;
-				if(rtpBound) {
-					this.rtpAcceptor.unbind(rtpSockAddr);
-				}
-				if(rtcpBound) {
-					this.rtcpAcceptor.unbind(rtcpSockAddr);
-				}
-			} else {
-				logger.debug(&quot;allocated local port pair&quot;);
-				
-				serverSession.setLocalBinding(this.rtpAcceptor, rtpSockAddr, this.rtcpAcceptor, rtcpSockAddr);
-			}
-			
-		} while(serverSession == null);
-		
-		JmxAgent.getInstance().registerPortrangeRtpServerSession(serverSession);
-		
-		return serverSession;
-	}
+    // RTP acceptor
+    private DatagramAcceptor rtpAcceptor = new DatagramAcceptor();
 
-	public void destroyObject(Object arg0) throws Exception {
-		PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession)arg0;
-		int conNumber = serverSession.getConnectionNumber();
-		
-		logger.debug(&quot;destroying connection &quot; + conNumber);
-		serverSession.unbind();
-		JmxAgent.getInstance().unregisterPortrangeRtpServerSession(serverSession);
-		this.usedConnections.clear(conNumber);
-	}
+    // RTCP acceptor
+    private DatagramAcceptor rtcpAcceptor = new DatagramAcceptor();
 
-	public boolean validateObject(Object arg0) {
-		boolean valid = true;
-		PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession)arg0;
-		long checkPoint = System.currentTimeMillis();
-		
-		logger.debug(&quot;checking validity for connection &quot; + serverSession.getConnectionNumber());
-		if(!serverSession.isActive() 
-				&amp;&amp; (checkPoint - serverSession.getLastPassiveCheckpoint()) &gt; (1000*this.idleTimeout)) {
-			logger.debug(&quot;connection &quot; + serverSession.getConnectionNumber() + &quot; timed out&quot;);
-			valid = false;
-		}
-		
-		return valid;
-	}
+    // Filter chain builder
+    private RtpRtcpFilterChainBuilder chainBuilder = new RtpRtcpFilterChainBuilder();
 
-	public void activateObject(Object arg0) throws Exception {
-		PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession)arg0;
-		
-		serverSession.setActive(true);
-	}
+    private long idleTimeout;
 
-	public void passivateObject(Object arg0) throws Exception {
-		PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession)arg0;
-		
-		serverSession.closeOpenSessions();
-		serverSession.setActive(false);
-	}
+    /**
+     * constructor
+     * 
+     * @param address
+     * @param maxConn
+     */
+    RtpServerSessionFactory( InetAddress address, int basePort, int maxConn,
+            long idleTimeout, int threadPoolSize )
+    {
+        this.localAddress = address;
+        this.usedConnections = new BitSet( maxConn );
+        this.maxConnections = maxConn;
+        this.basePort = basePort;
+        this.idleTimeout = idleTimeout;
 
-	public void update(Observable o, Object arg) {
-		if(o instanceof Parameter) {
-			Parameter p = (Parameter)o;
-			
-			if(p.equals(Config.proxyServerRtpThreadPoolSize))
-				this.chainBuilder.setPoolSize(Config.proxyServerRtpThreadPoolSize.getValue());
-			else if(p.equals(Config.proxyServerRtpIdleTimeout))
-				this.idleTimeout = Config.proxyServerRtpIdleTimeout.getValue();
-		}
-	}
+        this.chainBuilder.setPoolSize( threadPoolSize );
+        this.rtpAcceptor.setFilterChainBuilder( this.chainBuilder );
+        this.rtcpAcceptor.setFilterChainBuilder( this.chainBuilder );
+
+        Config.proxyServerRtpThreadPoolSize.addObserver( this );
+        Config.proxyServerRtpIdleTimeout.addObserver( this );
+    }
+
+    public Object makeObject() throws Exception
+    {
+        PortrangeRtpServerSession serverSession = null;
+        int nextCon = 0;
+
+        do {
+            nextCon = this.usedConnections.nextClearBit( 0 );
+            log.debug( &quot;found next free slot at {}&quot;, nextCon );
+
+            if ( nextCon &gt;= this.maxConnections ) {
+                log.debug( &quot;failed to allocate a free slot&quot; );
+                throw new IOException( &quot;no local ports available&quot; );
+            }
+            int rtpPort = this.basePort + 2 * nextCon;
+
+            this.usedConnections.set( nextCon );
+            serverSession = new PortrangeRtpServerSession( nextCon );
+
+            // try to bind local ports
+            InetSocketAddress rtpSockAddr = new InetSocketAddress( this.localAddress,
+                    rtpPort );
+            InetSocketAddress rtcpSockAddr = new InetSocketAddress( this.localAddress,
+                    rtpPort + 1 );
+
+            boolean rtpBound = false;
+            boolean rtcpBound = false;
+
+            try {
+                this.rtpAcceptor.bind( rtpSockAddr, new ServerRtpPacketHandler() );
+                rtpBound = true;
+            } catch ( IOException ie ) {
+                log.info( &quot;failed to bind RTP socket {}: {}&quot;, rtpSockAddr, ie );
+            }
+            try {
+                this.rtcpAcceptor.bind( rtcpSockAddr, new ServerRtcpPacketHandler() );
+                rtcpBound = true;
+            } catch ( IOException ie ) {
+                log.info( &quot;failed to bind RTCP socket {}: {}&quot;, rtpSockAddr, ie );
+            }
+            if ( rtpBound == false || rtcpBound == false ) {
+                log.debug( &quot;failed to allocate RTP/RTCP port port&quot; );
+
+                serverSession = null;
+                if ( rtpBound ) {
+                    this.rtpAcceptor.unbind( rtpSockAddr );
+                }
+                if ( rtcpBound ) {
+                    this.rtcpAcceptor.unbind( rtcpSockAddr );
+                }
+            } else {
+                log.debug( &quot;allocated local port pair&quot; );
+
+                serverSession.setLocalBinding( this.rtpAcceptor, rtpSockAddr,
+                        this.rtcpAcceptor, rtcpSockAddr );
+            }
+
+        } while ( serverSession == null );
+
+        JmxAgent.getInstance().registerPortrangeRtpServerSession( serverSession );
+
+        return serverSession;
+    }
+
+    public void destroyObject( Object arg0 ) throws Exception
+    {
+        PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession) arg0;
+        int conNumber = serverSession.getConnectionNumber();
+
+        log.debug( &quot;destroying connection {}&quot;, conNumber );
+        serverSession.unbind();
+        JmxAgent.getInstance().unregisterPortrangeRtpServerSession( serverSession );
+        this.usedConnections.clear( conNumber );
+    }
+
+    public boolean validateObject( Object arg0 )
+    {
+        boolean valid = true;
+        PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession) arg0;
+        long checkPoint = System.currentTimeMillis();
+
+        log.debug( &quot;checking validity for connection &quot;
+                + serverSession.getConnectionNumber() );
+        if ( !serverSession.isActive()
+                &amp;&amp; (checkPoint - serverSession.getLastPassiveCheckpoint()) &gt; (1000 * this.idleTimeout) ) {
+            log.debug( &quot;connection {} timed out&quot;, serverSession.getConnectionNumber() );
+            valid = false;
+        }
+
+        return valid;
+    }
+
+    public void activateObject( Object arg0 ) throws Exception
+    {
+        PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession) arg0;
+
+        serverSession.setActive( true );
+    }
+
+    public void passivateObject( Object arg0 ) throws Exception
+    {
+        PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession) arg0;
+
+        serverSession.closeOpenSessions();
+        serverSession.setActive( false );
+    }
+
+    public void update( Observable o, Object arg )
+    {
+        if ( o instanceof Parameter ) {
+            Parameter p = (Parameter) o;
+
+            if ( p.equals( Config.proxyServerRtpThreadPoolSize ) )
+                this.chainBuilder.setPoolSize( Config.proxyServerRtpThreadPoolSize
+                        .getValue() );
+            else if ( p.equals( Config.proxyServerRtpIdleTimeout ) )
+                this.idleTimeout = Config.proxyServerRtpIdleTimeout.getValue();
+        }
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspCode.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspCode.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspCode.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -102,12 +102,12 @@
 	{
 		if ( description != null )
 			return description;
-		else 
-			return name();
+		
+		return name();
 	}
 	
 	/**
-	 * Try to translare a numeric RTSP status code to
+	 * Try to translate a numeric RTSP status code to
 	 * the corresponding enum value.
 	 * 
 	 * @param strCode numeric code (as a string)

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspDecoder.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspDecoder.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspDecoder.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -14,7 +14,6 @@
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
-import java.io.LineNumberReader;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.nio.CharBuffer;
@@ -22,13 +21,13 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.ByteBuffer;
 import org.apache.mina.common.IoSession;
 import org.apache.mina.filter.codec.ProtocolDecoder;
 import org.apache.mina.filter.codec.ProtocolDecoderException;
 import org.apache.mina.filter.codec.ProtocolDecoderOutput;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.config.Config;
 import rtspproxy.lib.Exceptions;
@@ -39,270 +38,273 @@
 public class RtspDecoder implements ProtocolDecoder
 {
 
-	private static final String readStateATTR = RtspDecoder.class.toString()
-			+ &quot;readState&quot;;
-	private static final String rtspMessageATTR = RtspDecoder.class.toString()
-			+ &quot;rtspMessage&quot;;
+    private static final String readStateATTR = RtspDecoder.class.toString()
+            + &quot;readState&quot;;
 
-	/**
-	 * State enumerator that indicates the reached state in the RTSP message
-	 * decoding process.
-	 */
-	public enum ReadState {
-		/** Unrecoverable error occurred */
-		Failed,
-		/** Trying to resync */
-		Sync,
-		/** Waiting for a command */
-		Ready,
-		/** Reading interleaved packet */
-		Packet,
-		/** Reading command (request or command line) */
-		Command,
-		/** Reading headers */
-		Header,
-		/** Reading body (entity) */
-		Body,
-		/** Fully formed message */
-		Dispatch
-	}
+    private static final String rtspMessageATTR = RtspDecoder.class.toString()
+            + &quot;rtspMessage&quot;;
 
-	private static Logger log = LoggerFactory.getLogger( RtspDecoder.class );
+    /**
+     * State enumerator that indicates the reached state in the RTSP message
+     * decoding process.
+     */
+    public enum ReadState {
+        /** Unrecoverable error occurred */
+        Failed,
+        /** Trying to resync */
+        Sync,
+        /** Waiting for a command */
+        Ready,
+        /** Reading interleaved packet */
+        Packet,
+        /** Reading command (request or command line) */
+        Command,
+        /** Reading headers */
+        Header,
+        /** Reading body (entity) */
+        Body,
+        /** Fully formed message */
+        Dispatch
+    }
 
-	private static final Pattern rtspRequestPattern = Pattern.compile( &quot;([A-Z_]+) ([^ ]+) RTSP/1.0&quot; );
-	private static final Pattern rtspResponsePattern = Pattern.compile( &quot;RTSP/1.0 ([0-9]+) .+&quot; );
-	private static final Pattern rtspHeaderPattern = Pattern.compile( &quot;([a-zA-Z\\-]+[0-9]?):\\s?(.*)&quot; );
-	private static final Pattern spaceRtspHeaderPattern = Pattern.compile( &quot;([a-zA-Z\\-]+[0-9]?)\\s?:\\s?(.*)&quot; );
+    private static Logger log = LoggerFactory.getLogger( RtspDecoder.class );
 
-	private static final Charset asciiCharset = Charset.forName( &quot;US-ASCII&quot; );
+    private static final Pattern rtspRequestPattern = Pattern
+            .compile( &quot;([A-Z_]+) ([^ ]+) RTSP/1.0&quot; );
 
-	/**
-	 * Do the parsing on the incoming stream. If the stream does not contain the
-	 * entire RTSP message wait for other data to arrive, before dispatching the
-	 * message.
-	 * 
-	 * @see org.apache.mina.protocol.ProtocolDecoder#decode(org.apache.mina.protocol.IoSession,
-	 *      org.apache.mina.common.ByteBuffer,
-	 *      org.apache.mina.protocol.ProtocolDecoderOutput)
-	 */
-	public void decode( IoSession session, ByteBuffer buffer, ProtocolDecoderOutput out )
-			throws ProtocolDecoderException
-	{
-		BufferedReader reader = null;
+    private static final Pattern rtspResponsePattern = Pattern
+            .compile( &quot;RTSP/1.0 ([0-9]+) .+&quot; );
 
-		reader = new BufferedReader(new InputStreamReader( buffer.asInputStream(),
-				asciiCharset ), 2048 );
+    private static final Pattern rtspHeaderPattern = Pattern
+            .compile( &quot;([a-zA-Z\\-]+[0-9]?):\\s?(.*)&quot; );
 
-		// Retrieve status from session
-		ReadState state = (ReadState) session.getAttribute( readStateATTR );
-		RtspMessage rtspMessage = (RtspMessage) session.getAttribute( rtspMessageATTR );
-		log.debug(&quot;entered RTSP decode, state=&quot; + state + &quot;, rtsp message in session=&quot; + rtspMessageATTR);
-		
-		try {
+    private static final Pattern spaceRtspHeaderPattern = Pattern
+            .compile( &quot;([a-zA-Z\\-]+[0-9]?)\\s?:\\s?(.*)&quot; );
 
-			while ( true ) {
-				/*
-				if ( state != ReadState.Command &amp;&amp; state != ReadState.Header )
-					// the &quot;while&quot; loop is only used to read commands and
-					// headers
-					break;
-					*/
+    private static final Charset asciiCharset = Charset.forName( &quot;US-ASCII&quot; );
 
-				reader.mark(2048);
-				String line = reader.readLine();
-				if ( line == null ) {
-					// there's no more data in the buffer
-					log.debug(&quot;seen end-of-message, leaving loop&quot;);
-					break;					
-				}
-				
-				if ( state == null ) {
-					log.debug(&quot;switching null-state to Command&quot;);
-					state = ReadState.Command;
-				}
+    /**
+     * Do the parsing on the incoming stream. If the stream does not contain the
+     * entire RTSP message wait for other data to arrive, before dispatching the
+     * message.
+     * 
+     * @see org.apache.mina.protocol.ProtocolDecoder#decode(org.apache.mina.protocol.IoSession,
+     *      org.apache.mina.common.ByteBuffer,
+     *      org.apache.mina.protocol.ProtocolDecoderOutput)
+     */
+    public void decode( IoSession session, ByteBuffer buffer, ProtocolDecoderOutput out )
+            throws ProtocolDecoderException
+    {
+        BufferedReader reader = null;
 
-				if ( line.length() == 0 ) {
-					// This is the empty line that marks the end
-					// of the headers section
-					if(rtspMessage != null) {
-						log.debug(&quot;seen emtpy line, switching to Body&quot;);
-						state = ReadState.Body;
-						reader.mark(64);
-					} else {
-						log.debug(&quot;seen emtpy line, switching to Sync&quot;);
-						state = ReadState.Sync;						
-					}
-					// break;
-				}
+        reader = new BufferedReader( new InputStreamReader( buffer.asInputStream(),
+                asciiCharset ), 2048 );
 
-				switch (state) {
-				case Sync:
-					log.debug(&quot;found empty line between command, switching to Command&quot;);
-					state = ReadState.Command;
-					break;
-				case Command:
-					log.debug(&quot;Command line: &quot; + line);
-					if (line.startsWith(&quot;RTSP&quot;)) {
-						// this is a RTSP response
-						Matcher m = rtspResponsePattern.matcher(line);
-						if (!m.matches())
-							throw new ProtocolDecoderException(
-									&quot;Malformed response line: &quot; + line);
+        // Retrieve status from session
+        ReadState state = (ReadState) session.getAttribute( readStateATTR );
+        RtspMessage rtspMessage = (RtspMessage) session.getAttribute( rtspMessageATTR );
+        
+        log.debug( &quot;entered RTSP decode, state={}, rtsp message in session={}&quot;, state,
+                rtspMessageATTR );
 
-						RtspCode code = RtspCode.fromString(m.group(1));
-						rtspMessage = new RtspResponse();
-						((RtspResponse) (rtspMessage)).setCode(code);
-						RtspRequest.Verb verb = (RtspRequest.Verb) session
-								.getAttribute(RtspMessage.lastRequestVerbATTR);
-						((RtspResponse) (rtspMessage)).setRequestVerb(verb);
+        try {
 
-					} else {
-						// this is a RTSP request
-						Matcher m = rtspRequestPattern.matcher(line);
-						if (!m.matches())
-							throw new ProtocolDecoderException(
-									&quot;Malformed request line: &quot; + line);
+            while ( true ) {
+                /*
+                 * if ( state != ReadState.Command &amp;&amp; state != ReadState.Header ) //
+                 * the &quot;while&quot; loop is only used to read commands and // headers
+                 * break;
+                 */
 
-						String verb = m.group(1);
-						String strUrl = m.group(2);
-						URL url = null;
-						if (!strUrl.equalsIgnoreCase(&quot;*&quot;)) {
-							try {
-								url = new URL(strUrl);
-							} catch (MalformedURLException e) {
-								log.info(&quot;malformed URL: &quot; + url, e);
-								url = null;
-								session.setAttribute(readStateATTR,
-										ReadState.Failed);
-								throw new ProtocolDecoderException(
-										&quot;Invalid URL&quot;);
-							}
-						}
-						rtspMessage = new RtspRequest();
-						((RtspRequest) rtspMessage).setVerb(verb);
+                reader.mark( 2048 );
+                String line = reader.readLine();
+                if ( line == null ) {
+                    // there's no more data in the buffer
+                    log.debug( &quot;seen end-of-message, leaving loop&quot; );
+                    break;
+                }
 
-						if (((RtspRequest) rtspMessage).getVerb() == RtspRequest.Verb.None) {
-							session.setAttribute(readStateATTR,
-									ReadState.Failed);
-							throw new ProtocolDecoderException(
-									&quot;Invalid method: &quot; + verb);
-						}
+                if ( state == null ) {
+                    log.debug( &quot;switching null-state to Command&quot; );
+                    state = ReadState.Command;
+                }
 
-						((RtspRequest) rtspMessage).setUrl(url);
-					}
-					state = ReadState.Header;
-					log.debug(&quot;switching from Command to Header, message=&quot;
-							+ rtspMessage);
-					break;
+                if ( line.length() == 0 ) {
+                    // This is the empty line that marks the end
+                    // of the headers section
+                    if ( rtspMessage != null ) {
+                        log.debug( &quot;seen emtpy line, switching to Body&quot; );
+                        state = ReadState.Body;
+                        reader.mark( 64 );
+                    } else {
+                        log.debug( &quot;seen emtpy line, switching to Sync&quot; );
+                        state = ReadState.Sync;
+                    }
+                    // break;
+                }
 
-				case Header:
-					// this is an header
-					log.debug(&quot;Header line: &quot; + line);
-					Matcher m = rtspHeaderPattern.matcher(line);
+                switch ( state )
+                {
+                case Sync:
+                    log.debug( &quot;found empty line between command, switching to Command&quot; );
+                    state = ReadState.Command;
+                    break;
+                case Command:
+                    log.debug( &quot;Command line: {}&quot;, line );
+                    if ( line.startsWith( &quot;RTSP&quot; ) ) {
+                        // this is a RTSP response
+                        Matcher m = rtspResponsePattern.matcher( line );
+                        if ( !m.matches() )
+                            throw new ProtocolDecoderException(
+                                    &quot;Malformed response line: &quot; + line );
 
-					if (!m.matches()) {
-						if(Config.proxyRtspAllowBrokenHeaders.getValue()) {
-							Matcher m2 = spaceRtspHeaderPattern.matcher(line);
-							
-							if(!m2.matches()) {
-								throw new ProtocolDecoderException(
-										&quot;RTSP header not valid, line=&quot; + line);								
-							} else
-								rtspMessage.setHeader(m2.group(1), m2.group(2));
-						} else {
-							throw new ProtocolDecoderException(
-							&quot;RTSP header not valid, line=&quot; + line);
-						}
-					} else
-						rtspMessage.setHeader(m.group(1), m.group(2));
-					
-					break;
-				case Body:
-					int bufferLen = Integer.parseInt(rtspMessage.getHeader(
-							&quot;Content-Length&quot;, &quot;0&quot;));
+                        RtspCode code = RtspCode.fromString( m.group( 1 ) );
+                        rtspMessage = new RtspResponse();
+                        ((RtspResponse) (rtspMessage)).setCode( code );
+                        RtspRequest.Verb verb = (RtspRequest.Verb) session
+                                .getAttribute( RtspMessage.lastRequestVerbATTR );
+                        ((RtspResponse) (rtspMessage)).setRequestVerb( verb );
 
-					if (bufferLen == 0) {
-						log.debug(&quot;no message body found, switching to Dispatch&quot;);
-						// there's no buffer to be read
-						state = ReadState.Dispatch;
+                    } else {
+                        // this is a RTSP request
+                        Matcher m = rtspRequestPattern.matcher( line );
+                        if ( !m.matches() )
+                            throw new ProtocolDecoderException(
+                                    &quot;Malformed request line: &quot; + line );
 
-					} else {
-						// we have a content buffer to read
-						int bytesToRead = bufferLen
-								- rtspMessage.getBufferSize();
+                        String verb = m.group( 1 );
+                        String strUrl = m.group( 2 );
+                        URL url = null;
+                        if ( !strUrl.equalsIgnoreCase( &quot;*&quot; ) ) {
+                            try {
+                                url = new URL( strUrl );
+                            } catch ( MalformedURLException e ) {
+                                log.info( &quot;malformed URL {}&quot;, url );
+                                url = null;
+                                session.setAttribute( readStateATTR, ReadState.Failed );
+                                throw new ProtocolDecoderException( &quot;Invalid URL&quot; );
+                            }
+                        }
+                        rtspMessage = new RtspRequest();
+                        ((RtspRequest) rtspMessage).setVerb( verb );
 
-						// if ( bytesToRead &lt; reader. decodeBuf.length() ) {
-						// log.warn( &quot;We are reading more bytes than
-						// Content-Length.&quot; );
-						// }
+                        if ( ((RtspRequest) rtspMessage).getVerb() == RtspRequest.Verb.None ) {
+                            session.setAttribute( readStateATTR, ReadState.Failed );
+                            throw new ProtocolDecoderException( &quot;Invalid method: &quot; + verb );
+                        }
 
-						// read the content buffer
-						CharBuffer bufferContent = CharBuffer
-								.allocate(bytesToRead);
-						reader.reset();
-						reader.read(bufferContent);
-						bufferContent.flip();
-						rtspMessage.appendToBuffer(bufferContent);
-						
-						// this is an ugly hack to avoid content underruns produced by bogus servers
-						if( rtspMessage.getBufferSize() == (bufferLen - 2))
-							rtspMessage.appendToBuffer(&quot;\r\n&quot;);
-						if( rtspMessage.getBufferSize() == (bufferLen - 1))
-							rtspMessage.appendToBuffer(&quot;\n&quot;);
-						
-						// terminate message here
-						if (rtspMessage.getBufferSize() &gt;= bufferLen) {
-							// The RTSP message parsing is completed
-							state = ReadState.Dispatch;
-						}
-					}
-					break;
-				}
-				if ( state == ReadState.Dispatch ) {
-					log.debug(&quot;sending decoded RTSP message&quot;);
-					// The message is already formed
-					// send it
-					session.removeAttribute( readStateATTR );
-					session.removeAttribute( rtspMessageATTR );
-					out.write( rtspMessage );
-					
-					state = null;
-					rtspMessage = null;
-				}
+                        ((RtspRequest) rtspMessage).setUrl( url );
+                    }
+                    state = ReadState.Header;
+                    log.debug( &quot;switching from Command to Header, message={}&quot;,
+                            rtspMessage );
+                    break;
 
-			}
-		} catch ( IOException e ) {
-			/*
-			 * error on input stream should not happen since the input stream is
-			 * coming from a bytebuffer.
-			 */
-			Exceptions.logStackTrace( e );
-			return;
-		} catch( Throwable t) {
-			Exceptions.logStackTrace( t );
-			return;
-		} finally {
-			try {
-				reader.close();
-			} catch ( Exception e ) {
-			}
-		}
+                case Header:
+                    // this is an header
+                    log.debug( &quot;Header line: {}&quot;, line );
+                    Matcher m = rtspHeaderPattern.matcher( line );
 
-		// log.debug( &quot;INCOMPLETE MESSAGE \n&quot; + rtspMessage );
+                    if ( !m.matches() ) {
+                        if ( Config.proxyRtspAllowBrokenHeaders.getValue() ) {
+                            Matcher m2 = spaceRtspHeaderPattern.matcher( line );
 
-		// Save attributes in session
-		log.debug(&quot;leaving decode loop, state=&quot; + state + &quot;, message in session=&quot; + rtspMessage);
-		session.setAttribute( readStateATTR, state );
-		session.setAttribute( rtspMessageATTR, rtspMessage );
-	}
+                            if ( !m2.matches() ) {
+                                throw new ProtocolDecoderException(
+                                        &quot;RTSP header not valid, line=&quot; + line );
+                            }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.mina.filter.codec.ProtocolDecoder#dispose(org.apache.mina.common.IoSession)
-	 */
-	public void dispose( IoSession session ) throws Exception
-	{
-		// Do nothing
-	}
+                            rtspMessage.setHeader( m2.group( 1 ), m2.group( 2 ) );
+
+                        } else {
+                            throw new ProtocolDecoderException(
+                                    &quot;RTSP header not valid, line=&quot; + line );
+                        }
+                    } else
+                        rtspMessage.setHeader( m.group( 1 ), m.group( 2 ) );
+
+                    break;
+                case Body:
+                    int bufferLen = Integer.parseInt( rtspMessage.getHeader(
+                            &quot;Content-Length&quot;, &quot;0&quot; ) );
+
+                    if ( bufferLen == 0 ) {
+                        log.debug( &quot;no message body found, switching to Dispatch&quot; );
+                        // there's no buffer to be read
+                        state = ReadState.Dispatch;
+
+                    } else {
+                        // we have a content buffer to read
+                        int bytesToRead = bufferLen - rtspMessage.getBufferSize();
+
+                        // read the content buffer
+                        CharBuffer bufferContent = CharBuffer.allocate( bytesToRead );
+                        reader.reset();
+                        reader.read( bufferContent );
+                        bufferContent.flip();
+                        rtspMessage.appendToBuffer( bufferContent );
+
+                        // this is an ugly hack to avoid content underruns
+                        // produced by bogus servers
+                        if ( rtspMessage.getBufferSize() == (bufferLen - 2) )
+                            rtspMessage.appendToBuffer( &quot;\r\n&quot; );
+                        if ( rtspMessage.getBufferSize() == (bufferLen - 1) )
+                            rtspMessage.appendToBuffer( &quot;\n&quot; );
+
+                        // terminate message here
+                        if ( rtspMessage.getBufferSize() &gt;= bufferLen ) {
+                            // The RTSP message parsing is completed
+                            state = ReadState.Dispatch;
+                        }
+                    }
+                    break;
+                }
+                if ( state == ReadState.Dispatch ) {
+                    log.debug( &quot;sending decoded RTSP message&quot; );
+                    // The message is already formed
+                    // send it
+                    session.removeAttribute( readStateATTR );
+                    session.removeAttribute( rtspMessageATTR );
+                    out.write( rtspMessage );
+
+                    state = null;
+                    rtspMessage = null;
+                }
+
+            }
+        } catch ( IOException e ) {
+            /*
+             * error on input stream should not happen since the input stream is
+             * coming from a bytebuffer.
+             */
+            Exceptions.logStackTrace( e );
+            return;
+        } catch ( Throwable t ) {
+            Exceptions.logStackTrace( t );
+            return;
+        } finally {
+            try {
+                reader.close();
+            } catch ( Exception e ) {
+            }
+        }
+
+        // log.debug( &quot;INCOMPLETE MESSAGE \n{}&quot;, rtspMessage );
+
+        // Save attributes in session
+        log.debug( &quot;leaving decode loop, state={}, message in session={}&quot;, state,
+                rtspMessage );
+        session.setAttribute( readStateATTR, state );
+        session.setAttribute( rtspMessageATTR, rtspMessage );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.filter.codec.ProtocolDecoder#dispose(org.apache.mina.common.IoSession)
+     */
+    public void dispose( IoSession session ) throws Exception
+    {
+        // Do nothing
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspMessage.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspMessage.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspMessage.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -34,257 +34,260 @@
 public abstract class RtspMessage
 {
 
-	public static final String lastRequestVerbATTR = RtspMessage.class.toString()
-			+ &quot;lastRequestVerb&quot;;
+    public static final String lastRequestVerbATTR = RtspMessage.class.toString()
+            + &quot;lastRequestVerb&quot;;
 
-	/**
-	 * RTSP Message Type
-	 */
-	public enum Type {
-		/** Generic message (internal use) */
-		TypeNone,
-		/** Request message */
-		TypeRequest,
-		/** Response message */
-		TypeResponse
-	};
+    /**
+     * RTSP Message Type
+     */
+    public enum Type {
+        /** Generic message (internal use) */
+        TypeNone,
+        /** Request message */
+        TypeRequest,
+        /** Response message */
+        TypeResponse
+    };
 
-	private int sequenceNumber;
+    private int sequenceNumber;
 
-	private Map&lt;String, String&gt; headers;
+    private Map&lt;String, String&gt; headers;
 
-	private StringBuffer buffer;
+    private StringBuffer buffer;
 
-	/**
-	 * Constructor.
-	 */
-	public RtspMessage()
-	{
-		sequenceNumber = 0;
-		headers = new LinkedHashMap&lt;String, String&gt;();
-		buffer = new StringBuffer();
-	}
+    /**
+     * Constructor.
+     */
+    public RtspMessage()
+    {
+        sequenceNumber = 0;
+        headers = new LinkedHashMap&lt;String, String&gt;();
+        buffer = new StringBuffer();
+    }
 
-	/**
-	 * @return the RTSP type of the message
-	 */
-	public Type getType()
-	{
-		return Type.TypeNone;
-	}
+    /**
+     * @return the RTSP type of the message
+     */
+    public Type getType()
+    {
+        return Type.TypeNone;
+    }
 
-	/**
-	 * Adds a new header to the RTSP message.
-	 * 
-	 * @param key
-	 *            The name of the header
-	 * @param value
-	 *            Its value
-	 */
-	public void setHeader( String key, String value )
-	{
-		// Handle some bad formatted headers
-		if ( key.compareToIgnoreCase( &quot;content-length&quot; ) == 0 ) {
-			headers.put( &quot;Content-Length&quot;, value );
-		} else {
-			headers.put( key, value );
-		}
-	}
+    /**
+     * Adds a new header to the RTSP message.
+     * 
+     * @param key
+     *            The name of the header
+     * @param value
+     *            Its value
+     */
+    public void setHeader( String key, String value )
+    {
+        // Handle some bad formatted headers
+        if ( key.compareToIgnoreCase( &quot;content-length&quot; ) == 0 ) {
+            headers.put( &quot;Content-Length&quot;, value );
+        } else {
+            headers.put( key, value );
+        }
+    }
 
-	/**
-	 * @param key
-	 *            Header name
-	 * @return the value of the header
-	 */
-	public String getHeader( String key )
-	{
-		return headers.get( key );
-	}
+    /**
+     * @param key
+     *            Header name
+     * @return the value of the header
+     */
+    public String getHeader( String key )
+    {
+        return headers.get( key );
+    }
 
-	/**
-	 * @param key
-	 *            Header name
-	 * @param defaultValue
-	 *            the default value
-	 * @return the value of the header of &lt;i&gt;defaultValue&lt;/i&gt; if header is not
-	 *         found
-	 */
-	public String getHeader( String key, String defaultValue )
-	{
-		String value = getHeader( key );
-		if ( value == null )
-			return defaultValue;
-		else
-			return value;
-	}
+    /**
+     * @param key
+     *            Header name
+     * @param defaultValue
+     *            the default value
+     * @return the value of the header of &lt;i&gt;defaultValue&lt;/i&gt; if header is not
+     *         found
+     */
+    public String getHeader( String key, String defaultValue )
+    {
+        String value = getHeader( key );
+        if ( value == null )
+            return defaultValue;
 
-	/**
-	 * Remove an header from the message headers collection
-	 * 
-	 * @param key
-	 *            the name of the header
-	 */
-	public void removeHeader( String key )
-	{
-		headers.remove( key );
-	}
+        return value;
+    }
 
-	/**
-	 * Formats all the headers into a string ready to be sent in a RTSP message.
-	 * 
-	 * &lt;pre&gt;
-	 *     Header1: Value1
-	 *     Header2: value 2
-	 *     ... 
-	 * &lt;/pre&gt;
-	 * 
-	 * @return a string containing the serialzed headers
-	 */
-	public String getHeadersString()
-	{
-		StringBuilder buf = new StringBuilder();
-		for ( String key : headers.keySet() ) {
-			buf.append( key ).append( &quot;: &quot; ).append( headers.get( key ) ).append( CRLF );
-		}
-		return buf.toString();
-	}
+    /**
+     * Remove an header from the message headers collection
+     * 
+     * @param key
+     *            the name of the header
+     */
+    public void removeHeader( String key )
+    {
+        headers.remove( key );
+    }
 
-	/**
-	 * get a map of all headers set in the request
-	 * @return an unmodifiable map of all header fields in this request. 
-	 */
-	public Map&lt;String, String&gt; getHeaders() {
-		if(this.headers != null)
-			return Collections.unmodifiableMap(this.headers);
-		else
-			return Collections.unmodifiableMap(new HashMap&lt;String, String&gt;());
-	}
-	
-	/**
-	 * @return the number of headers owned by the message
-	 */
-	public int getHeadersCount()
-	{
-		return headers.size();
-	}
+    /**
+     * Formats all the headers into a string ready to be sent in a RTSP message.
+     * 
+     * &lt;pre&gt;
+     *      Header1: Value1
+     *      Header2: value 2
+     *      ... 
+     * &lt;/pre&gt;
+     * 
+     * @return a string containing the serialzed headers
+     */
+    public String getHeadersString()
+    {
+        StringBuilder buf = new StringBuilder();
+        for ( String key : headers.keySet() ) {
+            buf.append( key ).append( &quot;: &quot; ).append( headers.get( key ) ).append( CRLF );
+        }
+        return buf.toString();
+    }
 
-	/**
-	 * Sets common headers like &lt;code&gt;Server&lt;/code&gt; and &lt;code&gt;Via&lt;/code&gt;.
-	 */
-	public void setCommonHeaders()
-	{
-		String proxy = Config.getProxySignature();
-		if ( getHeader( &quot;Server&quot; ) == null )
-			setHeader( &quot;Server&quot;, proxy );
-		
-		if(Config.proxyClientAddress.getStringValue() != null) {
-			String via = getHeader(&quot;Via&quot;);
-			StringBuffer newVia = new StringBuffer();
-			
-			if(via != null &amp;&amp; via.length() &gt; 0) {
-				newVia.append(via);
-				newVia.append(&quot;, &quot;);
-			}
-			newVia.append(&quot;RTSP/1.0 &quot;);
-			
-			String clientAddr  = Config.proxyClientAddress.getStringValue();
-			String serverAddr = Config.proxyServerAddress.getStringValue();
-			
-			newVia.append(clientAddr);
-			if(serverAddr != null &amp;&amp; !serverAddr.equals(clientAddr)) {
-				newVia.append(&quot;, RTSP/1.0 &quot;);
-				newVia.append(serverAddr);
-			}
-			
-			setHeader(&quot;Via&quot;, newVia.toString());
-		}
-	}
+    /**
+     * get a map of all headers set in the request
+     * 
+     * @return an unmodifiable map of all header fields in this request.
+     */
+    public Map&lt;String, String&gt; getHeaders()
+    {
+        if ( this.headers != null )
+            return Collections.unmodifiableMap( this.headers );
 
-	/**
-	 * @param buffer
-	 *            StringBuffer containing the contents
-	 */
-	public void setBuffer( StringBuffer buffer )
-	{
-		this.buffer = buffer;
-	}
+        return Collections.unmodifiableMap( new HashMap&lt;String, String&gt;() );
+    }
 
-	/**
-	 * @param other
-	 *            buffer with content to be appended
-	 */
-	public void appendToBuffer( StringBuffer other )
-	{
-		this.buffer.append( other );
-	}
+    /**
+     * @return the number of headers owned by the message
+     */
+    public int getHeadersCount()
+    {
+        return headers.size();
+    }
 
-	/**
-	 * @param other
-	 *            buffer with content to be appended
-	 */
-	public void appendToBuffer( String other )
-	{
-		this.buffer.append( other );
-	}
+    /**
+     * Sets common headers like &lt;code&gt;Server&lt;/code&gt; and &lt;code&gt;Via&lt;/code&gt;.
+     */
+    public void setCommonHeaders()
+    {
+        String proxy = Config.getProxySignature();
+        if ( getHeader( &quot;Server&quot; ) == null )
+            setHeader( &quot;Server&quot;, proxy );
 
-	/**
-	 * @param other
-	 *            buffer with content to be appended
-	 */
-	public void appendToBuffer( CharBuffer other )
-	{
-		this.buffer.append( other );
-	}
+        if ( Config.proxyClientAddress.getStringValue() != null ) {
+            String via = getHeader( &quot;Via&quot; );
+            StringBuffer newVia = new StringBuffer();
 
-	/**
-	 * @return the content buffer
-	 */
-	public StringBuffer getBuffer()
-	{
-		return buffer;
-	}
+            if ( via != null &amp;&amp; via.length() &gt; 0 ) {
+                newVia.append( via );
+                newVia.append( &quot;, &quot; );
+            }
+            newVia.append( &quot;RTSP/1.0 &quot; );
 
-	/**
-	 * @return the size of the content buffer
-	 */
-	public int getBufferSize()
-	{
-		return buffer.length();
-	}
+            String clientAddr = Config.proxyClientAddress.getStringValue();
+            String serverAddr = Config.proxyServerAddress.getStringValue();
 
-	// CRLF
-	public static final String CRLF = &quot;\r\n&quot;;
+            newVia.append( clientAddr );
+            if ( serverAddr != null &amp;&amp; !serverAddr.equals( clientAddr ) ) {
+                newVia.append( &quot;, RTSP/1.0 &quot; );
+                newVia.append( serverAddr );
+            }
 
-	/**
-	 * get the sequence number. If the sequence has not been set, the value from the 
-	 * &lt;b&gt;CSeq&lt;/b&gt; header is scaned (if the header is set)
-	 * @return Returns the sequenceNumber. Returns 0 if the sequence number has not been set and the
-	 * &lt;b&gt;CSeq&lt;/b&gt; header is not available.
-	 */
-	public int getSequenceNumber()
-	{
-		if(this.sequenceNumber == 0) {
-			try {
-				if(this.headers.containsKey(&quot;CSeq&quot;))
-					this.sequenceNumber = Integer.parseInt(this.headers.get(&quot;CSeq&quot;));
-			} catch(Exception e) {
-				
-			}
-		}
-			
-		return sequenceNumber;
-	}
+            setHeader( &quot;Via&quot;, newVia.toString() );
+        }
+    }
 
-	/**
-	 * Set the sequence number. As a by-product it also sets the CSeq header field to this
-	 * value.
-	 * 
-	 * @param sequenceNumber
-	 *            The sequenceNumber to set.
-	 */
-	public void setSequenceNumber( int sequenceNumber )
-	{
-		this.sequenceNumber = sequenceNumber;
-		this.headers.put(&quot;CSeq&quot;, String.valueOf(this.sequenceNumber));
-	}
+    /**
+     * @param buffer
+     *            StringBuffer containing the contents
+     */
+    public void setBuffer( StringBuffer buffer )
+    {
+        this.buffer = buffer;
+    }
+
+    /**
+     * @param other
+     *            buffer with content to be appended
+     */
+    public void appendToBuffer( StringBuffer other )
+    {
+        this.buffer.append( other );
+    }
+
+    /**
+     * @param other
+     *            buffer with content to be appended
+     */
+    public void appendToBuffer( String other )
+    {
+        this.buffer.append( other );
+    }
+
+    /**
+     * @param other
+     *            buffer with content to be appended
+     */
+    public void appendToBuffer( CharBuffer other )
+    {
+        this.buffer.append( other );
+    }
+
+    /**
+     * @return the content buffer
+     */
+    public StringBuffer getBuffer()
+    {
+        return buffer;
+    }
+
+    /**
+     * @return the size of the content buffer
+     */
+    public int getBufferSize()
+    {
+        return buffer.length();
+    }
+
+    // CRLF
+    public static final String CRLF = &quot;\r\n&quot;;
+
+    /**
+     * get the sequence number. If the sequence has not been set, the value from
+     * the &lt;b&gt;CSeq&lt;/b&gt; header is scaned (if the header is set)
+     * 
+     * @return Returns the sequenceNumber. Returns 0 if the sequence number has
+     *         not been set and the &lt;b&gt;CSeq&lt;/b&gt; header is not available.
+     */
+    public int getSequenceNumber()
+    {
+        if ( this.sequenceNumber == 0 ) {
+            try {
+                if ( this.headers.containsKey( &quot;CSeq&quot; ) )
+                    this.sequenceNumber = Integer.parseInt( this.headers.get( &quot;CSeq&quot; ) );
+            } catch ( Exception e ) {
+                  // Do nothing
+            }
+        }
+
+        return sequenceNumber;
+    }
+
+    /**
+     * Set the sequence number. As a by-product it also sets the CSeq header
+     * field to this value.
+     * 
+     * @param sequenceNumber
+     *            The sequenceNumber to set.
+     */
+    public void setSequenceNumber( int sequenceNumber )
+    {
+        this.sequenceNumber = sequenceNumber;
+        this.headers.put( &quot;CSeq&quot;, String.valueOf( this.sequenceNumber ) );
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspRequest.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspRequest.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspRequest.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -44,7 +44,8 @@
 		verb = Verb.None;
 	}
 
-	public Type getType()
+	@Override
+    public Type getType()
 	{
 		return Type.TypeRequest;
 	}
@@ -101,11 +102,12 @@
 	 * [buffer]
 	 * &lt;/pre&gt;
 	 */
-	public String toString()
+	@Override
+    public String toString()
 	{
-		StringBuilder sb = new StringBuilder();
-		sb.append( getVerbString() + &quot; &quot; );
-		sb.append( url != null ? url : &quot;*&quot; );
+		final StringBuilder sb = new StringBuilder();
+		sb.append( getVerbString() ).append( ' ' );
+		sb.append( url != null ? url : '*' );
 		sb.append( &quot; RTSP/1.0\r\n&quot; );
 		sb.append( getHeadersString() );
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspResponse.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspResponse.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspResponse.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -39,7 +39,8 @@
 		code = RtspCode.OK;
 	}
 
-	public Type getType()
+	@Override
+    public Type getType()
 	{
 		return Type.TypeResponse;
 	}
@@ -74,10 +75,11 @@
 	 *    [buf] 
 	 * &lt;/pre&gt;
 	 */
-	public String toString()
+	@Override
+    public String toString()
 	{
-		StringBuilder sb = new StringBuilder();
-		sb.append( &quot;RTSP/1.0 &quot; ).append( code.value() ).append( &quot; &quot; );
+		final StringBuilder sb = new StringBuilder();
+		sb.append( &quot;RTSP/1.0 &quot; ).append( code.value() ).append( ' ' );
 		sb.append( code.description() ).append( CRLF );
 		sb.append( getHeadersString() );
 
@@ -87,7 +89,7 @@
 		if ( getBufferSize() &gt; 0 ) {
 			sb.append( getBuffer() );
 
-			log.debug( &quot;Buffer Size: &quot; + getBufferSize() );
+			log.debug( &quot;Buffer Size: {}&quot;, getBufferSize() );
 		}
 
 		return sb.toString();

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspSession.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspSession.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspSession.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -61,7 +61,7 @@
 		}
 		RtspSession session = new RtspSession( sessionId );
 		sessions.put( sessionId, session );
-		log.debug( &quot;New session created - id=&quot; + sessionId );
+		log.debug( &quot;New session created - id={}&quot;, sessionId );
 		return session;
 	}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransport.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransport.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransport.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -27,661 +27,662 @@
  * Parse the RTSP Transport header field. Reference Grammar:
  * 
  * &lt;pre&gt;
- *                       Transport           =    &quot;Transport&quot; &quot;:&quot;
- *                                                1\#transport-spec
- *                       transport-spec      =    transport-protocol/profile[/lower-transport]
- *                                                *parameter
- *                       transport-protocol  =    &quot;RTP&quot;
- *                       profile             =    &quot;AVP&quot;
- *                       lower-transport     =    &quot;TCP&quot; | &quot;UDP&quot;
- *                       parameter           =    ( &quot;unicast&quot; | &quot;multicast&quot; )
- *                                           |    &quot;;&quot; &quot;destination&quot; [ &quot;=&quot; address ]
- *                                           |    &quot;;&quot; &quot;interleaved&quot; &quot;=&quot; channel [ &quot;-&quot; channel ]
- *                                           |    &quot;;&quot; &quot;append&quot;
- *                                           |    &quot;;&quot; &quot;ttl&quot; &quot;=&quot; ttl
- *                                           |    &quot;;&quot; &quot;layers&quot; &quot;=&quot; 1*DIGIT
- *                                           |    &quot;;&quot; &quot;port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
- *                                           |    &quot;;&quot; &quot;client_port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
- *                                           |    &quot;;&quot; &quot;server_port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
- *                                           |    &quot;;&quot; &quot;ssrc&quot; &quot;=&quot; ssrc
- *                                           |    &quot;;&quot; &quot;mode&quot; = &lt;&quot;&gt; 1\#mode &lt;&quot;&gt;
- *                       ttl                 =    1*3(DIGIT)
- *                       port                =    1*5(DIGIT)
- *                       ssrc                =    8*8(HEX)
- *                       channel             =    1*3(DIGIT)
- *                       address             =    host
- *                       mode                =    &lt;&quot;&gt; *Method &lt;&quot;&gt; | Method
- *                    
- *                    
- *                       Example:
- *                         Transport: RTP/AVP;multicast;ttl=127;mode=&quot;PLAY&quot;,
- *                                    RTP/AVP;unicast;client_port=3456-3457;mode=&quot;PLAY&quot;
+ *                        Transport           =    &quot;Transport&quot; &quot;:&quot;
+ *                                                 1\#transport-spec
+ *                        transport-spec      =    transport-protocol/profile[/lower-transport]
+ *                                                 *parameter
+ *                        transport-protocol  =    &quot;RTP&quot;
+ *                        profile             =    &quot;AVP&quot;
+ *                        lower-transport     =    &quot;TCP&quot; | &quot;UDP&quot;
+ *                        parameter           =    ( &quot;unicast&quot; | &quot;multicast&quot; )
+ *                                            |    &quot;;&quot; &quot;destination&quot; [ &quot;=&quot; address ]
+ *                                            |    &quot;;&quot; &quot;interleaved&quot; &quot;=&quot; channel [ &quot;-&quot; channel ]
+ *                                            |    &quot;;&quot; &quot;append&quot;
+ *                                            |    &quot;;&quot; &quot;ttl&quot; &quot;=&quot; ttl
+ *                                            |    &quot;;&quot; &quot;layers&quot; &quot;=&quot; 1*DIGIT
+ *                                            |    &quot;;&quot; &quot;port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
+ *                                            |    &quot;;&quot; &quot;client_port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
+ *                                            |    &quot;;&quot; &quot;server_port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
+ *                                            |    &quot;;&quot; &quot;ssrc&quot; &quot;=&quot; ssrc
+ *                                            |    &quot;;&quot; &quot;mode&quot; = &lt;&quot;&gt; 1\#mode &lt;&quot;&gt;
+ *                        ttl                 =    1*3(DIGIT)
+ *                        port                =    1*5(DIGIT)
+ *                        ssrc                =    8*8(HEX)
+ *                        channel             =    1*3(DIGIT)
+ *                        address             =    host
+ *                        mode                =    &lt;&quot;&gt; *Method &lt;&quot;&gt; | Method
+ *                     
+ *                     
+ *                        Example:
+ *                          Transport: RTP/AVP;multicast;ttl=127;mode=&quot;PLAY&quot;,
+ *                                     RTP/AVP;unicast;client_port=3456-3457;mode=&quot;PLAY&quot;
  * &lt;/pre&gt;
  */
 public class RtspTransport
 {
 
-	private static Logger logger = LoggerFactory.getLogger(RtspTransport.class);
-	
-	/** Transport Protocol */
-	public enum TransportProtocol {
-		None,
-		/** Real Time Protocol */
-		RTP,
-		/** RDT: RealNetworks transport protocol */
-		RDT, RAW;
+    private static Logger log = LoggerFactory.getLogger( RtspTransport.class );
 
-		public static TransportProtocol fromString( String transportName )
-		{
-			if ( &quot;RTP&quot;.equalsIgnoreCase( transportName ) )
-				return RTP;
-			else
-				if ( &quot;RDT&quot;.equalsIgnoreCase( transportName )
-						|| &quot;x-real-rdt&quot;.equalsIgnoreCase( transportName ) )
-					return RDT;
-				else
-					return None;
-		}
-	}
+    /** Transport Protocol */
+    public enum TransportProtocol {
+        None,
+        /** Real Time Protocol */
+        RTP,
+        /** RDT: RealNetworks transport protocol */
+        RDT, RAW;
 
-	/** Profile of the streamed data */
-	public enum Profile {
-		None,
-		/** Audio-Video Profile */
-		AVP;
+        public static TransportProtocol fromString( String transportName )
+        {
+            if ( &quot;RTP&quot;.equalsIgnoreCase( transportName ) )
+                return RTP;
+            else if ( &quot;RDT&quot;.equalsIgnoreCase( transportName )
+                    || &quot;x-real-rdt&quot;.equalsIgnoreCase( transportName ) )
+                return RDT;
+            else
+                return None;
+        }
+    }
 
-		public static Profile fromString( String profile )
-		{
-			if ( &quot;AVP&quot;.equalsIgnoreCase( profile ) )
-				return AVP;
-			else
-				return None;
-		}
-	}
+    /** Profile of the streamed data */
+    public enum Profile {
+        None,
+        /** Audio-Video Profile */
+        AVP;
 
-	/** Underlying transport protocol */
-	public enum LowerTransport {
-		None, TCP, UDP;
+        public static Profile fromString( String profile )
+        {
+            if ( &quot;AVP&quot;.equalsIgnoreCase( profile ) )
+                return AVP;
 
-		public static LowerTransport fromString( String transportName )
-		{
-			if ( &quot;TCP&quot;.equalsIgnoreCase( transportName ) )
-				return TCP;
-			else
-				if ( &quot;UDP&quot;.equalsIgnoreCase( transportName ) )
-					return UDP;
-				else
-					return None;
-		}
-	}
+            return None;
+        }
+    }
 
-	/** Delivery method */
-	public enum DeliveryType {
-		None, unicast, multicast
-	}
+    /** Underlying transport protocol */
+    public enum LowerTransport {
+        None, TCP, UDP;
 
-	/** mode */
-	public enum Mode {
-		None, PLAY, RECORD;
-		
-		public static Mode fromString ( String modeName ) {
-			if( &quot;PLAY&quot;.equalsIgnoreCase( modeName ))
-				return PLAY;
-			else if( &quot;RECORD&quot;.equalsIgnoreCase( modeName ))
-				return RECORD;
-			else {
-				logger.debug(&quot;unknown mode string passed (ignored): &quot; + modeName);
-				return None;
-			}
-		}
-	}
-	
-	TransportProtocol transportProtocol = null;
-	Profile profile = null;
-	LowerTransport lowerTransport = null;
-	DeliveryType deliveryType = null;
+        public static LowerTransport fromString( String transportName )
+        {
+            if ( &quot;TCP&quot;.equalsIgnoreCase( transportName ) )
+                return TCP;
+            else if ( &quot;UDP&quot;.equalsIgnoreCase( transportName ) )
+                return UDP;
+            else
+                return None;
+        }
+    }
 
-	String destination;
-	String interleaved;
-	int layers;
-	boolean append;
-	int ttl;
-	int[] port = new int[2];
-	int[] client_port = new int[2];
-	int[] server_port = new int[2];
-	String ssrc;
-	Mode mode = Mode.None;
-	String source;
+    /** Delivery method */
+    public enum DeliveryType {
+        None, unicast, multicast
+    }
 
-	/**
-	 * Constructor. Creates a RtspTransport object from a transport header
-	 * string.
-	 */
-	public RtspTransport( String transport )
-	{
-		transportProtocol = TransportProtocol.None;
-		profile = Profile.None;
-		lowerTransport = LowerTransport.None;
-		deliveryType = DeliveryType.None;
-		destination = null;
-		interleaved = null;
-		layers = 0;
-		append = false;
-		ttl = 0;
-		port[0] = 0;
-		port[1] = 0;
-		client_port[0] = 0;
-		client_port[1] = 0;
-		server_port[0] = 0;
-		server_port[1] = 0;
-		ssrc = null;
-		mode = Mode.None;
-		source = null;
+    /** mode */
+    public enum Mode {
+        None, PLAY, RECORD;
 
-		parseTransport( transport );
-	}
+        public static Mode fromString( String modeName )
+        {
+            if ( &quot;PLAY&quot;.equalsIgnoreCase( modeName ) )
+                return PLAY;
+            else if ( &quot;RECORD&quot;.equalsIgnoreCase( modeName ) )
+                return RECORD;
+            else {
+                log.debug( &quot;unknown mode string passed (ignored): {}&quot;, modeName );
+                return None;
+            }
+        }
+    }
 
-	private void parseTransport( String transport )
-	{
-		for ( String tok : transport.split( &quot;;&quot; ) ) {
+    TransportProtocol transportProtocol = null;
 
-			// First check for the transport protocol
-			if ( tok.startsWith( &quot;RTP&quot; ) || tok.startsWith( &quot;RDT&quot; )
-					|| tok.startsWith( &quot;x-real-rdt&quot; ) ) {
-				String[] tpl = tok.split( &quot;/&quot; );
-				transportProtocol = TransportProtocol.fromString( tpl[0] );
-				if ( tpl.length &gt; 1 )
-					try {
-						profile = Profile.valueOf( tpl[1] );
-					} catch ( Exception e ) {
-						profile = Profile.None;
-					}
+    Profile profile = null;
 
-				if ( profile == Profile.None ) {
-					// Maybe this is a lower transport definition
-					lowerTransport = LowerTransport.fromString( tpl[1] );
-				}
+    LowerTransport lowerTransport = null;
 
-				if ( tpl.length &gt; 2 )
-					lowerTransport = LowerTransport.valueOf( tpl[2] );
-				continue;
-			}
+    DeliveryType deliveryType = null;
 
-			if ( tok.compareToIgnoreCase( &quot;unicast&quot; ) == 0 )
-				deliveryType = DeliveryType.unicast;
-			else
-				if ( tok.compareToIgnoreCase( &quot;multicast&quot; ) == 0 )
-					deliveryType = DeliveryType.multicast;
-				else
-					if ( tok.startsWith( &quot;destination&quot; ) )
-						setDestination( _getStrValue( tok ) );
-					else
-						if ( tok.startsWith( &quot;interleaved&quot; ) )
-							setInterleaved( _getStrValue( tok ) );
-						else
-							if ( tok.startsWith( &quot;append&quot; ) )
-								setAppend( true );
-							else
-								if ( tok.startsWith( &quot;layers&quot; ) )
-									setLayers( Integer.valueOf( _getStrValue( tok ) ) );
-								else
-									if ( tok.startsWith( &quot;ttl&quot; ) )
-										setTTL( Integer.valueOf( _getStrValue( tok ) ) );
-									else
-										if ( tok.startsWith( &quot;port&quot; ) )
-											setPort( _getPairValue( tok ) );
-										else
-											if ( tok.startsWith( &quot;client_port&quot; ) )
-												setClientPort( _getPairValue( tok ) );
-											else
-												if ( tok.startsWith( &quot;server_port&quot; ) )
-													setServerPort( _getPairValue( tok ) );
-												else
-													if ( tok.startsWith( &quot;ssrc&quot; ) )
-														setSSRC( _getStrValue( tok ) );
-													else
-														if ( tok.startsWith( &quot;mode&quot; ) )
-															setMode( Mode.fromString( _getStrValue( tok ) ) );
-														else
-															if ( tok.startsWith( &quot;source&quot; ) )
-																setSource( _getStrValue( tok ) );
-		}
+    String destination;
 
-		if ( transportProtocol == TransportProtocol.RTP
-				&amp;&amp; lowerTransport == LowerTransport.None )
-			// If it's not specified, let's assume UDP
-			setLowerTransport( LowerTransport.UDP );
+    String interleaved;
 
-		if ( transportProtocol == TransportProtocol.RTP
-				&amp;&amp; deliveryType == DeliveryType.None )
-			// If it's not specified, let's assume unicast
-			setDeliveryType( DeliveryType.unicast );
+    int layers;
 
-		if ( transportProtocol == TransportProtocol.RDT
-				&amp;&amp; deliveryType == DeliveryType.None )
-			// If it's not specified, let's assume unicast
-			setDeliveryType( DeliveryType.unicast );
+    boolean append;
 
-	}
+    int ttl;
 
-	public String toString()
-	{
-		StringBuilder sb = new StringBuilder();
-		if ( transportProtocol == TransportProtocol.RDT ) {
-			// RDT is a little bit &quot;special&quot;
-			sb.append( &quot;x-real-rdt&quot; );
+    int[] port = new int[2];
 
-			if ( lowerTransport != LowerTransport.None )
-				sb.append( &quot;/&quot; ).append( lowerTransport.toString().toLowerCase() );
-			
-			if ( deliveryType == DeliveryType.multicast )
-				sb.append( &quot;/mcast&quot; );
+    int[] client_port = new int[2];
 
-		} else {
-			sb.append( transportProtocol );
-			if ( profile != Profile.None ) {
-				sb.append( &quot;/&quot; ).append( profile );
-				if ( !Config.proxyLowerTransportSuppress.getValue() 
-						&amp;&amp; lowerTransport != LowerTransport.None )
-					sb.append( &quot;/&quot; ).append( lowerTransport );
-			}
-			if ( deliveryType != DeliveryType.None )
-				sb.append( &quot;;&quot; ).append( deliveryType );
-		}
-		if ( destination != null )
-			sb.append( &quot;;destination=&quot; ).append( destination );
-		if ( interleaved != null )
-			sb.append( &quot;;interleaved=&quot; ).append( interleaved );
-		if ( append )
-			sb.append( &quot;;append&quot; );
-		if ( layers &gt; 0 )
-			sb.append( &quot;;layers=&quot; ).append( layers );
-		if ( ttl &gt; 0 )
-			sb.append( &quot;;ttl=&quot; ).append( ttl );
-		if ( port[0] &gt; 0 ) {
-			sb.append( &quot;;port=&quot; ).append( port[0] );
-			if ( port[1] &gt; 0 )
-				sb.append( &quot;-&quot; ).append( port[1] );
-		}
-		if ( client_port[0] &gt; 0 ) {
-			sb.append( &quot;;client_port=&quot; ).append( client_port[0] );
-			if ( client_port[1] &gt; 0 )
-				sb.append( &quot;-&quot; ).append( client_port[1] );
-		}
-		if ( server_port[0] &gt; 0 ) {
-			sb.append( &quot;;server_port=&quot; ).append( server_port[0] );
-			if ( server_port[1] &gt; 0 )
-				sb.append( &quot;-&quot; ).append( server_port[1] );
-		}
-		
-		if(!Config.proxyRtspTransportSsrcDisable.getValue())
-			if ( ssrc != null )
-				sb.append( &quot;;ssrc=&quot; ).append( ssrc );
-		if(!Config.proxyRtspTransportSourceDisable.getValue())
-			if ( source != null )
-				sb.append( &quot;;source=&quot; ).append( source );
-		
-		if ( mode != Mode.None )
-			sb.append( &quot;;mode=\&quot;&quot; ).append( mode ) . append(&quot;\&quot;&quot;);
-		return sb.toString();
-	}
+    int[] server_port = new int[2];
 
-	/**
-	 * Test if the specified transport can be used by the proxy.
-	 * 
-	 * @return
-	 */
-	public boolean isSupportedByProxy()
-	{
-		/*
-		 * At now, the only transport supported by the server is
-		 * &quot;RTP/AVP/UDP;unicast&quot;
-		 */
-		if ( Config.proxyTransportRtpEnable.getValue()
-				&amp;&amp; transportProtocol == TransportProtocol.RTP &amp;&amp; profile == Profile.AVP
-				&amp;&amp; lowerTransport == LowerTransport.UDP
-				&amp;&amp; deliveryType == DeliveryType.unicast )
-			return true;
-		else
-			if ( Config.proxyTransportRdtEnable.getValue()
-					&amp;&amp; transportProtocol == TransportProtocol.RDT
-					&amp;&amp; lowerTransport == LowerTransport.UDP
-					&amp;&amp; deliveryType == DeliveryType.unicast )
-				return true;
-			else
-				return false;
-	}
+    String ssrc;
 
-	/**
-	 * @return Returns the append.
-	 */
-	public boolean isAppend()
-	{
-		return append;
-	}
+    Mode mode = Mode.None;
 
-	/**
-	 * @param append
-	 *        The append to set.
-	 */
-	public void setAppend( boolean append )
-	{
-		this.append = append;
-	}
+    String source;
 
-	/**
-	 * @return Returns the client_port.
-	 */
-	public int[] getClientPort()
-	{
-		return client_port;
-	}
+    /**
+     * Constructor. Creates a RtspTransport object from a transport header
+     * string.
+     */
+    public RtspTransport( String transport )
+    {
+        transportProtocol = TransportProtocol.None;
+        profile = Profile.None;
+        lowerTransport = LowerTransport.None;
+        deliveryType = DeliveryType.None;
+        destination = null;
+        interleaved = null;
+        layers = 0;
+        append = false;
+        ttl = 0;
+        port[0] = 0;
+        port[1] = 0;
+        client_port[0] = 0;
+        client_port[1] = 0;
+        server_port[0] = 0;
+        server_port[1] = 0;
+        ssrc = null;
+        mode = Mode.None;
+        source = null;
 
-	/**
-	 * @param client_port
-	 *        The client_port to set.
-	 */
-	public void setClientPort( int[] client_port )
-	{
-		this.client_port = client_port;
-	}
+        parseTransport( transport );
+    }
 
-	/**
-	 * @param client_port
-	 *        The client_port to set.
-	 */
-	public void setClientPort( int client_port )
-	{
-		this.client_port = new int[] { client_port, 0 };
-	}
+    private void parseTransport( String transport )
+    {
+        for ( String tok : transport.split( &quot;;&quot; ) ) {
 
-	/**
-	 * @return Returns the deliveryType.
-	 */
-	public DeliveryType getDeliveryType()
-	{
-		return deliveryType;
-	}
+            // First check for the transport protocol
+            if ( tok.startsWith( &quot;RTP&quot; ) || tok.startsWith( &quot;RDT&quot; )
+                    || tok.startsWith( &quot;x-real-rdt&quot; ) ) {
+                String[] tpl = tok.split( &quot;/&quot; );
+                transportProtocol = TransportProtocol.fromString( tpl[0] );
+                if ( tpl.length &gt; 1 )
+                    try {
+                        profile = Profile.valueOf( tpl[1] );
+                    } catch ( Exception e ) {
+                        profile = Profile.None;
+                    }
 
-	/**
-	 * @param deliveryType
-	 *        The deliveryType to set.
-	 */
-	public void setDeliveryType( DeliveryType deliveryType )
-	{
-		this.deliveryType = deliveryType;
-	}
+                if ( profile == Profile.None ) {
+                    // Maybe this is a lower transport definition
+                    lowerTransport = LowerTransport.fromString( tpl[1] );
+                }
 
-	/**
-	 * @return Returns the destination.
-	 */
-	public String getDestination()
-	{
-		return destination;
-	}
+                if ( tpl.length &gt; 2 )
+                    lowerTransport = LowerTransport.valueOf( tpl[2] );
+                continue;
+            }
 
-	/**
-	 * @param destination
-	 *        The destination to set.
-	 */
-	public void setDestination( String destination )
-	{
-		this.destination = destination;
-	}
+            if ( tok.compareToIgnoreCase( &quot;unicast&quot; ) == 0 )
+                deliveryType = DeliveryType.unicast;
+            else if ( tok.compareToIgnoreCase( &quot;multicast&quot; ) == 0 )
+                deliveryType = DeliveryType.multicast;
+            else if ( tok.startsWith( &quot;destination&quot; ) )
+                setDestination( _getStrValue( tok ) );
+            else if ( tok.startsWith( &quot;interleaved&quot; ) )
+                setInterleaved( _getStrValue( tok ) );
+            else if ( tok.startsWith( &quot;append&quot; ) )
+                setAppend( true );
+            else if ( tok.startsWith( &quot;layers&quot; ) )
+                setLayers( Integer.valueOf( _getStrValue( tok ) ) );
+            else if ( tok.startsWith( &quot;ttl&quot; ) )
+                setTTL( Integer.valueOf( _getStrValue( tok ) ) );
+            else if ( tok.startsWith( &quot;port&quot; ) )
+                setPort( _getPairValue( tok ) );
+            else if ( tok.startsWith( &quot;client_port&quot; ) )
+                setClientPort( _getPairValue( tok ) );
+            else if ( tok.startsWith( &quot;server_port&quot; ) )
+                setServerPort( _getPairValue( tok ) );
+            else if ( tok.startsWith( &quot;ssrc&quot; ) )
+                setSSRC( _getStrValue( tok ) );
+            else if ( tok.startsWith( &quot;mode&quot; ) )
+                setMode( Mode.fromString( _getStrValue( tok ) ) );
+            else if ( tok.startsWith( &quot;source&quot; ) )
+                setSource( _getStrValue( tok ) );
+        }
 
-	/**
-	 * @return Returns the interleaved.
-	 */
-	public String getInterleaved()
-	{
-		return interleaved;
-	}
+        if ( transportProtocol == TransportProtocol.RTP
+                &amp;&amp; lowerTransport == LowerTransport.None )
+            // If it's not specified, let's assume UDP
+            setLowerTransport( LowerTransport.UDP );
 
-	/**
-	 * @param interleaved
-	 *        The interleaved to set.
-	 */
-	public void setInterleaved( String interleaved )
-	{
-		this.interleaved = interleaved;
-	}
+        if ( transportProtocol == TransportProtocol.RTP
+                &amp;&amp; deliveryType == DeliveryType.None )
+            // If it's not specified, let's assume unicast
+            setDeliveryType( DeliveryType.unicast );
 
-	/**
-	 * @return Returns the layers.
-	 */
-	public int getLayers()
-	{
-		return layers;
-	}
+        if ( transportProtocol == TransportProtocol.RDT
+                &amp;&amp; deliveryType == DeliveryType.None )
+            // If it's not specified, let's assume unicast
+            setDeliveryType( DeliveryType.unicast );
 
-	/**
-	 * @param layers
-	 *        The layers to set.
-	 */
-	public void setLayers( int layers )
-	{
-		this.layers = layers;
-	}
+    }
 
-	/**
-	 * @return Returns the lowerTransport.
-	 */
-	public LowerTransport getLowerTransport()
-	{
-		return lowerTransport;
-	}
+    @Override
+    public String toString()
+    {
+        final StringBuilder sb = new StringBuilder();
+        if ( transportProtocol == TransportProtocol.RDT ) {
+            // RDT is a little bit &quot;special&quot;
+            sb.append( &quot;x-real-rdt&quot; );
 
-	/**
-	 * @param lowerTransport
-	 *        The lowerTransport to set.
-	 */
-	public void setLowerTransport( LowerTransport lowerTransport )
-	{
-		this.lowerTransport = lowerTransport;
-	}
+            if ( lowerTransport != LowerTransport.None )
+                sb.append( '/' ).append( lowerTransport.toString().toLowerCase() );
 
-	/**
-	 * @return Returns the mode.
-	 */
-	public Mode getMode()
-	{
-		return mode;
-	}
+            if ( deliveryType == DeliveryType.multicast )
+                sb.append( &quot;/mcast&quot; );
 
-	/**
-	 * Set the mode. The 
-	 * @param mode
-	 *        The mode to set.
-	 */
-	public void setMode( Mode mode )
-	{
-		this.mode = mode;
-	}
+        } else {
+            sb.append( transportProtocol );
+            if ( profile != Profile.None ) {
+                sb.append( '/' ).append( profile );
+                if ( !Config.proxyLowerTransportSuppress.getValue()
+                        &amp;&amp; lowerTransport != LowerTransport.None )
+                    sb.append( '/' ).append( lowerTransport );
+            }
+            if ( deliveryType != DeliveryType.None )
+                sb.append( ';' ).append( deliveryType );
+        }
+        if ( destination != null )
+            sb.append( &quot;;destination=&quot; ).append( destination );
+        if ( interleaved != null )
+            sb.append( &quot;;interleaved=&quot; ).append( interleaved );
+        if ( append )
+            sb.append( &quot;;append&quot; );
+        if ( layers &gt; 0 )
+            sb.append( &quot;;layers=&quot; ).append( layers );
+        if ( ttl &gt; 0 )
+            sb.append( &quot;;ttl=&quot; ).append( ttl );
+        if ( port[0] &gt; 0 ) {
+            sb.append( &quot;;port=&quot; ).append( port[0] );
+            if ( port[1] &gt; 0 )
+                sb.append( '-' ).append( port[1] );
+        }
+        if ( client_port[0] &gt; 0 ) {
+            sb.append( &quot;;client_port=&quot; ).append( client_port[0] );
+            if ( client_port[1] &gt; 0 )
+                sb.append( '-' ).append( client_port[1] );
+        }
+        if ( server_port[0] &gt; 0 ) {
+            sb.append( &quot;;server_port=&quot; ).append( server_port[0] );
+            if ( server_port[1] &gt; 0 )
+                sb.append( '-' ).append( server_port[1] );
+        }
 
-	/**
-	 * @return Returns the port.
-	 */
-	public int[] getPort()
-	{
-		return port;
-	}
+        if ( !Config.proxyRtspTransportSsrcDisable.getValue() )
+            if ( ssrc != null )
+                sb.append( &quot;;ssrc=&quot; ).append( ssrc );
+        if ( !Config.proxyRtspTransportSourceDisable.getValue() )
+            if ( source != null )
+                sb.append( &quot;;source=&quot; ).append( source );
 
-	/**
-	 * @param port
-	 *        The port to set.
-	 */
-	public void setPort( int[] port )
-	{
-		this.port = port;
-	}
+        if ( mode != Mode.None )
+            sb.append( &quot;;mode=\&quot;&quot; ).append( mode ).append( '&quot;' );
+        return sb.toString();
+    }
 
-	/**
-	 * @return Returns the profile.
-	 */
-	public Profile getProfile()
-	{
-		return profile;
-	}
+    /**
+     * Test if the specified transport can be used by the proxy.
+     * 
+     * @return
+     */
+    public boolean isSupportedByProxy()
+    {
+        /*
+         * At now, the only transport supported by the server is
+         * &quot;RTP/AVP/UDP;unicast&quot;
+         */
+        if ( Config.proxyTransportRtpEnable.getValue()
+                &amp;&amp; transportProtocol == TransportProtocol.RTP &amp;&amp; profile == Profile.AVP
+                &amp;&amp; lowerTransport == LowerTransport.UDP
+                &amp;&amp; deliveryType == DeliveryType.unicast )
+            return true;
+        else if ( Config.proxyTransportRdtEnable.getValue()
+                &amp;&amp; transportProtocol == TransportProtocol.RDT
+                &amp;&amp; lowerTransport == LowerTransport.UDP
+                &amp;&amp; deliveryType == DeliveryType.unicast )
+            return true;
+        else
+            return false;
+    }
 
-	/**
-	 * @param profile
-	 *        The profile to set.
-	 */
-	public void setProfile( Profile profile )
-	{
-		this.profile = profile;
-	}
+    /**
+     * @return Returns the append.
+     */
+    public boolean isAppend()
+    {
+        return append;
+    }
 
-	/**
-	 * @return Returns the server_port.
-	 */
-	public int[] getServerPort()
-	{
-		return server_port;
-	}
+    /**
+     * @param append
+     *            The append to set.
+     */
+    public void setAppend( boolean append )
+    {
+        this.append = append;
+    }
 
-	/**
-	 * @param server_port
-	 *        The server_port to set.
-	 */
-	public void setServerPort( int[] server_port )
-	{
-		this.server_port = server_port;
-	}
+    /**
+     * @return Returns the client_port.
+     */
+    public int[] getClientPort()
+    {
+        return client_port;
+    }
 
-	/**
-	 * @param server_port
-	 *        The server_port to set.
-	 */
-	public void setServerPort( int server_port )
-	{
-		this.server_port = new int[] { server_port, 0 };
-	}
+    /**
+     * @param client_port
+     *            The client_port to set.
+     */
+    public void setClientPort( int[] client_port )
+    {
+        this.client_port = client_port;
+    }
 
-	/**
-	 * @return Returns the ssrc.
-	 */
-	public String getSSRC()
-	{
-		return ssrc;
-	}
+    /**
+     * @param client_port
+     *            The client_port to set.
+     */
+    public void setClientPort( int client_port )
+    {
+        this.client_port = new int[] { client_port, 0 };
+    }
 
-	/**
-	 * @param ssrc
-	 *        The ssrc to set.
-	 */
-	public void setSSRC( String ssrc )
-	{
-		this.ssrc = ssrc;
-	}
+    /**
+     * @return Returns the deliveryType.
+     */
+    public DeliveryType getDeliveryType()
+    {
+        return deliveryType;
+    }
 
-	/**
-	 * @param ssrc
-	 *        The ssrc to set.
-	 */
-	public void setSSRC( long ssrc )
-	{
-		this.ssrc = Long.toHexString( ssrc &amp; 0xFFFFFFFFL ).toUpperCase();
-	}
+    /**
+     * @param deliveryType
+     *            The deliveryType to set.
+     */
+    public void setDeliveryType( DeliveryType deliveryType )
+    {
+        this.deliveryType = deliveryType;
+    }
 
-	/**
-	 * @return Returns the transportProtocol.
-	 */
-	public TransportProtocol getTransportProtocol()
-	{
-		return transportProtocol;
-	}
+    /**
+     * @return Returns the destination.
+     */
+    public String getDestination()
+    {
+        return destination;
+    }
 
-	/**
-	 * @param transportProtocol
-	 *        The transportProtocol to set.
-	 */
-	public void setTransportProtocol( TransportProtocol transportProtocol )
-	{
-		this.transportProtocol = transportProtocol;
-	}
+    /**
+     * @param destination
+     *            The destination to set.
+     */
+    public void setDestination( String destination )
+    {
+        this.destination = destination;
+    }
 
-	/**
-	 * @return Returns the ttl.
-	 */
-	public int getTTL()
-	{
-		return ttl;
-	}
+    /**
+     * @return Returns the interleaved.
+     */
+    public String getInterleaved()
+    {
+        return interleaved;
+    }
 
-	/**
-	 * @param ttl
-	 *        The ttl to set.
-	 */
-	public void setTTL( int ttl )
-	{
-		this.ttl = ttl;
-	}
+    /**
+     * @param interleaved
+     *            The interleaved to set.
+     */
+    public void setInterleaved( String interleaved )
+    {
+        this.interleaved = interleaved;
+    }
 
-	public void setSource( String source )
-	{
-		this.source = source;
-	}
+    /**
+     * @return Returns the layers.
+     */
+    public int getLayers()
+    {
+        return layers;
+    }
 
-	public String getSource()
-	{
-		return source;
-	}
+    /**
+     * @param layers
+     *            The layers to set.
+     */
+    public void setLayers( int layers )
+    {
+        this.layers = layers;
+    }
 
-	/**
-	 * Get the value part in a string like:
-	 * 
-	 * &lt;pre&gt;
-	 * key = value
-	 * &lt;/pre&gt;
-	 * 
-	 * @param str
-	 *        the content string
-	 * @return a String containing only the value
-	 */
-	private static String _getStrValue( String str )
-	{
-		String val = null;
-		
-		String[] list = str.split( &quot;=&quot; );
-		if ( list.length != 2 )
-			return null;
+    /**
+     * @return Returns the lowerTransport.
+     */
+    public LowerTransport getLowerTransport()
+    {
+        return lowerTransport;
+    }
 
-		val = list[1];
-		if(val.startsWith(&quot;\&quot;&quot;) &amp;&amp; val.endsWith(&quot;\&quot;&quot;))
-			val = val.substring(1, val.length()-2);
-		
-		return val;
-	}
+    /**
+     * @param lowerTransport
+     *            The lowerTransport to set.
+     */
+    public void setLowerTransport( LowerTransport lowerTransport )
+    {
+        this.lowerTransport = lowerTransport;
+    }
 
-	/**
-	 * Get the value part in a string like:
-	 * 
-	 * &lt;pre&gt;
-	 * key = 6344 - 6345
-	 * &lt;/pre&gt;
-	 * 
-	 * @param str
-	 *        the content string
-	 * @return a int[2] containing only the value
-	 */
-	private static int[] _getPairValue( String str )
-	{
-		int[] pair = { 0, 0 };
-		String[] list = str.split( &quot;=&quot; );
-		if ( list.length != 2 )
-			return pair;
+    /**
+     * @return Returns the mode.
+     */
+    public Mode getMode()
+    {
+        return mode;
+    }
 
-		try {
-			pair[0] = Integer.parseInt( list[1].split( &quot;-&quot; )[0] );
-			pair[1] = Integer.parseInt( list[1].split( &quot;-&quot; )[1] );
+    /**
+     * Set the mode. The
+     * 
+     * @param mode
+     *            The mode to set.
+     */
+    public void setMode( Mode mode )
+    {
+        this.mode = mode;
+    }
 
-			// log.debug(&quot;Client ports: &quot; + 1);
-			// Integers.parse();
+    /**
+     * @return Returns the port.
+     */
+    public int[] getPort()
+    {
+        return port;
+    }
 
-		} catch ( Exception e ) {
-			return pair;
-		}
-		return pair;
-	}
+    /**
+     * @param port
+     *            The port to set.
+     */
+    public void setPort( int[] port )
+    {
+        this.port = port;
+    }
+
+    /**
+     * @return Returns the profile.
+     */
+    public Profile getProfile()
+    {
+        return profile;
+    }
+
+    /**
+     * @param profile
+     *            The profile to set.
+     */
+    public void setProfile( Profile profile )
+    {
+        this.profile = profile;
+    }
+
+    /**
+     * @return Returns the server_port.
+     */
+    public int[] getServerPort()
+    {
+        return server_port;
+    }
+
+    /**
+     * @param server_port
+     *            The server_port to set.
+     */
+    public void setServerPort( int[] server_port )
+    {
+        this.server_port = server_port;
+    }
+
+    /**
+     * @param server_port
+     *            The server_port to set.
+     */
+    public void setServerPort( int server_port )
+    {
+        this.server_port = new int[] { server_port, 0 };
+    }
+
+    /**
+     * @return Returns the ssrc.
+     */
+    public String getSSRC()
+    {
+        return ssrc;
+    }
+
+    /**
+     * @param ssrc
+     *            The ssrc to set.
+     */
+    public void setSSRC( String ssrc )
+    {
+        this.ssrc = ssrc;
+    }
+
+    /**
+     * @param ssrc
+     *            The ssrc to set.
+     */
+    public void setSSRC( long ssrc )
+    {
+        this.ssrc = Long.toHexString( ssrc &amp; 0xFFFFFFFFL ).toUpperCase();
+    }
+
+    /**
+     * @return Returns the transportProtocol.
+     */
+    public TransportProtocol getTransportProtocol()
+    {
+        return transportProtocol;
+    }
+
+    /**
+     * @param transportProtocol
+     *            The transportProtocol to set.
+     */
+    public void setTransportProtocol( TransportProtocol transportProtocol )
+    {
+        this.transportProtocol = transportProtocol;
+    }
+
+    /**
+     * @return Returns the ttl.
+     */
+    public int getTTL()
+    {
+        return ttl;
+    }
+
+    /**
+     * @param ttl
+     *            The ttl to set.
+     */
+    public void setTTL( int ttl )
+    {
+        this.ttl = ttl;
+    }
+
+    public void setSource( String source )
+    {
+        this.source = source;
+    }
+
+    public String getSource()
+    {
+        return source;
+    }
+
+    /**
+     * Get the value part in a string like:
+     * 
+     * &lt;pre&gt;
+     * key = value
+     * &lt;/pre&gt;
+     * 
+     * @param str
+     *            the content string
+     * @return a String containing only the value
+     */
+    private static String _getStrValue( String str )
+    {
+        String val = null;
+
+        String[] list = str.split( &quot;=&quot; );
+        if ( list.length != 2 )
+            return null;
+
+        val = list[1];
+        if ( val.startsWith( &quot;\&quot;&quot; ) &amp;&amp; val.endsWith( &quot;\&quot;&quot; ) )
+            val = val.substring( 1, val.length() - 2 );
+
+        return val;
+    }
+
+    /**
+     * Get the value part in a string like:
+     * 
+     * &lt;pre&gt;
+     * key = 6344 - 6345
+     * &lt;/pre&gt;
+     * 
+     * @param str
+     *            the content string
+     * @return a int[2] containing only the value
+     */
+    private static int[] _getPairValue( String str )
+    {
+        int[] pair = { 0, 0 };
+        String[] list = str.split( &quot;=&quot; );
+        if ( list.length != 2 )
+            return pair;
+
+        try {
+            pair[0] = Integer.parseInt( list[1].split( &quot;-&quot; )[0] );
+            pair[1] = Integer.parseInt( list[1].split( &quot;-&quot; )[1] );
+
+            // log.debug(&quot;Client ports: {}&quot;, 1);
+            // Integers.parse();
+
+        } catch ( Exception e ) {
+            return pair;
+        }
+        return pair;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -62,14 +62,15 @@
 		return transportList.size();
 	}
 
-	public String toString()
+	@Override
+    public String toString()
 	{
-		StringBuilder buf = new StringBuilder();
+		final StringBuilder buf = new StringBuilder();
 		int i = 0;
-		for ( RtspTransport t : transportList ) {
+		for ( RtspTransport transport : transportList ) {
 			if ( i++ != 0 )
-				buf.append( &quot;,&quot; );
-			buf.append( t.toString() );
+				buf.append( ',' );
+			buf.append( transport.toString() );
 		}
 		return buf.toString();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/package.html
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/package.html	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/package.html	2006-04-14 15:41:06 UTC (rev 415)
@@ -10,4 +10,4 @@
 &lt;!-- $URL$ --&gt;
 RTSP implementation classes.
 &lt;/body&gt;
-&lt;/html&gt;
\ No newline at end of file
+&lt;/html&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000100.html">[Rtspproxy-devel] r416 - in trunk: . RTSPProxy-App RTSPProxy-App/src/main/java/rtspproxy/filter/accounting RTSPProxy-App/src/main/java/rtspproxy/filter/authentication RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite RTSPProxy-App/src/resources/conf RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress RTSPProxy-Core RTSPProxy-Core/src RTSPProxy-Core/src/main/java/gov/nist/core RTSPProxy-Core/src/main/java/gov/nist/javax/sdp RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser RTSPProxy-Core/src/main/java/javax/sdp RTSPProxy-Core/src/main/java/rtspproxy RTSPProxy-Core/src/main/java/rtspproxy/config RTSPProxy-Core/src/main/java/rtspproxy/filter RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme RTSPProxy-Core/src/main/java/rtspproxy/filte! r/control RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking RTSPProxy-Core/src/main/java/rtspproxy/jmx RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans RTSPProxy-Core/src/main/java/rtspproxy/lib RTSPProxy-Core/src/main/java/rtspproxy/lib/number RTSPProxy-Core/src/main/java/rtspproxy/proxy RTSPProxy-Core/src/main/java/rtspproxy/proxy/track RTSPProxy-Core/src/main/java/rtspproxy/rdt RTSPProxy-Core/src/main/java/rtspproxy/rtp/range RTSPProxy-Core/src/main/java/rtspproxy/rtsp RTSPProxy-Core/src/test/java/rtspproxy/lib/number RTSPProxy-Core/src/test/java/rtspproxy/rdt RTSPProxy-Core/src/test/java/rtspproxy/rtsp RTSPProxy-Core/src/test/resources/rtspproxy/rdt RTSPProxy-OSGi src/changes src/site
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#99">[ date ]</a>
              <a href="thread.html#99">[ thread ]</a>
              <a href="subject.html#99">[ subject ]</a>
              <a href="author.html#99">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/rtspproxy-devel">More information about the Rtspproxy-devel
mailing list</a><br>
</body></html>
