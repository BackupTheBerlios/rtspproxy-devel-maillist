From merlimat at berlios.de  Fri Apr 14 17:42:30 2006
From: merlimat at berlios.de (merlimat at berlios.de)
Date: Fri, 14 Apr 2006 17:42:30 +0200
Subject: [Rtspproxy-devel] r415 - in trunk: RTSPProxy-App RTSPProxy-App/src/main/java/rtspproxy RTSPProxy-App/src/main/java/rtspproxy/filter/accounting RTSPProxy-App/src/resources/conf RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress RTSPProxy-Core RTSPProxy-Core/src/main/java/gov/nist/javax/sdp RTSPProxy-Core/src/main/java/javax/sdp RTSPProxy-Core/src/main/java/rtspproxy RTSPProxy-Core/src/main/java/rtspproxy/config RTSPProxy-Core/src/main/java/rtspproxy/filter RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme RTSPProxy-Core/src/main/java/rtspproxy/filter/control RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking RTSPProxy-Core/src/main/java/rtspproxy/jmx RTSPProxy-Core/src/main/java/rtspproxy/lib RTSPProxy-Core/src/main/java/rtspproxy/lib/number RTSPProxy-Core/src/main/java/rtspproxy/proxy RTSPProxy-Core/src/main/java/rtspproxy/proxy/track RTSPProxy-!
 Core/src/main/java/rtspproxy/rdt RTSPProxy-Core/src/main/java/rtspproxy/rtp/range RTSPProxy-Core/src/main/java/rtspproxy/rtsp
Message-ID: <200604141542.k3EFgUE3025362@sheep.berlios.de>

Author: merlimat
Date: 2006-04-14 17:41:06 +0200 (Fri, 14 Apr 2006)
New Revision: 415

Added:
   trunk/RTSPProxy-App/src/resources/conf/user.properties
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java
Removed:
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerListParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringListParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/transport/
Modified:
   trunk/RTSPProxy-App/
   trunk/RTSPProxy-App/pom.xml
   trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java
   trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java
   trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml
   trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml
   trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java
   trunk/RTSPProxy-Core/
   trunk/RTSPProxy-Core/pom.xml
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java
   trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactoryException.java
   trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpParseException.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtClientService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtServerService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/Reactor.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/RtspService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/ShutdownHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/BooleanParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Parameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/Credentials.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/DigestAuthentication.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Authenticator.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/ParametersMBean.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/NetworkInterface.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Npt.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/PortManager.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Singleton.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRdtPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientSide.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxySession.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRdtPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtcpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerSide.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RdtTrack.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RtpTrack.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspCode.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspDecoder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspMessage.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspRequest.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspResponse.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspSession.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransport.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/package.html
Log:
Big code synchronization and refactoring.


Property changes on: trunk/RTSPProxy-App
___________________________________________________________________
Name: svn:ignore
   + 
target


Modified: trunk/RTSPProxy-App/pom.xml
===================================================================
--- trunk/RTSPProxy-App/pom.xml	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/pom.xml	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,13 +6,14 @@
 		$Id$
 		$URL$
 	-->
-        <parent>
-                <groupId>net.merlimat</groupId>
-                <artifactId>rtspproxy</artifactId>
-                <version>3.0-ALPHA5-SNAPSHOT</version>
-		<relativePath>../pom.xml</relativePath>
-        </parent>
 
+	<parent>
+		<groupId>net.merlimat</groupId>
+		<artifactId>rtspproxy</artifactId>
+		<version>3.0-ALPHA5-SNAPSHOT</version>
+		<!--	<relativePath>../pom.xml</relativePath> -->
+	</parent>
+
 	<modelVersion>4.0.0</modelVersion>
 
 	<name>RTSP Proxy standalone application</name>
@@ -24,41 +25,22 @@
 
 
 	<dependencies>
-
-    <dependency>
-      <groupId>net.merlimat</groupId>
-      <artifactId>RTSPProxy-Core</artifactId>
-      <version>3.0-ALPHA5-SNAPSHOT</version>
-    </dependency>
-
 		<dependency>
-			<groupId>org.slf4j</groupId>
-			<artifactId>slf4j-log4j12</artifactId>
-			<version>1.0-rc3</version>
+			<groupId>net.merlimat</groupId>
+			<artifactId>RTSPProxy-Core</artifactId>
+			<version>3.0-ALPHA5-SNAPSHOT</version>
 		</dependency>
-
+		
 		<dependency>
-			<groupId>log4j</groupId>
-			<artifactId>log4j</artifactId>
-			<version>1.2.9</version>
-		</dependency>
-
-		<dependency>
 			<groupId>junit</groupId>
 			<artifactId>junit</artifactId>
 			<version>3.8.1</version>
 			<scope>test</scope>
 		</dependency>
+		
 	</dependencies>
-<!--
-	<repositories>
-		<repository>
-		<id>Apache repository</id>
-		<url>http://svn.apache.org/repository/</url>
-		</repository>
-	</repositories>
--->
 
+
 	<build>
 		<defaultGoal>assembly:directory</defaultGoal>
 

Modified: trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -19,6 +19,7 @@
 
 import java.io.File;
 import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.log4j.BasicConfigurator;
 import org.apache.log4j.Logger;
@@ -35,88 +36,90 @@
 public class Main
 {
 
-	static Logger log = Logger.getLogger( "rtspproxy" );
+    static Logger log = Logger.getLogger( "rtspproxy" );
 
-	public static void main( String[] args )
-	{
-		// Configure the logger with default settings
-		// useful to track pre-config file errors
-		BasicConfigurator.configure();
+    public static void main( String[] args )
+    {
+        // Configure the logger with default settings
+        // useful to track pre-config file errors
+        BasicConfigurator.configure();
 
-		// Register the signal handler
-		Runtime.getRuntime().addShutdownHook( new ShutdownHandler() );
+        // Register the signal handler
+        Runtime.getRuntime().addShutdownHook( new ShutdownHandler() );
 
-		try {
-			// Read configuration files
-			new Config();
+        try {
+            // Read configuration files
+            new Config();
 
-			// Log4J configuration
-			ArrayList<String> log4jList = new ArrayList<String>();
-			
-			// system wide configuration (typical on un*x-like systems)
-			log4jList.add("/etc/rtspproxy.log4j.");
-			
-			// Per-user configuration
-			log4jList.add(System.getProperty( "user.home", "" ) + "/.rtspproxy.log4j.");
+            // Log4J configuration
+            List<String> log4jList = new ArrayList<String>();
 
-			// RtspProxy home folder
-			if(Config.getHome() != null)
-				log4jList.add(Config.getHome() + "/conf/rtspproxy.log4j.");
+            // system wide configuration (typical on un*x-like systems)
+            log4jList.add( "/etc/rtspproxy.log4j." );
 
-			// Current directory configuration
-			log4jList.add("rtspproxy.log4j.");
+            // Per-user configuration
+            log4jList.add( System.getProperty( "user.home", "" ) + "/.rtspproxy.log4j." );
 
-			// Used for testing purposes:
-			// checks for the configuration file
-			log4jList.add("src/resources/conf/rtspproxy.log4j.");
+            // RtspProxy home folder
+            if ( Config.getHome() != null )
+                log4jList.add( Config.getHome() + "/conf/rtspproxy.log4j." );
 
-			for(String path : log4jList) {
-				File propFile = new File(path + "properties");
-				File xmlFile = new File(path + "xml");
-				
-				if(propFile.canRead())
-					PropertyConfigurator.configure(propFile.toURL());
-				else if(xmlFile.canRead())
-					DOMConfigurator.configure(xmlFile.toURL());
-			}
-			
-			ArrayList<String> pathlist = new ArrayList<String>();
+            // Current directory configuration
+            log4jList.add( "rtspproxy.log4j." );
 
-			// System wide configuration (tipical in unix systems)
-			pathlist.add("/etc/rtspproxy.conf.xml");
-			
-			// Per user config
-			pathlist.add(System.getProperty( "user.home", "" ) + "/.rtspproxy.conf.xml");
+            // Used for testing purposes:
+            // checks for the configuration file
+            log4jList.add( "src/resources/conf/rtspproxy.log4j." );
 
-			// RtspProxy home folder
-			if(Config.getHome() != null)
-				pathlist.add(Config.getHome() + "/conf/rtspproxy.conf.xml");
+            for ( String path : log4jList ) {
+                File propFile = new File( path + "properties" );
+                File xmlFile = new File( path + "xml" );
 
-			// Current directory configuration
-			pathlist.add("rtspproxy.conf.xml");
+                if ( propFile.canRead() ) {
+                    PropertyConfigurator.configure( propFile.toURL() );
+                    
+                } else if ( xmlFile.canRead() ) {
+                    DOMConfigurator.configure( xmlFile.toURL() );
+                }
+            }
 
-			// Used for testing purposes:
-			// checks for the configuration file
-			pathlist.add("src/resources/conf/rtspproxy.conf.xml");
+            List<String> pathlist = new ArrayList<String>();
 
-			XMLConfigReader configReader = new XMLConfigReader();
-			
-			for ( String path : pathlist ) {
-				configReader.readConfig(path);
-			}
+            // System wide configuration (tipical in unix systems)
+            pathlist.add( "/etc/rtspproxy.conf.xml" );
 
-			if ( log.isDebugEnabled() ) {
-				log.debug( Config.debugParameters() );
-			}
-			
-			Reactor.setStandalone( true );
-			Reactor.start();
+            // Per user config
+            pathlist.add( System.getProperty( "user.home", "" ) + "/.rtspproxy.conf.xml" );
 
-		} catch ( Exception e ) {
-			log.fatal( "Exception in the reactor: ", e );
-			Exceptions.logStackTrace( e );
-			System.exit( -1 );
-		}
-	}
+            // RtspProxy home folder
+            if ( Config.getHome() != null )
+                pathlist.add( Config.getHome() + "/conf/rtspproxy.conf.xml" );
 
+            // Current directory configuration
+            pathlist.add( "rtspproxy.conf.xml" );
+
+            // Used for testing purposes:
+            // checks for the configuration file
+            pathlist.add( "src/resources/conf/rtspproxy.conf.xml" );
+
+            XMLConfigReader configReader = new XMLConfigReader();
+
+            for ( String path : pathlist ) {
+                configReader.readConfig( path );
+            }
+
+            if ( log.isDebugEnabled() ) {
+                log.debug( Config.debugParameters() );
+            }
+
+            Reactor.setStandalone( true );
+            Reactor.start();
+
+        } catch ( Exception e ) {
+            log.fatal( "Exception in the reactor: ", e );
+            Exceptions.logStackTrace( e );
+            System.exit( -1 );
+        }
+    }
+
 }

Modified: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -17,69 +17,72 @@
 /**
  * @author Matteo Merli
  */
-public class SimpleAccountingProvider extends AccountingProviderAdapter 
-implements AccountingProvider,  AAAConfigurable
+public class SimpleAccountingProvider extends AccountingProviderAdapter implements
+        AccountingProvider, AAAConfigurable
 {
 
-	private static String datePattern = "yyyy-MM-dd HH:mm:ss Z";
-	private static SimpleDateFormat format = new SimpleDateFormat( datePattern );
+    private static SimpleDateFormat format = new SimpleDateFormat(
+            "yyyy-MM-dd HH:mm:ss Z" );
 
-	// This is not static since it's a separate log
-	private Logger accessLog;
+    // This is not static since it's a separate log
+    private Logger accessLog;
 
-	public SimpleAccountingProvider()
-	{
-		accessLog = Logger.getLogger( "accessLog" );
-	}
+    public SimpleAccountingProvider()
+    {
+        accessLog = Logger.getLogger( "accessLog" );
+    }
 
-	public void messageReceived( IoSession session, RtspMessage message )
-	{
-		StringBuilder logMessage = new StringBuilder();
-		if ( message instanceof RtspRequest ) {
-			logMessage.append( ( (RtspRequest) message ).getVerb() ).append( " " );
-			logMessage.append( ( (RtspRequest) message ).getUrl() );
-		}
-		accessLog.info( buildLogMessage( session, message, logMessage ) );
-	}
+    @Override
+    public void messageReceived( IoSession session, RtspMessage message )
+    {
+        StringBuilder logMessage = new StringBuilder();
+        if ( message instanceof RtspRequest ) {
+            logMessage.append( ((RtspRequest) message).getVerb() ).append( " " );
+            logMessage.append( ((RtspRequest) message).getUrl() );
+        }
+        accessLog.info( buildLogMessage( session, message, logMessage ) );
+    }
 
-	public void messageSent( IoSession session, RtspMessage message )
-	{
-		StringBuilder logMessage = new StringBuilder();
-		accessLog.info( buildLogMessage( session, message, logMessage ) );
-	}
+    @Override
+    public void messageSent( IoSession session, RtspMessage message )
+    {
+        StringBuilder logMessage = new StringBuilder();
+        accessLog.info( buildLogMessage( session, message, logMessage ) );
+    }
 
+    private static String buildLogMessage( IoSession session, RtspMessage message,
+            StringBuilder logMessage )
+    {
+        StringBuilder sb = new StringBuilder( 150 );
+        String userName = (String) session.getAttribute( AuthenticationFilter.ATTR );
+        String userAgent = message.getHeader( "User-Agent" );
+        Date now = new Date();
+        String dateString = format.format( now );
 
-	private static String buildLogMessage( IoSession session, RtspMessage message,
-			StringBuilder logMessage )
-	{
-		StringBuilder sb = new StringBuilder( 150 );
-		String userName = (String) session.getAttribute( AuthenticationFilter.ATTR );
-		String userAgent = message.getHeader( "User-Agent" );
-		Date now = new Date();
-		String dateString = format.format( now );
+        sb.append( ((InetSocketAddress) session.getRemoteAddress()).getAddress()
+                .getHostAddress() );
+        sb.append( " - " );
+        sb.append( userName != null ? userName : '-' ).append( ' ' );
+        sb.append( '[' ).append( dateString ).append( "] " );
+        sb.append( '"' ).append( logMessage ).append( "\" " );
+        if ( userAgent != null ) {
+            sb.append( '"' ).append( userAgent ).append( "\" " );
+        }
 
-		sb.append( ( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getHostAddress() );
-		sb.append( " - " );
-		sb.append( userName != null ? userName : "-" ).append( " " );
-		sb.append( "[" ).append( dateString ).append( "] " );
-		sb.append( "\"" ).append( logMessage ).append( "\" " );
-		if ( userAgent != null ) {
-			sb.append( "\"" ).append( userAgent ).append( "\" " );
-		}
+        return sb.toString();
+    }
 
-		return sb.toString();
-	}
+    public void configure( List<Element> configElements ) throws Exception
+    {
+        for ( Element el : configElements ) {
+            if ( el.getName().equals( "category" ) ) {
+                String category = el.getTextTrim();
 
-	public void configure(List<Element> configElements) throws Exception {
-		for(Element el : configElements) {
-			if(el.getName().equals("category")) {
-				String category = el.getTextTrim();
-				
-				if(category == null || category.length() == 0) 					
-					throw new IllegalArgumentException("invalid log category given");
-				
-				accessLog = Logger.getLogger(category);
-			}
-		}
-	}
+                if ( category == null || category.length() == 0 )
+                    throw new IllegalArgumentException( "invalid log category given" );
+
+                accessLog = Logger.getLogger( category );
+            }
+        }
+    }
 }

Modified: trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml
===================================================================
--- trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,83 +1,178 @@
+<!-- $Id$ -->
+
 <rtspproxy>
-  <threadPoolSize>10</threadPoolSize>
-  <proxy>
-    <rtspPort>554</rtspPort>
-	<server>
-		<rtpPort>6970</rtpPort>
-		<rtcpPort>6971</rtcpPort>
-		<rdtPort>6972</rdtPort>
-		<address>10.0.0.24</address>
-		<!-- interface>eth0</interface -->
-		<rtpUsePortrange>false</rtpUsePortrange>
-		<rtpPortrange>
-			<minPort>9000</minPort>
-			<maxPort>9100</maxPort>
-			<idleTimeout>120</idleTimeout>
-			<idleScanInterval>60</idleScanInterval>
-			<threadPoolSize>10</threadPoolSize>
-		</rtpPortrange>
-	</server>
-    <client>
-      <rtpPort>6970</rtpPort>
-      <rtcpPort>6971</rtcpPort>
-      <rdtPort>6972</rdtPort>
-      <address>10.0.0.23</address>
-      <!-- interface>eth1</interface -->
-    </client>
-	<transport>
-		<rtp>true</rtp>
-		<rdt>true</rdt>
-		<hacks>
-			<lowerTransportSuppress>false</lowerTransportSuppress>
-			<offerRemoteSsrc>false</offerRemoteSsrc>
-		</hacks>
-	</transport>
-	<streaming>
-		<hacks>
-			<rtpSsrcUnreliable>false</rtpSsrcUnreliable>
-		</hacks>
-	</streaming>
-  </proxy>
-  <jmx>
-    <manageable>true</manageable>
-    <address>10.0.0.22</address>
-    <user>admin</user>
-    <password>admin123</password>
-    <web>
-      <manageable>true</manageable>
-      <port>8080</port>
-    </web>
-    <connectorService>
-      <manageable>true</manageable>
-    </connectorService>
-  </jmx>
-  <filters>
-    <authentication implClass="rtspproxy.filter.authentication.SimpleAuthenticationProvider" scheme="Digest" side="client">
-      <user>
-	<name>myuser</name>
-	<password>itspassword</password>
-      </user>
-    </authentication>
-    <ipaddress implClass="rtspproxy.filter.ipaddress.SimpleIpAddressProvider" side="client">
-      <deny>*</deny>
-      <allow>127.0.0.1</allow>
-      <allow>10.0.0.*</allow>
-      <allow>*.some.domain</allow>
-    </ipaddress>
-    <ipaddress implClass="rtspproxy.filter.ipaddress.SimpleIpAddressProvider" side="server">
-      <deny>*</deny>
-      <allow>127.0.0.1</allow>
-      <allow>10.0.0.*</allow>
-      <allow>*.some.domain</allow>
-    </ipaddress>
-    <accounting implClass="rtspproxy.filter.accounting.SimpleAccountingProvider" >
-      <category>accounting.rtspproxy</category>
-    </accounting>
-	<rewriting implClass="rtspproxy.filter.rewrite.SimpleUrlRewritingProvider" side="client">
-		<mapping>
-			<from>rtsp://10.0.0.1:554/</from>
-			<to>rtsp://10.0.0.2:1554/foo/</to>
-		</mapping>
-	</rewriting>
-  </filters>
+
+	<debug>true</debug>
+
+	<!-- Thread pool configuration. Number of active threads. -->
+	<threadPoolSize>10</threadPoolSize>
+
+	<proxy>
+
+		<!-- TCP port to be used for incoming RTSP connection from clients. -->
+		<rtspPort>5540</rtspPort>
+
+		<!-- Server-side configuration -->
+		<server>
+			<!-- <rtpPort>6970</rtpPort> -->
+			<!-- <rtcpPort>6971</rtcpPort> -->
+			<!-- <rdtPort>6972</rdtPort> -->
+			<!-- <address>10.0.0.24</address> -->
+
+			<!-- 
+				<rtpUsePortrange>false</rtpUsePortrange>
+				
+				<rtpPortrange>
+				<minPort>9000</minPort>
+				<maxPort>9100</maxPort>
+				<idleTimeout>120</idleTimeout>
+				<idleScanInterval>60</idleScanInterval>
+				<threadPoolSize>10</threadPoolSize>
+				</rtpPortrange>
+			-->
+		</server>
+
+
+		<client>
+			<!-- 
+				<rtpPort>6970</rtpPort>
+				<rtcpPort>6971</rtcpPort>
+				<rdtPort>6972</rdtPort>
+				<address>127.0.0.1</address>
+			-->
+			<interface>lo0</interface>
+		</client>
+
+		<!-- Proxy feature selection -->
+		<transport>
+			<!-- Enable RTP based streaming -->
+			<rtp>true</rtp>
+
+			<!-- Enable Real/RDT based streaming -->
+			<rdt>true</rdt>
+
+			<!-- These are some special case handling -->
+			<hacks>
+				<lowerTransportSuppress>false</lowerTransportSuppress>
+				<offerRemoteSsrc>false</offerRemoteSsrc>
+				<rtpSsrcUnreliable>false</rtpSsrcUnreliable>
+			</hacks>
+
+		</transport>
+
+	</proxy>
+
+	<!-- Management Interface -->
+	<jmx>
+		<!-- Enable or disable the JMX interface -->
+		<enable>true</enable>
+
+		<!-- Bound the JMX service to a local address. -->
+		<address>127.0.0.1</address>
+
+		<!-- Username and password to access the management interfaces -->
+		<user>admin</user>
+		<password>password</password>
+
+		<!-- JMX web console -->
+		<web>
+			<enable>true</enable>
+			<port>8080</port>
+		</web>
+
+		<!-- JMX remote service -->
+		<connectorService>
+			<!-- Enable or disable the TCP connector for JMX -->
+			<enable>true</enable>
+		</connectorService>
+	</jmx>
+
+	<!-- Filters are the mean layered functionalities such as Authentication or 
+		Tracking are implemented.
+	-->
+	<filters>
+
+		<!-- Authentication filter -->
+		<authentication>
+
+			<enable>false</enable>
+
+			<implClass>
+				rtspproxy.filter.authentication.SimpleAuthenticationProvider
+			</implClass>
+
+			<!-- Authentication Scheme: 
+				can be 'Basic' or 'Digest'
+			-->
+			<scheme>Digest</scheme>
+
+			<usersFile>conf/users.properties</usersFile>
+		</authentication>
+
+		<!-- Filter clients using theyr IP address -->
+		<ipaddress
+			implClass="rtspproxy.filter.ipaddress.SimpleIpAddressProvider"
+			side="client">
+
+			<!-- Enable or disable the ipaddress filter -->
+			<enabled>false</enabled>
+
+			<rules>
+				<rule type="deny" pattern="*" />
+				<allow>127.0.0.1</allow>
+				<allow>10.0.0.*</allow>
+				<allow>*.some.domain</allow>
+			</rules>
+		</ipaddress>
+
+		<ipaddress
+			implClass="rtspproxy.filter.ipaddress.SimpleIpAddressProvider"
+			side="server">
+
+			<!-- Enable or disable the ipaddress filter -->
+			<enable>false</enable>
+
+			<rules>
+				<deny>*</deny>
+				<allow>127.0.0.1</allow>
+				<allow>10.0.0.*</allow>
+				<allow>*.some.domain</allow>
+			</rules>
+		</ipaddress>
+
+
+		<accounting>
+
+			<!-- Enable or disable the ipaddress filter -->
+			<enable>false</enable>
+
+			<implClass>
+				rtspproxy.filter.accounting.SimpleAccountingProvider
+			</implClass>
+
+			<category>accounting.rtspproxy</category>
+		</accounting>
+
+
+		<rewriting>
+
+			<!-- enable or disable the rewriting filter -->
+			<enable>false</enable>
+
+			<!-- Class implementing the rewriting filter -->
+			<implClass>
+				rtspproxy.filter.rewrite.SimpleUrlRewritingProvider
+			</implClass>
+
+			<!-- Rewriting rules -->
+			<rules>
+				<mapping from="rtsp://10.0.0.1:554/"
+					       to="rtsp://10.0.0.2:1554/foo/" />
+
+				<mapping from="rtsp://127.0.0.01/" 
+					 		   to="rtsp://10.0.0.26:1554/foo/" />
+			</rules>
+		</rewriting>
+	</filters>
+
 </rtspproxy>

Modified: trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml
===================================================================
--- trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml	2006-04-14 15:41:06 UTC (rev 415)
@@ -10,69 +10,80 @@
 <!-- $Id$ -->
 
 <!--
-   | For more configuration infromation and examples see the Jakarta Log4j
-   | owebsite: http://jakarta.apache.org/log4j
- -->
+	| For more configuration infromation and examples see the Jakarta Log4j
+	| owebsite: http://jakarta.apache.org/log4j
+-->
 
-<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/" debug="false">
+<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"
+	debug="false">
 
-   <!-- ================================= -->
-   <!-- Preserve messages in a local file -->
-   <!-- ================================= -->
+	<!-- ================================= -->
+	<!-- Preserve messages in a local file -->
+	<!-- ================================= -->
 
-   <!-- A time/date based rolling appender -->
-   <appender name="FILE" class="org.apache.log4j.FileAppender">
-      <param name="File" value="/tmp/rtspproxy.log"/>
-      <param name="Append" value="false"/>
+	<!-- A time/date based rolling appender -->
+	<appender name="FILE" class="org.apache.log4j.FileAppender">
+		<param name="File" value="/tmp/rtspproxy.log" />
+		<param name="Append" value="false" />
 
-      <layout class="org.apache.log4j.PatternLayout">
-         <!-- The default pattern: Date Priority [Category] Message\n -->
-         <param name="ConversionPattern" value="%9r %5p [%t] %c - %m%n"/>
+		<layout class="org.apache.log4j.PatternLayout">
+			<!-- The default pattern: Date Priority [Category] Message\n -->
+			<param name="ConversionPattern"
+				value="%9r %5p [%t] %c - %m%n" />
 
-         <!-- The full pattern: Date MS Priority [Category] (Thread:NDC) Message\n
-         <param name="ConversionPattern" value="%d %-5r %-5p [%c] (%t:%x) %m%n"/>
-          -->
-      </layout>
-   </appender>
+			<!-- The full pattern: Date MS Priority [Category] (Thread:NDC) Message\n
+				<param name="ConversionPattern" value="%d %-5r %-5p [%c] (%t:%x) %m%n"/>
+			-->
+		</layout>
+	</appender>
 
-   <!-- A time/date based rolling appender -->
-   <appender name="ACCOUNTING" class="org.apache.log4j.FileAppender">
-      <param name="File" value="/tmp/rtspproxy-accounting.log"/>
-      <param name="Append" value="true"/>
+	<!-- A time/date based rolling appender -->
+	<appender name="ACCOUNTING" class="org.apache.log4j.FileAppender">
+		<param name="File" value="/tmp/rtspproxy-accounting.log" />
+		<param name="Append" value="true" />
 
-      <layout class="org.apache.log4j.PatternLayout">
-         <!-- The default pattern: Date Priority [Category] Message\n -->
-         <param name="ConversionPattern" value="%m%n"/>
-      </layout>
-   </appender>
+		<layout class="org.apache.log4j.PatternLayout">
+			<!-- The default pattern: Date Priority [Category] Message\n -->
+			<param name="ConversionPattern" value="%m%n" />
+		</layout>
+	</appender>
 
-   <!-- ============================== -->
-   <!-- Append messages to the console -->
-   <!-- ============================== -->
+	<!-- ============================== -->
+	<!-- Append messages to the console -->
+	<!-- ============================== -->
 
-   <appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
-      <param name="Target" value="System.out"/>
-      <param name="Threshold" value="INFO"/>
+	<appender name="CONSOLE" class="org.apache.log4j.ConsoleAppender">
+		<param name="Target" value="System.out" />
 
-      <layout class="org.apache.log4j.PatternLayout">
-         <!-- The default pattern: Date Priority [Category] Message\n -->
-         <param name="ConversionPattern" value="%9r %5p [%t] %c - %m%n"/>
-      </layout>
-   </appender>
+		<layout class="org.apache.log4j.PatternLayout">
+			<!-- The default pattern: Date Priority [Category] Message\n -->
+			<param name="ConversionPattern"
+				value="%9r %5p [%t] %c - %m%n" />
+		</layout>
+	</appender>
 
-   <category name="accounting.rtspproxy" >
-      <priority value="INFO" />
-      <appender-ref ref="ACCOUNTING" />
-   </category>
+	<category name="accounting.rtspproxy">
+		<priority value="INFO" />
+		<appender-ref ref="ACCOUNTING" />
+	</category>
+	
+	<category name="rtspproxy.rtsp.RtspDecoder">
+		<priority value="INFO" />
+	</category>
+	
+	<category name="rtspproxy.ProxyService">
+		<priority value="INFO" />
+	</category>
 
-   <!-- ======================= -->
-   <!-- Setup the Root category -->
-   <!-- ======================= -->
+	<!-- ======================= -->
+	<!-- Setup the Root category -->
+	<!-- ======================= -->
 
-   <root>
-      <priority value="DEBUG"/>
-      <appender-ref ref="CONSOLE"/>
-      <appender-ref ref="FILE"/>
-   </root>
+	<root>
+		<priority value="INFO" />
+		
+		<appender-ref ref="CONSOLE" />
+		<!-- appender-ref ref="FILE" / -->
+	</root>
 
 </log4j:configuration>

Added: trunk/RTSPProxy-App/src/resources/conf/user.properties
===================================================================
--- trunk/RTSPProxy-App/src/resources/conf/user.properties	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/resources/conf/user.properties	2006-04-14 15:41:06 UTC (rev 415)
@@ -0,0 +1,7 @@
+
+## User Databases
+# 
+# Insert users in the form: 
+
+user: password
+joe: test


Property changes on: trunk/RTSPProxy-App/src/resources/conf/user.properties
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java
===================================================================
--- trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -20,8 +20,6 @@
 import java.io.StringReader;
 import java.net.InetAddress;
 
-import rtspproxy.filter.ipaddress.SimpleIpAddressProvider;
-
 import junit.framework.TestCase;
 
 /**


Property changes on: trunk/RTSPProxy-Core
___________________________________________________________________
Name: svn:ignore
   + 
target


Modified: trunk/RTSPProxy-Core/pom.xml
===================================================================
--- trunk/RTSPProxy-Core/pom.xml	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/pom.xml	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,12 +6,13 @@
 		$Id$
 		$URL$
 	-->
-        <parent>
-                <groupId>net.merlimat</groupId>
-                <artifactId>rtspproxy</artifactId>
-                <version>3.0-ALPHA5-SNAPSHOT</version>
-        </parent>
 
+	<parent>
+		<groupId>net.merlimat</groupId>
+		<artifactId>rtspproxy</artifactId>
+		<version>3.0-ALPHA5-SNAPSHOT</version>
+	</parent>
+
 	<modelVersion>4.0.0</modelVersion>
 
 	<name>RTSP Proxy core</name>
@@ -22,32 +23,51 @@
 	<inceptionYear>2003</inceptionYear>
 
 	<dependencies>
-		
+
 		<dependency>
-			<groupId>directory-network</groupId>
-			<artifactId>mina</artifactId>
-			<version>0.9.0</version>
+			<groupId>org.apache.directory.mina</groupId>
+			<artifactId>mina-core</artifactId>
+			<version>0.9.3</version>
 		</dependency>
-		
+
 		<dependency>
 			<groupId>mx4j</groupId>
 			<artifactId>mx4j-tools</artifactId>
 			<version>2.1.1</version>
 		</dependency>
-		
+
 		<dependency>
-			<groupId>dom4j</groupId>
-			<artifactId>dom4j</artifactId>
-			<version>1.6.1</version>
+			<groupId>org.slf4j</groupId>
+			<artifactId>slf4j-log4j12</artifactId>
+			<version>1.0-rc3</version>
 		</dependency>
-		
+
 		<dependency>
+			<groupId>log4j</groupId>
+			<artifactId>log4j</artifactId>
+			<version>1.2.9</version>
+		</dependency>
+ 
+		<dependency>
 			<groupId>commons-pool</groupId>
 			<artifactId>commons-pool</artifactId>
 			<version>1.2</version>
 		</dependency>
+
+		<dependency>
+			<groupId>commons-configuration</groupId>
+			<artifactId>commons-configuration</artifactId>
+			<version>1.2</version>
+		</dependency>
 		
+		<!-- Included here to disambiguate the version number -->
 		<dependency>
+			<groupId>commons-collections</groupId>
+			<artifactId>commons-collections</artifactId>
+			<version>3.1</version>
+		</dependency>
+
+		<dependency>
 			<groupId>junit</groupId>
 			<artifactId>junit</artifactId>
 			<version>3.8.1</version>
@@ -56,16 +76,25 @@
 	</dependencies>
 
 	<repositories>
-<!--
+
 		<repository>
-		<id>Apache repository</id>
-		<url>http://svn.apache.org/repository/</url>
+			<id>Apache repository</id>
+			<url>http://svn.apache.org/repository/</url>
 		</repository>
--->
+
+		<!-- For snapshots (no release jars or non-apache jars)           -->
 		<repository>
-		<id>ibilio maven1</id>
-		<url>http://www.ibiblio.org/maven/</url>
+			<id>apache.snapshots</id>
+			<name>Apache Snapshot Repository</name>
+			<url>http://cvs.apache.org/maven-snapshot-repository</url>
 		</repository>
+
+		<!--
+			<repository>
+			<id>ibilio maven2</id>
+			<url>http://www.ibiblio.org/maven2/</url>
+			</repository>
+		-->
 	</repositories>
 
 	<build>

Modified: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -76,7 +76,8 @@
 		return retval.toString();
 	}
 
-	public String toString()
+	@Override
+    public String toString()
 	{
 		return this.encode();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactoryException.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactoryException.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactoryException.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -70,7 +70,8 @@
 	 * 
 	 * @return the error message
 	 */
-	public String getMessage()
+	@Override
+    public String getMessage()
 	{
 		if ( super.getMessage() != null )
 			return super.getMessage();

Modified: trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpParseException.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpParseException.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpParseException.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -77,7 +77,8 @@
 	 * 
 	 * @return the message stored when the exception was created.
 	 */
-	public String getMessage()
+	@Override
+    public String getMessage()
 	{
 		return super.getMessage();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,20 +26,19 @@
 import java.util.Observer;
 import java.util.Set;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.IoAcceptor;
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.common.IoHandler;
 import org.apache.mina.common.IoSession;
 import org.apache.mina.common.TransportType;
 import org.apache.mina.filter.ThreadPoolFilter;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.config.Parameter;
 import rtspproxy.lib.Exceptions;
 import rtspproxy.lib.NetworkInterface;
 import rtspproxy.lib.Singleton;
-import rtspproxy.transport.socket.nio.ConnectionlessSessionTracker;
 
 /**
  * ProxyService is the base abstract class for all the "Services" that can be
@@ -50,266 +49,283 @@
 public abstract class ProxyService extends Singleton implements Observer
 {
 
-	private static Logger log = LoggerFactory.getLogger( ProxyService.class );
+    private static Logger log = LoggerFactory.getLogger( ProxyService.class );
 
-	/**
-	 * Main Socket address used by the service. It can be bound on several
-	 * different addresses and network interfaces, but it MUST have a default
-	 * address to be communicated to third parties.
-	 */
-	private InetSocketAddress socketAddress = null;
+    /**
+     * Main Socket address used by the service. It can be bound on several
+     * different addresses and network interfaces, but it MUST have a default
+     * address to be communicated to third parties.
+     */
+    private InetSocketAddress socketAddress = null;
 
-	/**
-	 * Flag used to keep track of the service status.
-	 */
-	private volatile boolean isRunning = false;
+    /**
+     * Flag used to keep track of the service status.
+     */
+    private volatile boolean isRunning = false;
 
-	/**
-	 * Service hook name.
-	 */
-	protected static final String SERVICE = ProxyService.class.getName();
+    /**
+     * Service hook name.
+     */
+    protected static final String SERVICE = ProxyService.class.getName();
 
-	/**
-	 * Starts the service.
-	 * 
-	 * @throws Exception
-	 */
-	public void start() throws Exception
-	{
-		if ( isRunning ) {
-			log.warn( getName() + " is already running." );
-			return;
-		}
+    /**
+     * Starts the service.
+     * 
+     * @throws Exception
+     */
+    public void start() throws Exception
+    {
+        if ( isRunning ) {
+            log.warn( getName() + " is already running." );
+            return;
+        }
 
-		int port = getBindPort();
+        int port = getBindPort();
 
-		try {
-			if (getNetworkAddress() != null) {
-				socketAddress = new InetSocketAddress(getNetworkAddress(), port);
-				log.debug("binding to specific address: " + socketAddress);
+        log.debug( "Service Bind port: {}", port );
 
-				Reactor.getRegistry().bind(this, getIoHandler(),
-						socketAddress, getFilterChainBuilder());				
-			} else {
-				String netInterface = getNetworkInterface();
+        try {
+            if ( getNetworkAddress() != null ) {
+                socketAddress = new InetSocketAddress( getNetworkAddress(), port );
+                log.debug( "binding to specific address: {}", socketAddress );
 
-				Set<InetAddress> addressSet = NetworkInterface.getInterfaceAddresses(netInterface);
+                Reactor.getRegistry().bind( this, getIoHandler(), socketAddress,
+                        getFilterChainBuilder() );
 
-				for (InetAddress inetAddress : addressSet) {
-					// Bind to all addresses
+            } else {
+                String netInterface = getNetworkInterface();
 
-					log.debug("binding to address from set: " + socketAddress);
-					socketAddress = new InetSocketAddress(inetAddress, port);
+                Set<InetAddress> addressSet = NetworkInterface
+                        .getInterfaceAddresses( netInterface );
 
-					Reactor.getRegistry().bind(this, getIoHandler(),
-							socketAddress, getFilterChainBuilder());
+                log.debug( "Network Interface: {} - Addresses: {}", netInterface,
+                        addressSet );
+                if ( addressSet == null ) {
+                    throw new RuntimeException( "Invalid Network interface: "
+                            + netInterface );
+                }
 
-				}
+                for ( InetAddress inetAddress : addressSet ) {
+                    // Bind to all addresses
 
-				// Choose a bind address
-				InetAddress inetAddress = NetworkInterface
-						.getBindAddress(addressSet);
-				socketAddress = new InetSocketAddress(inetAddress, port);
+                    log.debug( "binding to address from set: {}", socketAddress );
+                    socketAddress = new InetSocketAddress( inetAddress, port );
 
-			}
-		} catch (IOException e) {
-			log.error("Can't start " + getName(), e);
-			throw e;
-		}
-		log.info( getName() + " Started - Listening on: " + socketAddress );
+                    Reactor.getRegistry().bind( this, getIoHandler(), socketAddress,
+                            getFilterChainBuilder() );
 
+                }
 
-		isRunning = true;
-	}
+                // Choose a bind address
+                InetAddress inetAddress = NetworkInterface.getBindAddress( addressSet );
+                socketAddress = new InetSocketAddress( inetAddress, port );
 
-	/**
-	 * Stops the service
-	 * 
-	 * @throws Exception
-	 */
-	public void stop() throws Exception
-	{
-		if ( !isRunning ) {
-			log.warn( getName() + " is not running." );
-			return;
-		}
+            }
+        } catch ( IOException e ) {
+            log.error( "Can't start {}: {}", getName(), e );
+            throw e;
+        }
+        log.info( "{} Started - Listening on: {}", getName(), socketAddress );
 
-		log.info( getName() + " Stopped" );
-		isRunning = false;
-	}
+        isRunning = true;
+    }
 
-	/**
-	 * Restart the service.
-	 * 
-	 * @throws Exception
-	 */
-	public void restart() throws Exception
-	{
-		log.info( "Restarting " + getName() );
-		if ( isRunning )
-			stop();
-		else
-			log.warn( getName() + " is not running." );
+    /**
+     * Stops the service
+     * 
+     * @throws Exception
+     */
+    public void stop() throws Exception
+    {
+        if ( !isRunning ) {
+            log.warn( getName() + " is not running." );
+            return;
+        }
 
-		start();
-	}
+        log.info( getName() + " Stopped" );
+        isRunning = false;
+    }
 
-	/**
-	 * @return true if the server is running
-	 */
-	public boolean isRunning()
-	{
-		return isRunning;
-	}
+    /**
+     * Restart the service.
+     * 
+     * @throws Exception
+     */
+    public void restart() throws Exception
+    {
+        log.info( "Restarting {}", getName() );
+        if ( isRunning )
+            stop();
+        else
+            log.warn( getName() + " is not running." );
 
-	/**
-	 * @return the transport type used by this service
-	 */
-	public abstract TransportType getTransportType();
+        start();
+    }
 
-	/**
-	 * @return an instance to the IoHandler object that will receive all the
-	 *         messages.
-	 */
-	public abstract IoHandler getIoHandler();
+    /**
+     * @return true if the server is running
+     */
+    public boolean isRunning()
+    {
+        return isRunning;
+    }
 
-	/**
-	 * @return the filter chain builder to be be used by the IoAcceptor
-	 *         associated with the service.
-	 */
-	public IoFilterChainBuilder getFilterChainBuilder()
-	{
-		// By default there's no filter chain
-		return IoFilterChainBuilder.NOOP;
-	}
+    /**
+     * @return the transport type used by this service
+     */
+    public abstract TransportType getTransportType();
 
-	/**
-	 * Return the name of the service.
-	 * 
-	 * @return the human readable name
-	 */
-	public abstract String getName();
+    /**
+     * @return an instance to the IoHandler object that will receive all the
+     *         messages.
+     */
+    public abstract IoHandler getIoHandler();
 
-	/**
-	 * Get the network interface to bind to. This is only used if there is no more specific
-	 * IP address configured.
-	 * @return the network interface to bind this service on, as it appears in
-	 *         the configuratio registry (Config).
-	 */
-	public abstract String getNetworkInterface();
+    /**
+     * @return the filter chain builder to be be used by the IoAcceptor
+     *         associated with the service.
+     */
+    public IoFilterChainBuilder getFilterChainBuilder()
+    {
+        // By default there's no filter chain
+        return IoFilterChainBuilder.NOOP;
+    }
 
-	/**
-	 * @return the network address to bind this service on, as it appears in
-	 *         the configuratio registry (Config). If null, the network interface
-	 *         configuration parameter is used.
-	 */
-	public abstract String getNetworkAddress();
+    /**
+     * Return the name of the service.
+     * 
+     * @return the human readable name
+     */
+    public abstract String getName();
 
-	/**
-	 * @return the port to bind on, as it appear in the configuration registry.
-	 */
-	public abstract int getBindPort();
+    /**
+     * Get the network interface to bind to. This is only used if there is no
+     * more specific IP address configured.
+     * 
+     * @return the network interface to bind this service on, as it appears in
+     *         the configuratio registry (Config).
+     */
+    public abstract String getNetworkInterface();
 
-	/**
-	 * @return the Parameter associated with the network interface used by the
-	 *         service.
-	 */
-	public abstract Parameter getNetworkInterfaceParameter();
+    /**
+     * @return the network address to bind this service on, as it appears in the
+     *         configuration registry (Config). If null, the network interface
+     *         configuration parameter is used.
+     */
+    public abstract String getNetworkAddress();
 
-	/**
-	 * @return the Parameter associated with the port number used by the
-	 *         service.
-	 */
-	public abstract Parameter getPortParameter();
+    /**
+     * @return the port to bind on, as it appear in the configuration registry.
+     */
+    public abstract int getBindPort();
 
-	/**
-	 * @return the main IP address where the service is bound.
-	 */
-	public InetAddress getAddress()
-	{
-		return socketAddress.getAddress();
-	}
+    /**
+     * @return the Parameter associated with the network interface used by the
+     *         service.
+     */
+    public abstract Parameter getNetworkInterfaceParameter();
 
-	/**
-	 * @return the main TCP or UDP port where the service is bound.
-	 */
-	public int getPort()
-	{
-		return socketAddress.getPort();
-	}
+    /**
+     * @return the Parameter associated with the port number used by the
+     *         service.
+     */
+    public abstract Parameter getPortParameter();
 
-	/**
-	 * @return the TCP or UDP address (IP+port) where the service is bound.
-	 */
-	public SocketAddress getSocketAddress()
-	{
-		return socketAddress;
-	}
+    /**
+     * @return the main IP address where the service is bound.
+     */
+    public InetAddress getAddress()
+    {
+        return socketAddress.getAddress();
+    }
 
-	/**
-	 * Creates a new connection-less IoSession to a remote address. This is only
-	 * used to create UDP session.
-	 * 
-	 * @param remoteAddress
-	 *            the address of the remote host to connect to.
-	 * @return the newly created IoSession
-	 */
-	public synchronized IoSession newSession( SocketAddress remoteAddress )
-	{
-		IoSession session = null;
-		IoAcceptor acceptor = Reactor.getRegistry().getAcceptor( this );
-		
-		if(acceptor instanceof ConnectionlessSessionTracker)
-			session = ((ConnectionlessSessionTracker)acceptor).getSession(socketAddress, remoteAddress);
-		
-		if(session == null) 
-		 session = acceptor.newSession( remoteAddress, socketAddress );
-		
-		return session;
-	}
+    /**
+     * @return the main TCP or UDP port where the service is bound.
+     */
+    public int getPort()
+    {
+        return socketAddress.getPort();
+    }
 
-	/**
-	 * Update the ProxyService state. A proxy service will likely subscribe to
-	 * some parameter changes notifications. When a change is notified the
-	 * service will be restarted.
-	 * <p>
-	 * <i>NOTE:</i>
-	 * <ul>
-	 * <li>if the service is TCP based, all connected clients will be
-	 * disconnected! </li>
-	 * <li>If the service is UDP based some packets may be missed when the
-	 * service is down. </li>
-	 * </ul>
-	 * 
-	 * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
-	 */
-	public void update( Observable o, Object arg )
-	{
-		if ( !(o instanceof Parameter) )
-			throw new IllegalArgumentException( "Only observe parameters" );
+    /**
+     * @return the TCP or UDP address (IP+port) where the service is bound.
+     */
+    public SocketAddress getSocketAddress()
+    {
+        return socketAddress;
+    }
 
-		try {
-			restart();
-		} catch ( Exception e ) {
-			log.error( "Error restarting " + getName() );
-			Exceptions.logStackTrace( e );
-			throw new RuntimeException( e );
-		}
-	}
+    /**
+     * Creates a new connection-less IoSession to a remote address. This is only
+     * used to create UDP session.
+     * 
+     * @param remoteAddress
+     *            the address of the remote host to connect to.
+     * @return the newly created IoSession
+     */
+    public synchronized IoSession newSession( SocketAddress remoteAddress )
+    {
+        IoSession session = null;
+        IoAcceptor acceptor = Reactor.getRegistry().getAcceptor( this );
 
-	/**
-	 * service may provide their own ThreadPoolFilter instances.
-	 * @return a ThreadPoolFilter instance or null if the service wants to use the shared instance.
-	 * 
-	 */
-	public ThreadPoolFilter getThreadPoolFilter() {
-		return null;
-	}
-	
-	/**
-	 * flag if the service wants to use a ThreadPoolFilter at all
-	 */
-	public boolean wantThreadPoolFilter() {
-		return true;
-	}
+        // TODO: ConnectionlessSessionTracker
+        // if(acceptor instanceof ConnectionlessSessionTracker)
+        // session =
+        // ((ConnectionlessSessionTracker)acceptor).getSession(socketAddress,
+        // remoteAddress);
+
+        if ( session == null )
+            session = acceptor.newSession( remoteAddress, socketAddress );
+
+        return session;
+    }
+
+    /**
+     * Update the ProxyService state. A proxy service will likely subscribe to
+     * some parameter changes notifications. When a change is notified the
+     * service will be restarted.
+     * <p>
+     * <i>NOTE:</i>
+     * <ul>
+     * <li>if the service is TCP based, all connected clients will be
+     * disconnected! </li>
+     * <li>If the service is UDP based some packets may be missed when the
+     * service is down. </li>
+     * </ul>
+     * 
+     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
+     */
+    public void update( Observable o, Object arg )
+    {
+        if ( !(o instanceof Parameter) )
+            throw new IllegalArgumentException( "Only observe parameters" );
+
+        try {
+            restart();
+        } catch ( Exception e ) {
+            log.error( "Error restarting {}", getName() );
+            Exceptions.logStackTrace( e );
+            throw new RuntimeException( e );
+        }
+    }
+
+    /**
+     * service may provide their own ThreadPoolFilter instances.
+     * 
+     * @return a ThreadPoolFilter instance or null if the service wants to use
+     *         the shared instance.
+     * 
+     */
+    public ThreadPoolFilter getThreadPoolFilter()
+    {
+        return null;
+    }
+
+    /**
+     * flag if the service wants to use a ThreadPoolFilter at all
+     */
+    public boolean wantThreadPoolFilter()
+    {
+        return true;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -28,8 +28,6 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.IoAcceptor;
 import org.apache.mina.common.IoFilter;
 import org.apache.mina.common.IoFilterChain;
@@ -37,13 +35,14 @@
 import org.apache.mina.common.IoHandler;
 import org.apache.mina.common.TransportType;
 import org.apache.mina.filter.ThreadPoolFilter;
+import org.apache.mina.transport.socket.nio.DatagramAcceptor;
 import org.apache.mina.transport.socket.nio.SocketAcceptor;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;
 import rtspproxy.lib.Singleton;
-import rtspproxy.transport.socket.nio.DatagramAcceptor;
-import rtspproxy.transport.socket.nio.SessionAwareDatagramAcceptor;
 
 /**
  * Custom implementation of the ServiceRegistry interface. Creates an acceptor
@@ -127,8 +126,8 @@
 		
 		IoFilterChainBuilder builder = new IoFilterChainBuilderWrapper( service,
 				filterChainBuilder );
-		// acceptor.setFilterChainBuilder( builder );
-		acceptor.bind( address, ioHandler, builder );
+		acceptor.setFilterChainBuilder( builder );
+		acceptor.bind( address, ioHandler );
 
 		services.put( service.getName(), service );
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtClientService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtClientService.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtClientService.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -18,13 +18,9 @@
 
 package rtspproxy;
 
-import java.net.SocketAddress;
-
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.common.IoHandler;
-import org.apache.mina.common.IoSession;
 import org.apache.mina.common.TransportType;
-import org.apache.mina.filter.ThreadPoolFilter;
 
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;
@@ -52,7 +48,7 @@
 		super();
 
 		// Subscribe to parameter changes
-		Config.proxyClientInterface.addObserver( this );
+		Config.proxyClientAddress.addObserver( this );
 		Config.proxyClientRdtPort.addObserver( this );
 	}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtServerService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtServerService.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/RdtServerService.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -18,13 +18,9 @@
 
 package rtspproxy;
 
-import java.net.SocketAddress;
-
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.common.IoHandler;
-import org.apache.mina.common.IoSession;
 import org.apache.mina.common.TransportType;
-import org.apache.mina.filter.ThreadPoolFilter;
 
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/Reactor.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/Reactor.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/Reactor.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -86,7 +86,7 @@
 		ProxyService rdtServerService = new RdtServerService();
 		rdtServerService.start();
 
-		boolean enableJmx = Config.proxyManagementEnable.getValue();
+		boolean enableJmx = Config.jmxEnable.getValue();
 		if ( enableJmx )
 			jmxAgent = new JmxAgent();
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/RtspService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/RtspService.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/RtspService.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -20,14 +20,10 @@
 
 import java.util.Observable;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.apache.mina.common.IoAcceptor;
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.common.IoHandler;
 import org.apache.mina.common.TransportType;
 
-import rtspproxy.ProxyServiceRegistry.IoFilterChainBuilderWrapper;
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;
 import rtspproxy.filter.RtspClientFilters;
@@ -39,11 +35,9 @@
  */
 public final class RtspService extends ProxyService
 {
+	
+	private final IoHandler rtspHandler = new ClientSide();
 
-	private static Logger log = LoggerFactory.getLogger( RtspService.class );
-
-	private IoHandler rtspHandler = new ClientSide();
-
 	private final IoFilterChainBuilder filterChainBuilder = new RtspClientFilters();
 
 	private static final String NAME = "RtspService";
@@ -54,8 +48,8 @@
 
 		// Subscribe to parameter changes
 		Config.proxyClientInterface.addObserver( this );
+        Config.proxyClientAddress.addObserver( this );
 		Config.proxyRtspPort.addObserver( this );
-
 	}
 
 	@Override

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/ShutdownHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/ShutdownHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/ShutdownHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -34,15 +34,16 @@
 
 	private static Logger log = LoggerFactory.getLogger( ShutdownHandler.class );
 
-	public void run()
+	@Override
+    public void run()
 	{
 		log.info( "Shutting down" );
 		try {
-			log.info( "Stopping " + Config.getName() + " " + Config.getVersion() );
+			log.info( "Stopping {} {}", Config.getName(), Config.getVersion() );
 			Reactor.stop();
 
 		} catch ( Exception e ) {
-			log.error( "Exception in the reactor: " + e );
+			log.error( "Exception in the reactor: ", e );
 			Exceptions.logStackTrace( e );
 		}
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -8,14 +8,20 @@
 import org.dom4j.Element;
 
 /**
- * This interface is implemented by filters which can be configured via the XML 
+ * This interface is implemented by filters which can be configured via the XML
  * mechanism
+ * 
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  */
-public interface AAAConfigurable {
-	/**
-	 * configure the filter.
-	 * @param configElements a list of dom4j elements containing the actual configuration
-	 */
-	public void configure(List<Element> configElements) throws Exception;
+public interface AAAConfigurable
+{
+
+    /**
+     * configure the filter.
+     * 
+     * @param configElements
+     *            a list of dom4j elements containing the actual configuration
+     */
+    public void configure( List<Element> configElements ) throws Exception;
+    
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/BooleanParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/BooleanParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/BooleanParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,6 +3,8 @@
  */
 package rtspproxy.config;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  */
@@ -14,25 +16,12 @@
 	private boolean defaultValue;
 
 	public BooleanParameter( String name, boolean defaultValue, boolean mutable,
-			String description, String xpathExpr )
+			String description )
 	{
-		super( name, mutable, description, xpathExpr );
+		super( name, mutable, description );
 		this.defaultValue = defaultValue;
 	}
 
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-		value = value.trim().toLowerCase();
-		if ( "true".equals( value ) || "yes".equals( value ) )
-			this.value = true;
-		else if ( "false".equals( value ) || "no".equals( value ) )
-			this.value = false;
-		else
-			throw new IllegalArgumentException( "Boolean value not valid: " + value );
-
-		setChanged();
-	}
-
 	/**
 	 * @return Returns the defaultValue.
 	 */
@@ -80,4 +69,12 @@
 			setChanged();
 		}
 	}
+    
+
+    @Override
+    public void readConfiguration( Configuration configuration )
+    {
+        boolean value = configuration.getBoolean( name );
+        setObjectValue( value );
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,3 +1,21 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - matteo.merli at gmail.com            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
+ * 
+ * $URL$
+ * 
+ */
+
 package rtspproxy.config;
 
 import java.util.ArrayList;
@@ -13,516 +31,482 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import org.apache.log4j.Appender;
+import org.apache.log4j.Level;
+import org.apache.log4j.Logger;
+
 import rtspproxy.lib.Singleton;
 import rtspproxy.rtsp.Handler;
 
+/**
+ * 
+ * @author Matteo Merli
+ */
 public class Config extends Singleton implements Observer
 {
 
-	private static ConcurrentMap<String, Parameter> parameters = new ConcurrentHashMap<String, Parameter>();
+    /** Map that contains all the application parameters. */
+    private static ConcurrentMap<String, Parameter> parameters = new ConcurrentHashMap<String, Parameter>();
 
-	protected static void addParameter( Parameter parameter )
-	{
-		parameters.put( parameter.getName(), parameter );
-	}
+    protected static void addParameter( Parameter parameter )
+    {
+        parameters.put( parameter.getName(), parameter );
+    }
 
-	public static Parameter getParameter( String name )
-	{
-		if ( name == null )
-			throw new IllegalArgumentException( "name is null" );
+    public static Parameter getParameter( String name )
+    {
+        if ( name == null )
+            throw new IllegalArgumentException( "name is null" );
 
-		return parameters.get( name );
-	}
+        return parameters.get( name );
+    }
 
-	public static Collection<Parameter> getAllParameters()
-	{
-		return parameters.values();
-	}
+    public static Collection<Parameter> getAllParameters()
+    {
+        return parameters.values();
+    }
 
-	protected static Map<String, Parameter> getParametersMap()
-	{
-		return parameters;
-	}
-	
-	public static final IntegerParameter threadPoolSize = new IntegerParameter(
-			"thread.pool.size", // name
-			new Integer( 0 ), // min value
-			new Integer( 2147483647 ), // max value
-			new Integer( 10 ), // default value
-			true, // mutable
-			"Maximum size of the thread pool. The thread pool is shared "
-					+ "between all services found in RtspProxy.",
-			"/rtspproxy/threadPoolSize" // xpathExpr
-	);
+    protected static Map<String, Parameter> getParametersMap()
+    {
+        return parameters;
+    }
 
-	public static final IntegerParameter proxyRtspPort = new IntegerParameter(
-			"proxy.rtsp.port", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( Handler.DEFAULT_RTSP_PORT ), // default value
-			true, // mutable
-			"This is the port which the proxy will listen for "
-					+ "RTSP connection. The default is 554, like normal RTSP servers.",
-			"/rtspproxy/proxy/rtspPort" // xpathExpr
-			);
+    public static final BooleanParameter debugEnabled = new BooleanParameter( "debug", // name
+            false, // default value
+            false, // mutable
+            "Enables or disable application-wide debug messages." );
 
-	public static final StringParameter proxyClientInterface = new StringParameter(
-			"proxy.client.interface", // name
-			null, // default value
-			false, // mutable
-			"Specify a network interface. Default is to listen on all interfaces." ,
-			"/rtspproxy/proxy/client/interface" // xpathExpr
-			);
+    public static final IntegerParameter threadPoolSize = new IntegerParameter(
+            "threadPoolSize", // name
+            new Integer( 0 ), // min value
+            new Integer( 2147483647 ), // max value
+            new Integer( 10 ), // default value
+            true, // mutable
+            "Maximum size of the thread pool. The thread pool is shared "
+                    + "between all services found in RtspProxy." );
 
-	public static final StringParameter proxyServerInterface = new StringParameter(
-			"proxy.server.interface", // name
-			null, // default value
-			false, // mutable
-			"Specify a network interface. Default is to listen on all interfaces.",
-			"/rtspproxy/proxy/server/interface" // pathExpr
-			);
+    public static final IntegerParameter proxyRtspPort = new IntegerParameter(
+            "proxy.rtspPort", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( Handler.DEFAULT_RTSP_PORT ), // default value
+            true, // mutable
+            "This is the port which the proxy will listen for "
+                    + "RTSP connection. The default is 554, like normal RTSP servers." );
 
-	public static final StringParameter proxyClientAddress = new StringParameter(
-			"proxy.client.address", // name
-			null, // default value
-			false, // mutable
-			"Specify a network address." ,
-			"/rtspproxy/proxy/client/address" // xpathExpr
-			);
+    public static final StringParameter proxyClientInterface = new StringParameter(
+            "proxy.client.interface", // name
+            null, // default value
+            false, // mutable
+            "Specify a network interface. Default is to listen on all interfaces." );
 
-	public static final StringParameter proxyServerAddress = new StringParameter(
-			"proxy.server.address", // name
-			null, // default value
-			false, // mutable
-			"Specify a network address.",
-			"/rtspproxy/proxy/server/address" // pathExpr
-			);
+    public static final StringParameter proxyServerInterface = new StringParameter(
+            "proxy.server.interface", // name
+            null, // default value
+            false, // mutable
+            "Specify a network interface. Default is to listen on all interfaces." );
 
-	public static final IntegerParameter proxyServerRtpPort = new IntegerParameter(
-			"proxy.server.rtp.port", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8000 ), // default value
-			true, // mutable
-			"Port to listen for RTP packets arriving from servers.",
-			"/rtspproxy/proxy/server/rtpPort" // xpathExpr
-			);
+    public static final StringParameter proxyClientAddress = new StringParameter(
+            "proxy.client.address", // name
+            null, // default value
+            false, // mutable
+            "Specify a network address. Default is to listen on all addresses" );
 
-	public static final IntegerParameter proxyServerRtcpPort = new IntegerParameter(
-			"proxy.server.rtcp.port", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8001 ), // default value
-			true, // mutable
-			"Port to listen for RTCP packets arriving from servers.",
-			"/rtspproxy/proxy/server/rtcpPort" // xpathExpr
-			);
+    public static final StringParameter proxyServerAddress = new StringParameter(
+            "proxy.server.address", // name
+            null, // default value
+            false, // mutable
+            "Specify a network address." );
 
-	public static final BooleanParameter proxyServerRtpMultiplePorts = new BooleanParameter(
-			"proxy.server.rtp.multiport.enable", // name
-			false, // default value
-			false, // mutable
-			"Enables the RTP/RTCP multiport handling.",
-			"/rtspproxy/proxy/server/rtpUsePortrange" // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpPort = new IntegerParameter(
+            "proxy.server.rtpPort", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8000 ), // default value
+            true, // mutable
+            "Port to listen for RTP packets arriving from servers." );
 
-	public static final IntegerParameter proxyServerRtpMinPort = new IntegerParameter(
-			"proxy.server.rtp.port.min", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 9000 ), // default value
-			true, // mutable
-			"Port to listen for RTP packets arriving from servers.",
-			"/rtspproxy/proxy/server/rtpPortrange/minPort" // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtcpPort = new IntegerParameter(
+            "proxy.server.rtcp.port", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8001 ), // default value
+            true, // mutable
+            "Port to listen for RTCP packets arriving from servers." );
 
-	public static final IntegerParameter proxyServerRtpMaxPort = new IntegerParameter(
-			"proxy.server.rtp.port.max", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 9100 ), // default value
-			true, // mutable
-			"Port to listen for RTP packets arriving from servers.",
-			"/rtspproxy/proxy/server/rtpPortrange/maxPort" // xpathExpr
-			);
-	
-	public static final IntegerParameter proxyServerRtpIdleTimeout = new IntegerParameter(
-			"proxy.server.rtp.portrange.idle.timeout", // name
-			new Integer( 0 ), // min value
-			new Integer( 86400 ), // max value
-			new Integer( 3600 ), // default value
-			true, // mutable
-			"Timeout an open RTP server port may linger around.",
-			"/rtspproxy/proxy/server/rtpPortrange/idleTimeout" // xpathExpr
-			);	
+    public static final BooleanParameter proxyServerRtpMultiplePorts = new BooleanParameter(
+            "proxy.server.rtpUsePortRange", // name
+            false, // default value
+            false, // mutable
+            "Enables the RTP/RTCP multiport handling." );
 
-	public static final IntegerParameter proxyServerRtpIdleScanInterval = new IntegerParameter(
-			"proxy.server.rtp.portrange.idle.timeout", // name
-			new Integer( 0 ), // min value
-			new Integer( 86400 ), // max value
-			new Integer( 1800 ), // default value
-			true, // mutable
-			"Scan interval on idle RTP server ports.",
-			"/rtspproxy/proxy/server/rtpPortrange/idleScanInterval" // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpMinPort = new IntegerParameter(
+            "proxy.server.rtpPortrange.minPort", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 9000 ), // default value
+            true, // mutable
+            "Port to listen for RTP packets arriving from servers." );
 
-	public static final IntegerParameter proxyServerRtpThreadPoolSize = new IntegerParameter(
-			"proxy.server.rtp.portrange.pool.size", // name
-			new Integer( 0 ), // min value
-			new Integer( 2147483647 ), // max value
-			new Integer( 10 ), // default value
-			true, // mutable
-			"Scan interval on idle RTP server ports.",
-			"/rtspproxy/proxy/server/rtpPortrange/threadPoolSize" // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpMaxPort = new IntegerParameter(
+            "proxy.server.rtpPortrange.maxPort", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 9100 ), // default value
+            true, // mutable
+            "Port to listen for RTP packets arriving from servers." );
 
-	public static final IntegerParameter proxyClientRtpPort = new IntegerParameter(
-			"proxy.client.rtp.port", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8002 ), // default value
-			true, // mutable
-			"Port to listen for RTP packets arriving from clients.",
-			"/rtspproxy/proxy/client/rtpPort" // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpIdleTimeout = new IntegerParameter(
+            "proxy.server.rtpPortrange.idleTimeout", // name
+            new Integer( 0 ), // min value
+            new Integer( 86400 ), // max value
+            new Integer( 3600 ), // default value
+            true, // mutable
+            "Timeout an open RTP server port may linger around." );
 
-	public static final IntegerParameter proxyClientRtcpPort = new IntegerParameter(
-			"proxy.client.rtcp.port", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8003 ), // default value
-			true, // mutable
-			"Port to listen for RTCP packets arriving from clients.",
-			"/rtspproxy/proxy/client/rtcpPort" // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpIdleScanInterval = new IntegerParameter(
+            "proxy.server.rtpPortrange.idleScanInterval", // name
+            new Integer( 0 ), // min value
+            new Integer( 86400 ), // max value
+            new Integer( 1800 ), // default value
+            true, // mutable
+            "Scan interval on idle RTP server ports." );
 
-	public static final IntegerParameter proxyServerRdtPort = new IntegerParameter(
-			"proxy.server.rdt.port", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8020 ), // default value
-			true, // mutable
-			"Port to listen for RDT packets arriving from servers.",
-			"/rtspproxy/proxy/server/rdtPort" // xpathExpr
-			);
+    public static final IntegerParameter proxyServerRtpThreadPoolSize = new IntegerParameter(
+            "proxy.server.rtpPortrange.threadPoolSize", // name
+            new Integer( 0 ), // min value
+            new Integer( 2147483647 ), // max value
+            new Integer( 10 ), // default value
+            true, // mutable
+            "Scan interval on idle RTP server ports." );
 
-	public static final IntegerParameter proxyClientRdtPort = new IntegerParameter(
-			"proxy.client.rdt.port", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8022 ), // default value
-			true, // mutable
-			"Port to listen for RDT packets arriving from clients.",
-			"/rtspproxy/proxy/client/rdtPort" // xpathExpr
-			);
+    public static final IntegerParameter proxyClientRtpPort = new IntegerParameter(
+            "proxy.client.rtpPort", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8002 ), // default value
+            true, // mutable
+            "Port to listen for RTP packets arriving from clients." );
 
-	public static final BooleanParameter proxyTransportRtpEnable = new BooleanParameter(
-			"proxy.transport.rtp.enable", // name
-			true, // default value
-			false, // mutable
-			"Enables the UDP/AVP/RTP transport.",
-			"/rtspproxy/proxy/transport/rtp" // xpathExpr
-			);
-	
+    public static final IntegerParameter proxyClientRtcpPort = new IntegerParameter(
+            "proxy.client.rtcpPort", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8003 ), // default value
+            true, // mutable
+            "Port to listen for RTCP packets arriving from clients." );
 
-	public static final BooleanParameter proxyTransportRdtEnable = new BooleanParameter(
-			"proxy.transport.rdt.enable", // name
-			true, // default value
-			false, // mutable
-			"Enables the x-udp-rdt transport.",
-			"/rtspproxy/proxy/transport/rdt" // xpathExpr
-			);	
-	
+    public static final IntegerParameter proxyServerRdtPort = new IntegerParameter(
+            "proxy.server.rdtPort", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8020 ), // default value
+            true, // mutable
+            "Port to listen for RDT packets arriving from servers." );
 
-	public static final BooleanParameter proxyLowerTransportSuppress = new BooleanParameter(
-			"proxy.transport.rtp.protocol.disable", // name
-			false, // default value
-			false, // mutable
-			"Enables the x-udp-rdt transport.",
-			"/rtspproxy/proxy/transport/hacks/lowerTransportSuppress" // xpathExpr
-			);	
+    public static final IntegerParameter proxyClientRdtPort = new IntegerParameter(
+            "proxy.client.rdtPort", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8022 ), // default value
+            true, // mutable
+            "Port to listen for RDT packets arriving from clients." );
 
-	public static final BooleanParameter proxyRtspTransportSsrcDisable = new BooleanParameter(
-			"proxy.transport.rtsp.transport.ssrc.disable", // name
-			false, // default value
-			false, // mutable
-			"disable the output of the SSRC transport attribute",
-			"/rtspproxy/proxy/transport/hacks/rtspTransportSsrcDisable" // xpathExpr
-			);	
+    public static final BooleanParameter proxyTransportRtpEnable = new BooleanParameter(
+            "proxy.transport.rtp", // name
+            true, // default value
+            false, // mutable
+            "Enables the UDP/AVP/RTP transport." );
 
-	public static final BooleanParameter proxyRtspTransportSourceDisable = new BooleanParameter(
-			"proxy.transport.rtsp.transport.source.disable", // name
-			false, // default value
-			false, // mutable
-			"disable the output of the SOURCE transport attribute",
-			"/rtspproxy/proxy/transport/hacks/rtspTransportSourceDisable" // xpathExpr
-			);	
+    public static final BooleanParameter proxyTransportRdtEnable = new BooleanParameter(
+            "proxy.transport.rdt", // name
+            true, // default value
+            false, // mutable
+            "Enables the x-udp-rdt transport." );
 
-	public static final BooleanParameter proxyRtspKeepAlive = new BooleanParameter(
-			"proxy.transport.rtsp.keepAlive.enable", // name
-			false, // default value
-			false, // mutable
-			"Enable keep-alive on RTSP connections to remote servers.",
-			"/rtspproxy/proxy/transport/hacks/rtspKeepAlive" // xpathExpr
-			);
-	
-	public static final BooleanParameter proxyRtspAllowBrokenHeaders = new BooleanParameter(
-			"proxy.transport.rtsp.broken.headers.enable", // name
-			false, // default value
-			false, // mutable
-			"Allow certain work-arounds for clients generating non-conformant RTSP protocol traffic.",
-			"/rtspproxy/proxy/transport/hacks/rtspAllowBrokenHeaders" // xpathExpr
-			);
+    public static final BooleanParameter proxyLowerTransportSuppress = new BooleanParameter(
+            "proxy.transport.hacks.lowerTransportSuppress", // name
+            false, // default value
+            false, // mutable
+            "Enables the x-udp-rdt transport." );
 
-	public static final BooleanParameter proxyRtspOfferSsrcToServer = new BooleanParameter(
-			"proxy.transport.rtsp.offer.ssrc.enable", // name
-			false, // default value
-			false, // mutable
-			"Allow certain work-arounds for clients generating non-conformant RTSP protocol traffic.",
-			"/rtspproxy/proxy/transport/hacks/offerRemoteSsrc" // xpathExpr
-			);
+    public static final BooleanParameter proxyRtspTransportSsrcDisable = new BooleanParameter(
+            "proxy.transport.hacks.rtspTransportSsrcDisable", // name
+            false, // default value
+            false, // mutable
+            "Disable the output of the SSRC transport attribute" );
 
-	public static final BooleanParameter proxyServerRtpSsrcUnreliable = new BooleanParameter(
-			"proxy.streaming.rtp.ssrc.unreliable", // name
-			false, // default value
-			false, // mutable
-			"Disable the evaluation of the SSRC send by the remote streaming server.",
-			"/rtspproxy/proxy/streaming/hacks/rtpSsrcUnreliable" // xpathExpr
-			);	
+    public static final BooleanParameter proxyRtspTransportSourceDisable = new BooleanParameter(
+            "proxy.transport.rtspTransportSourceDisable", // name
+            false, // default value
+            false, // mutable
+            "Disable the output of the SOURCE transport attribute" );
 
-	// /////////////////////////////////////////////////////////
+    public static final BooleanParameter proxyRtspKeepAlive = new BooleanParameter(
+            "proxy.transport.hacks.rtspKeepAlive", // name
+            false, // default value
+            false, // mutable
+            "Enable keep-alive on RTSP connections to remote servers." );
 
-	// JMX
+    public static final BooleanParameter proxyRtspAllowBrokenHeaders = new BooleanParameter(
+            "proxy.transport.hacks.rtspAllowBrokenHeaders", // name
+            false, // default value
+            false, // mutable
+            "Allow certain work-arounds for clients generating non-conformant RTSP protocol traffic." );
 
-	public static final BooleanParameter proxyManagementEnable = new BooleanParameter(
-			"proxy.management.enable", // name
-			false, // default value
-			false, // mutable
-			"Controls the activation of the management subsystem (JMX).",
-			"/rtspproxy/jmx/manageable" // xpathExpr
-			);
+    public static final BooleanParameter proxyRtspOfferSsrcToServer = new BooleanParameter(
+            "proxy.transport.hacks.offerRemoteSsrc", // name
+            false, // default value
+            false, // mutable
+            "Allow certain work-arounds for clients generating non-conformant RTSP protocol traffic." );
 
-	public static final StringParameter proxyManagementHost = new StringParameter(
-			"proxy.management.host", // name
-			"localhost", // default value
-			false, // mutable
-			"Host to bind the management services. Default is localhost, and the services "
-					+ "will only be reachable from local machine.",
-			"/rtspproxy/jmx/address" // xpathExpr
-			 );
+    public static final BooleanParameter proxyServerRtpSsrcUnreliable = new BooleanParameter(
+            "proxy.transport.hacks.rtpSsrcUnreliable", // name
+            false, // default value
+            false, // mutable
+            "Disable the evaluation of the SSRC send by the remote streaming server." );
 
-	public static final StringParameter proxyManagementUser = new StringParameter(
-			"proxy.management.user", // name
-			null, // default value
-			true, // mutable
-			"Remote management administrator user name.",
-			"/rtspproxy/jmx/user" // xpathExpr
-			 );
-	
-	public static final StringParameter proxyManagementPassword = new StringParameter(
-			"proxy.management.password", // name
-			null, // default value
-			true, // mutable
-			"Remote management administrator password.",
-			"/rtspproxy/jmx/password" // xpathExpr
-			 );
+    // /////////////////////////////////////////////////////////
 
-	public static final BooleanParameter proxyManagementWebEnable = new BooleanParameter(
-			"proxy.management.web.enable", // name
-			false, // default value
-			false, // mutable
-			"Controls the activation of the Web management console.",
-			"/rtspproxy/jmx/web/manageable" // xpathExpr
-			 );
+    // JMX
 
-	public static final IntegerParameter proxyManagementWebPort = new IntegerParameter(
-			"proxy.management.web.port", // name
-			new Integer( 0 ), // min value
-			new Integer( 65536 ), // max value
-			new Integer( 8000 ), // default value
-			false, // mutable
-			"TCP port to be used for the Web Console.",
-			"/rtspproxy/jmx/web/port" // xpathExpr
-			 );
+    public static final BooleanParameter jmxEnable = new BooleanParameter( "jmx.enable", // name
+            false, // default value
+            false, // mutable
+            "Controls the activation of the management subsystem (JMX)." );
 
-	public static final BooleanParameter proxyManagementRemoteEnable = new BooleanParameter(
-			"proxy.management.remote.enable", // name
-			false, // default value
-			false, // mutable
-			"Controls the activation of the JMX connector server.",
-			"/rtspproxy/jmx/connectorService/manageable" // xpathExpr
-			 );
+    public static final StringParameter jmxAddress = new StringParameter( "jmx.address", // name
+            "localhost", // default value
+            false, // mutable
+            "Host to bind the management services. Default is localhost, and the services "
+                    + "will only be reachable from local machine." );
 
-	// /////////////////////////////////////////////////////////
+    public static final StringParameter jmxUser = new StringParameter( "jmx.user", // name
+            "", // default value
+            true, // mutable
+            "Remote management administrator user name." );
 
-	private static String rtspproxyHome;
+    public static final StringParameter jmxPassword = new StringParameter(
+            "jmx.password", // name
+            "", // default value
+            true, // mutable
+            "Remote management administrator password." );
 
-	private static String name;
+    public static final BooleanParameter jmxWebEnable = new BooleanParameter(
+            "jmx.web.enable", // name
+            false, // default value
+            false, // mutable
+            "Controls the activation of the Web management console." );
 
-	private static String version;
+    public static final IntegerParameter jmxWebPort = new IntegerParameter(
+            "jmx.web.port", // name
+            new Integer( 0 ), // min value
+            new Integer( 65536 ), // max value
+            new Integer( 8000 ), // default value
+            false, // mutable
+            "TCP port to be used for the Web Console." );
 
-	private static String proxySignature;
+    public static final BooleanParameter jmxConnectorServiceEnable = new BooleanParameter(
+            "jmx.connectorService.enable", // name
+            false, // default value
+            false, // mutable
+            "Controls the activation of the JMX connector server." );
 
-	private static Date startDate;
+    // /////////////////////////////////////////////////////////
 
-	// /////////////////////////////////////////////////////////
-	
-	// filter configurations from XML
-	private static List<AAAConfig> authenticationFilters = new ArrayList<AAAConfig>();
+    private static String rtspproxyHome;
 
-	// filter configurations from XML
-	private static List<AAAConfig> ipAddressFilters = new ArrayList<AAAConfig>();
+    private static String name;
 
-	// filter configurations from XML
-	private static List<AAAConfig> accountingFilters = new ArrayList<AAAConfig>();
+    private static String version;
 
-	// filter configurations from XML
-	private static List<AAAConfig> urlRewritingFilters = new ArrayList<AAAConfig>();
+    private static String proxySignature;
 
-	private static List<AAAConfig> controlFilters = new ArrayList<AAAConfig>();
-	
-	static void addAuthenticationFilter(AAAConfig config) {
-		authenticationFilters.add(config);
-	}
-	
-	static void addIpAddressFilter(AAAConfig config) {
-		ipAddressFilters.add(config);
-	}
-	
-	static void addAccountingFilter(AAAConfig config) {
-		accountingFilters.add(config);
-	}
-	
-	static void addUrlRewritingFilter(AAAConfig config) {
-		urlRewritingFilters.add(config);
-	}
+    private static Date startDate;
 
-	public static void addControlFilter(AAAConfig aaa) {
-		controlFilters.add(aaa);
-	}
+    // /////////////////////////////////////////////////////////
 
-	public static List<AAAConfig> getAuthenticationFilters() {
-		return Collections.unmodifiableList(authenticationFilters);
-	}
-	
-	public static List<AAAConfig> getIpAddressFilters() {
-		return Collections.unmodifiableList(ipAddressFilters);
-	}
-	
-	public static List<AAAConfig> getAccountingFilters() {
-		return Collections.unmodifiableList(accountingFilters);
-	}
+    // filter configurations from XML
+    private static List<AAAConfig> authenticationFilters = new ArrayList<AAAConfig>();
 
-	public static List<AAAConfig> getUrlRewritingFilters() {
-		return Collections.unmodifiableList(urlRewritingFilters);
-	}
-	
-	public static List<AAAConfig> getControlFilters() {
-		return Collections.unmodifiableList(controlFilters);
-	}
- 	
-	// /////////////////////////////////////////////////////////
+    // filter configurations from XML
+    private static List<AAAConfig> ipAddressFilters = new ArrayList<AAAConfig>();
 
-	public Config()
-	{
-		// Read home directory
-		rtspproxyHome = System.getProperty( "rtspproxy.home" );
-		if ( rtspproxyHome == null ) {
-			rtspproxyHome = System.getProperty( "user.dir" );
-		}
+    // filter configurations from XML
+    private static List<AAAConfig> accountingFilters = new ArrayList<AAAConfig>();
 
-		// Read program name and version
-		Properties jarProps = new Properties();
-		try {
-			jarProps.load( Thread.currentThread().getContextClassLoader().getResourceAsStream(
-					"META-INF/application.properties" ) );
-			name = jarProps.getProperty( "application.name" );
-			version = jarProps.getProperty( "application.version" );
-		} catch ( Exception e ) {
-			name = "RtspProxy";
-			version = "";
-		}
+    // filter configurations from XML
+    private static List<AAAConfig> urlRewritingFilters = new ArrayList<AAAConfig>();
 
-		// Build proxy signature
-		StringBuilder sb = new StringBuilder();
-		sb.append( name ).append( " " ).append( version );
-		sb.append( " (" ).append( System.getProperty( "os.name" ) );
-		sb.append( " / " ).append( System.getProperty( "os.version" ) );
-		sb.append( " / " ).append( System.getProperty( "os.arch" ) );
-		sb.append( ")" );
-		proxySignature = sb.toString();
+    private static List<AAAConfig> controlFilters = new ArrayList<AAAConfig>();
 
-		startDate = new Date();
+    static void addAuthenticationFilter( AAAConfig config )
+    {
+        authenticationFilters.add( config );
+    }
 
-	}
+    static void addIpAddressFilter( AAAConfig config )
+    {
+        ipAddressFilters.add( config );
+    }
 
-	/**
-	 * Manage parameters value changes
-	 * 
-	 * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
-	 */
-	public void update( Observable o, Object arg )
-	{
-		if ( !( o instanceof Parameter ) )
-			throw new IllegalArgumentException( "Only observe parameters" );
-	}
+    static void addAccountingFilter( AAAConfig config )
+    {
+        accountingFilters.add( config );
+    }
 
-	/**
-	 * @return the application base dir or null if the home directory cannot be determined.
-	 */
-	public static String getHome()
-	{
-		return rtspproxyHome;
-	}
+    static void addUrlRewritingFilter( AAAConfig config )
+    {
+        urlRewritingFilters.add( config );
+    }
 
-	/**
-	 * @return Returns the application name.
-	 */
-	public static String getName()
-	{
-		return name;
-	}
+    public static void addControlFilter( AAAConfig aaa )
+    {
+        controlFilters.add( aaa );
+    }
 
-	/**
-	 * @return Returns the application version.
-	 */
-	public static String getVersion()
-	{
-		return version;
-	}
+    public static List<AAAConfig> getAuthenticationFilters()
+    {
+        return Collections.unmodifiableList( authenticationFilters );
+    }
 
-	/**
-	 * @return Returns the proxySignature.
-	 */
-	public static String getProxySignature()
-	{
-		return proxySignature;
-	}
+    public static List<AAAConfig> getIpAddressFilters()
+    {
+        return Collections.unmodifiableList( ipAddressFilters );
+    }
 
-	public static Date getStartDate()
-	{
-		return startDate;
-	}
+    public static List<AAAConfig> getAccountingFilters()
+    {
+        return Collections.unmodifiableList( accountingFilters );
+    }
 
-	// /////////////////////////////////////////////////////////
+    public static List<AAAConfig> getUrlRewritingFilters()
+    {
+        return Collections.unmodifiableList( urlRewritingFilters );
+    }
 
-	/**
-	 * @return a String containing all the parameters
-	 */
-	public static String debugParameters()
-	{
-		StringBuilder sb = new StringBuilder();
-		Map<String, Parameter> parameters = new TreeMap<String, Parameter>(
-				Config.getParametersMap() );
-		sb.append( "Parameters:\n" );
-		for ( Parameter parameter : parameters.values() ) {
-			sb.append( parameter.getName() );
-			sb.append( ": " );
-			sb.append( parameter.getStringValue() );
-			sb.append( "\n" );
-		}
+    public static List<AAAConfig> getControlFilters()
+    {
+        return Collections.unmodifiableList( controlFilters );
+    }
 
-		return sb.toString();
-	}
+    // /////////////////////////////////////////////////////////
 
+    public Config()
+    {
+        // Read home directory
+        rtspproxyHome = System.getProperty( "rtspproxy.home" );
+        if ( rtspproxyHome == null ) {
+            rtspproxyHome = System.getProperty( "user.dir" );
+        }
+
+        // Read program name and version
+        Properties jarProps = new Properties();
+        try {
+            jarProps.load( Thread.currentThread().getContextClassLoader()
+                    .getResourceAsStream( "META-INF/application.properties" ) );
+            name = jarProps.getProperty( "application.name" );
+            version = jarProps.getProperty( "application.version" );
+        } catch ( Exception e ) {
+            name = "RtspProxy";
+            version = "";
+        }
+
+        // Build proxy signature
+        StringBuilder sb = new StringBuilder();
+        sb.append( name ).append( ' ' ).append( version );
+        sb.append( " (" ).append( System.getProperty( "os.name" ) );
+        sb.append( " / " ).append( System.getProperty( "os.version" ) );
+        sb.append( " / " ).append( System.getProperty( "os.arch" ) );
+        sb.append( ')' );
+        proxySignature = sb.toString();
+
+        startDate = new Date();
+
+    }
+
+    /**
+     * Manage parameters value changes
+     * 
+     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
+     */
+    public void update( Observable o, Object arg )
+    {
+        if ( !(o instanceof Parameter) )
+            throw new IllegalArgumentException( "Only observe parameters" );
+    }
+
+    /**
+     * @return the application base dir or null if the home directory cannot be
+     *         determined.
+     */
+    public static String getHome()
+    {
+        return rtspproxyHome;
+    }
+
+    /**
+     * @return Returns the application name.
+     */
+    public static String getName()
+    {
+        return name;
+    }
+
+    /**
+     * @return Returns the application version.
+     */
+    public static String getVersion()
+    {
+        return version;
+    }
+
+    /**
+     * @return Returns the proxySignature.
+     */
+    public static String getProxySignature()
+    {
+        return proxySignature;
+    }
+
+    public static Date getStartDate()
+    {
+        return startDate;
+    }
+
+    // /////////////////////////////////////////////////////////
+
+    protected static void updateDebugSettings()
+    {
+        Logger rootLogger = Logger.getRootLogger();
+        if ( debugEnabled.getValue() ) {
+            rootLogger.setLevel( Level.DEBUG );
+        }
+
+        /*
+         * else use the default level set in the log4j configuration file, which
+         * is INFO
+         */
+    }
+
+    /**
+     * @return a String containing all the parameters
+     */
+    public static String debugParameters()
+    {
+        StringBuilder sb = new StringBuilder();
+        Map<String, Parameter> parameters = new TreeMap<String, Parameter>( Config
+                .getParametersMap() );
+
+        sb.append( "Parameters:\n" );
+        for ( Parameter parameter : parameters.values() ) {
+            sb.append( parameter.getName() );
+            sb.append( ": " );
+            sb.append( parameter.getStringValue() );
+            sb.append( '\n' );
+        }
+
+        return sb.toString();
+    }
+
 }

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerListParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerListParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerListParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,139 +0,0 @@
-/**
- * 
- */
-package rtspproxy.config;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author Matteo Merli
- */
-public class IntegerListParameter extends ListParameter
-{
-	private List<Integer> values = null;
-
-	private Integer minValue;
-
-	private Integer maxValue;
-
-	private Integer defaultValue;
-
-	public IntegerListParameter( String name, Integer minValue, Integer maxValue,
-			Integer defaultValue, boolean mutable, String description, String xpathExpr )
-	{
-		super( name, mutable, description, xpathExpr );
-
-		if ( defaultValue == null )
-			throw new IllegalArgumentException( "Default value for " + name
-					+ " must be not null." );
-		this.defaultValue = defaultValue;
-		this.minValue = minValue;
-		this.maxValue = maxValue;
-	}
-
-	@Override
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-		this.values = new ArrayList<Integer>();
-		Integer tmpValue = null;
-		String[] tokens = value.split( "," );
-
-		for ( String token : tokens ) {
-
-			token = token.trim();
-			try {
-				tmpValue = Integer.valueOf( token );
-			} catch ( NumberFormatException nfe ) {
-				throw new IllegalArgumentException( "Integer value for " + name
-						+ " not valid: " + token );
-			}
-
-			if ( minValue != null && (tmpValue.compareTo( minValue ) < 0) )
-				throw new IllegalArgumentException( "Integer value for " + name
-						+ " must be greater than " + minValue );
-			if ( maxValue != null && (tmpValue.compareTo( maxValue ) > 0) )
-				throw new IllegalArgumentException( "Integer value for " + name
-						+ " must be lesser than " + maxValue );
-
-			this.values.add( tmpValue );
-		}
-
-		setChanged();
-	}
-
-	@Override	
-	public void addValue(String value) {
-		try {
-			Integer tmpValue = Integer.valueOf(value);
-
-			this.values.add(tmpValue);
-		} catch ( NumberFormatException nfe ) {
-			throw new IllegalArgumentException( "Integer value for " + name
-					+ " not valid: " + value );
-		}
-		
-		setChanged();
-	}
-
-	@Override
-	public String getStringValue()
-	{
-		if ( values == null )
-			return defaultValue.toString();
-
-		StringBuilder sb = new StringBuilder();
-		final int size = values.size();
-		for ( int i = 0; i < size; i++ ) {
-			sb.append( values.get( i ).toString() );
-			if ( i < size - 1 )
-				sb.append( ", " );
-		}
-		return sb.toString();
-	}
-
-	/**
-	 * @return Returns the defaultValue.
-	 */
-	public String getDefaultValue()
-	{
-		return defaultValue.toString();
-	}
-
-	public int[] getValue()
-	{
-		if ( values == null )
-			return new int[] { defaultValue };
-
-		int[] v = new int[values.size()];
-		for ( int i = values.size() - 1; i >= 0; i-- )
-			v[i] = values.get( i );
-		return v;
-	}
-
-	@Override
-	public String getType()
-	{
-		return "[I";
-	}
-
-	@Override
-	public Object getObjectValue()
-	{
-		return getValue();
-	}
-
-	@Override
-	public void setObjectValue( Object object )
-	{
-		if ( !(object instanceof int[]) )
-			throw new IllegalArgumentException( "Value must be a int[]" );
-		
-		this.values = new ArrayList<Integer>( ((int[]) object).length );
-		for ( int v : (int[]) object )
-			values.add( v );
-
-		setChanged();
-	}
-
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/IntegerParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,6 +3,8 @@
  */
 package rtspproxy.config;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  */
@@ -17,9 +19,9 @@
 	private Integer defaultValue;
 
 	public IntegerParameter( String name, Integer minValue, Integer maxValue,
-			Integer defaultValue, boolean mutable, String description, String xpathExpr )
+			Integer defaultValue, boolean mutable, String description )
 	{
-		super( name, mutable, description, xpathExpr );
+		super( name, mutable, description );
 
 		if ( defaultValue == null )
 			throw new IllegalArgumentException( "Default value for " + name
@@ -30,21 +32,6 @@
 	}
 
 	@Override
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-
-		Integer tmpValue;
-		try {
-			tmpValue = Integer.valueOf( value );
-		} catch ( NumberFormatException nfe ) {
-			throw new IllegalArgumentException( "Integer value for " + name
-					+ "not valid: " + value );
-		}
-
-		setObjectValue( tmpValue );
-	}
-
-	@Override
 	public String getStringValue()
 	{
 		return (value != null ? value : defaultValue).toString();
@@ -96,5 +83,12 @@
 			setChanged();
 		}
 	}
+    
+    @Override
+    public void readConfiguration( Configuration configuration )
+    {
+        int value = configuration.getInt( name );
+        setObjectValue( value );
+    }
 
 }

Added: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - matteo.merli at gmail.com            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
+ * 
+ * $URL$
+ * 
+ */
+package rtspproxy.config;
+
+/**
+ * @author Matteo Merli
+ * 
+ */
+public interface ListElementParameter
+{
+    
+}


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,25 +3,72 @@
  */
 package rtspproxy.config;
 
+import java.util.List;
+
+import org.apache.commons.configuration.Configuration;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public abstract class ListParameter extends Parameter {
+public class ListParameter<T> extends Parameter
+{
 
-	/**
-	 * @param name
-	 * @param mutable
-	 * @param description
-	 * @param xpathExpr
-	 */
-	public ListParameter(String name, boolean mutable, String description,
-			String xpathExpr) {
-		super(name, mutable, description, xpathExpr);
-	}
+    private static Logger log = LoggerFactory.getLogger( ListParameter.class );
 
-	/**
-	 * add a value to the list
-	 */
-	public abstract void addValue(String value);
+    private List<T> list;
+
+    /**
+     * @param name
+     * @param mutable
+     * @param description
+     */
+    public ListParameter( String name, boolean mutable, String description )
+    {
+        super( name, mutable, description );
+    }
+
+    @Override
+    public Object getObjectValue()
+    {
+        return list;
+    }
+
+    @Override
+    public String getStringValue()
+    {
+        return list.toString();
+    }
+
+    @Override
+    public String getType()
+    {
+        return "java.util.List";
+    }
+
+    @Override
+    public void readConfiguration( Configuration configuration )
+    {
+        List elements = configuration.getList( name );
+        if ( elements == null ) {
+            log.debug( "Elements not found for key '{}'", name );
+            return;
+        }
+
+        for ( Object element : elements ) {
+            log.info( "ELEMENT: {}", element );
+        }
+    }
+
+    @Override
+    public void setObjectValue( Object object )
+    {
+        if ( !(object instanceof List) ) {
+            throw new IllegalArgumentException( "Only accept a List parameter." );
+        }
+        
+        list = (List<T>)object;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Parameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Parameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Parameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -5,110 +5,101 @@
 
 import java.util.Observable;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  */
 public abstract class Parameter extends Observable
 {
 
-	protected final String name;
+    protected final String name;
 
-	protected final boolean mutable;
+    protected final boolean mutable;
 
-	protected final String description;
-	
-	protected final String xpathExpr;
+    protected final String description;
 
-	protected Parameter( String name, boolean mutable, String description, String xpathExpr )
-	{
-		validateName( name );
+    protected Parameter( String name, boolean mutable, String description )
+    {
+        validateName( name );
 
-		this.name = name;
-		this.mutable = mutable;
-		this.description = description;
-		this.xpathExpr = xpathExpr;
-		
-		Config.addParameter( this );
-	}
+        this.name = name;
+        this.mutable = mutable;
+        this.description = description;
 
-	/**
-	 * Validate the name of the parameter. The name length must be > 0
-	 */
-	private void validateName( String name ) throws IllegalArgumentException
-	{
-		if ( (name == null) || (name.length() < 1) ) {
-			throw new IllegalArgumentException(
-					" A configuration parameter name can't be null or 0 length" );
-		}
-	}
+        Config.addParameter( this );
+    }
 
-	/**
-	 * Changes the value of this parameter
-	 * 
-	 * @param value
-	 * @throws IllegalArgumentException
-	 */
-	public abstract void setValue( String value ) throws IllegalArgumentException;
+    /**
+     * Validate the name of the parameter. The name length must be > 0
+     */
+    private void validateName( String name ) throws IllegalArgumentException
+    {
+        if ( (name == null) || (name.length() < 1) ) {
+            throw new IllegalArgumentException(
+                    " A configuration parameter name can't be null or 0 length" );
+        }
+    }
+    
+    /**
+     * @return a String representation of the value of this parameter.
+     */
+    public abstract String getStringValue();
 
-	/**
-	 * @return a String representation of the value of this parameter.
-	 */
-	public abstract String getStringValue();
+    public abstract Object getObjectValue();
 
-	public abstract Object getObjectValue();
+    public abstract void setObjectValue( Object object );
 
-	public abstract void setObjectValue( Object object );
+    /**
+     * @return the name of this parameter
+     */
+    public String getName()
+    {
+        return name;
+    }
 
-	/**
-	 * @return the name of this parameter
-	 */
-	public String getName()
-	{
-		return name;
-	}
+    /**
+     * @return true if this parameter is "mutable" (so that it can be modified
+     *         at runtime)
+     */
+    public boolean isMutable()
+    {
+        return mutable;
+    }
 
-	/**
-	 * @return true if this parameter is "mutable" (so that it can be modified
-	 *         at runtime)
-	 */
-	public boolean isMutable()
-	{
-		return mutable;
-	}
+    /**
+     * @return the description string of this parameter
+     */
+    public String getDescription()
+    {
+        return description;
+    }
 
-	/**
-	 * @return the description string of this parameter
-	 */
-	public String getDescription()
-	{
-		return description;
-	}
+    /**
+     * @return the string representation of the type for this parameter, such as
+     *         java.lang.String, java.lang.Integer...
+     */
+    public abstract String getType();
 
-	/**
-	 * @return the string representation of the type for this parameter, such as
-	 *         java.lang.String, java.lang.Integer...
-	 */
-	public abstract String getType();
+    /**
+     * Marks the parameter as changed and notify all the Observers.
+     * 
+     * @see java.util.Observable#setChanged()
+     */
+    @Override
+    protected void setChanged()
+    {
+        super.setChanged();
+        if ( mutable )
+            notifyObservers();
+    }
 
-	/**
-	 * @return the xpath expression used to address this parameter in the xml configuration file.
-	 * If null, this parameter is ignored in the configuration file evaluation.
-	 */
-	public final String getXPathExpr() {
-		return this.xpathExpr;
-	}
-	
-	/**
-	 * Marks the parameter as changed and notify all the Observers.
-	 * 
-	 * @see java.util.Observable#setChanged()
-	 */
-	@Override
-	protected void setChanged()
-	{
-		super.setChanged();
-		if ( mutable )
-			notifyObservers();
-	}
+    /**
+     * Concrete classes must use this method to read from a Configuration object
+     * the value of the parameter.
+     * 
+     * @param configuration
+     */
+    public abstract void readConfiguration( Configuration configuration );
 
-}
\ No newline at end of file
+}

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringListParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringListParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringListParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,108 +0,0 @@
-/**
- * 
- */
-package rtspproxy.config;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author Matteo Merli
- */
-public class StringListParameter extends ListParameter
-{
-	private List<String> values = null;
-
-	private String defaultValue;
-
-	public StringListParameter( String name, String defaultValue, boolean mutable,
-			String description, String xpathExpr )
-	{
-		super( name, mutable, description, xpathExpr );
-
-		if ( defaultValue == null )
-			throw new IllegalArgumentException( "Default value for " + name
-					+ " must be not null." );
-		this.defaultValue = defaultValue;
-	}
-
-	@Override
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-		this.values = new ArrayList<String>();
-		String[] tokens = value.split( "," );
-
-		for ( String token : tokens ) {
-			this.values.add( token );
-		}
-		setChanged();
-	}
-	
-	@Override	
-	public void addValue(String value) {
-		this.values.add(value);
-		
-		setChanged();
-	}
-
-	@Override
-	public String getStringValue()
-	{
-		if ( values == null )
-			return defaultValue.toString();
-
-		StringBuilder sb = new StringBuilder();
-		final int size = values.size();
-		for ( int i = 0; i < size; i++ ) {
-			sb.append( values.get( i ) );
-			if ( i < size - 1 )
-				sb.append( ", " );
-		}
-		return sb.toString();
-	}
-
-	/**
-	 * @return Returns the defaultValue.
-	 */
-	public String getDefaultValue()
-	{
-		return defaultValue;
-	}
-
-	public String[] getValue()
-	{
-		if ( values == null )
-			return new String[] { defaultValue };
-
-		String[] v = new String[values.size()];
-		for ( int i = values.size() - 1; i >= 0; i-- )
-			v[i] = values.get( i );
-		return v;
-	}
-
-	@Override
-	public String getType()
-	{
-		return "[Ljava.lang.String";
-	}
-
-	@Override
-	public Object getObjectValue()
-	{
-		return getValue();
-	}
-
-	@Override
-	public void setObjectValue( Object object )
-	{
-		if ( !(object instanceof String[]) )
-			throw new IllegalArgumentException( "Value must be a String[]" );
-
-		this.values = new ArrayList<String>( ((String[]) object).length );
-		for ( String s : (String[]) object )
-			values.add( s );
-
-		setChanged();
-	}
-
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringParameter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/StringParameter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,74 +1,96 @@
-/**
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - matteo.merli at gmail.com            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
  * 
+ * $URL$
+ * 
  */
 package rtspproxy.config;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  */
 public class StringParameter extends Parameter
 {
 
-	private String value = null;
+    private String value = null;
 
-	private String defaultValue;
+    private String defaultValue;
 
-	public StringParameter( String name, String defaultValue, boolean mutable,
-			String description, String xpathExpr )
-	{
-		super( name, mutable, description, xpathExpr );
-		this.defaultValue = defaultValue;
-	}
+    public StringParameter( String name, String defaultValue, boolean mutable,
+            String description )
+    {
+        super( name, mutable, description );
+        this.defaultValue = defaultValue;
+    }
 
-	@Override
-	public void setValue( String value ) throws IllegalArgumentException
-	{
-		this.value = value;
-		setChanged();
-	}
+    @Override
+    public String getStringValue()
+    {
+        return getValue();
+    }
 
-	@Override
-	public String getStringValue()
-	{
-		return getValue();
-	}
+    @Override
+    public String getType()
+    {
+        return "java.lang.String";
+    }
 
-	@Override
-	public String getType()
-	{
-		return "java.lang.String";
-	}
+    public String getValue()
+    {
+        return value == null ? defaultValue : value;
+    }
 
-	public String getValue()
-	{
-		return value == null ? defaultValue : value;
-	}
+    /**
+     * @return Returns the defaultValue.
+     */
+    public String getDefaultValue()
+    {
+        return defaultValue;
+    }
 
-	/**
-	 * @return Returns the defaultValue.
-	 */
-	public String getDefaultValue()
-	{
-		return defaultValue;
-	}
+    @Override
+    public Object getObjectValue()
+    {
+        return getValue();
+    }
 
-	@Override
-	public Object getObjectValue()
-	{
-		return getValue();
-	}
+    @Override
+    public void setObjectValue( Object object )
+    {
+        if ( object == null ) {
+            value = null;
+            return;
+        }
 
-	@Override
-	public void setObjectValue( Object object )
-	{
-		if ( !(object instanceof String) )
-			throw new IllegalArgumentException( "Value must be a String" );
+        if ( !(object instanceof String) )
+            throw new IllegalArgumentException( "Value for parameter '" + name
+                    + "' must be a String" );
 
-		if ( !object.equals( getObjectValue() ) ) {
-			// Only notify if the value is different
-			this.value = (String) object;
-			setChanged();
-		}
-	}
+        if ( !object.equals( getObjectValue() ) ) {
+            // Only notify if the value is different
+            this.value = (String) object;
+            setChanged();
+        }
+    }
 
+    @Override
+    public void readConfiguration( Configuration configuration )
+    {
+        String value = configuration.getString( name, defaultValue );
+        setObjectValue( value );
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,141 +1,96 @@
-/**
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - matteo.merli at gmail.com            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id: Main.java 378 2006-01-06 20:36:11Z rbieniek $
  * 
+ * $URL: https://svn.berlios.de/svnroot/repos/rtspproxy/trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java $
+ * 
  */
 package rtspproxy.config;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
+import java.io.BufferedReader;
 import java.io.File;
-import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
 import java.io.IOException;
-import java.io.InputStream;
-import java.util.List;
+import java.io.Reader;
+import java.util.NoSuchElementException;
 
-import org.dom4j.Attribute;
-import org.dom4j.Document;
+import org.apache.commons.configuration.ConfigurationException;
+import org.apache.commons.configuration.XMLConfiguration;
 import org.dom4j.DocumentException;
-import org.dom4j.Element;
-import org.dom4j.Node;
-import org.dom4j.io.SAXReader;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import rtspproxy.lib.Side;
-
 /**
  * This class implements a parser for XML configuration files.
+ * 
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  * @todo validate the parsed configuration file by a schema.
  */
-public class XMLConfigReader {
+public class XMLConfigReader
+{
 
-	// logger
-	private static final Logger logger = LoggerFactory.getLogger(XMLConfigReader.class);
-	
-	/**
-	 * create the xml config read object
-	 */
-	public XMLConfigReader() {}
-	
-	/**
-	 * read the configuration file.
-	 * @param fName the pathname of the configuration file
-	 * @exception IOException the file denoted by the file name cannot be read
-	 * @throws DocumentException parsing the config file failed.
-	 */ 
-	public final void readConfig(String fName) throws IOException, DocumentException {
-		logger.debug("radConfig, fName=" + fName);
-		File fFile = new File(fName);
-		
-		if(fFile.canRead())
-			this.readConfig(new FileInputStream(fFile));
-	}
-	
-	/**
-	 * read the configuration file
-	 * @param is the input stream to read the configuration from.
-	 * @throws DocumentException parsing the input stream failed.
-	 * @throws IllegalArgumentException invalid parameter value given
-	 */
-	public final void readConfig(InputStream is) throws DocumentException, IllegalArgumentException {
-		SAXReader reader = new SAXReader();
-		Document doc = reader.read(is); // TODO validate the document by a schema
-		
-		for(Parameter param : Config.getAllParameters()) {
-			String xpathExpr = param.getXPathExpr();
-			
-			if(xpathExpr != null) {
-				logger.debug("evaluating parameter " + param.getName() + " with xpath " + xpathExpr);
-				
-				List<Node> nodes = (List<Node>)doc.selectNodes(xpathExpr);
-				
-				if(nodes.size() > 1) {
-					if(param instanceof ListParameter) {
-						for(Node node : nodes) {
-							String value = null;
-							
-							if(node instanceof Attribute)
-								value = ((Attribute)node).getText();
-							else if(node instanceof Element)
-								value = ((Element)node).getTextTrim();
-							
-							if(value == null)
-								throw new IllegalArgumentException("Invalid value specified for parameter " + param.getName());
-							
-							((ListParameter)param).addValue(value);							
-						}
-					} else
-						throw new IllegalArgumentException("Parameter " + param.getName() + " is not a list value");
-				} else if(nodes.size() == 1){
-					String value = null;
-					Node node = nodes.get(0);
-					
-					if(node instanceof Attribute)
-						value = ((Attribute)node).getText();
-					else if(node instanceof Element)
-						value = ((Element)node).getTextTrim();
-					
-					if(value == null)
-						throw new IllegalArgumentException("Invalid value specified for parameter " + param.getName());
-					
-					param.setValue(value);
-				}
-			}
-		}
-		
-		for(Node aaaNode : (List<Node>)doc.selectNodes("/rtspproxy/filters/*")) {
-			String name = aaaNode.getName();
-			String implClass = ((Element)aaaNode).attributeValue("implClass");
-			Side side = Side.fromString(((Element)aaaNode).attributeValue("side"));
-			
-			logger.debug("element name=" + name + ", implClass=" + implClass + ",side=" + side);
-			
-			if(implClass == null || implClass.length() == 0)
-				throw new IllegalArgumentException("no implementation class given");
+    // logger
+    private static final Logger log = LoggerFactory.getLogger( XMLConfigReader.class );
 
-			AAAConfig aaa = new AAAConfig(implClass, side, 
-					(List<Element>)((Element)aaaNode).elements());
-			
-			for(Attribute attr : (List<Attribute>)((Element)aaaNode).attributes()) {
-				if(attr.getName().equals("implClass") || attr.getName().equals("side"))
-					continue;
-				aaa.setAttribute(attr.getName(), attr.getText().trim());
-			}
-			
-			if(name.equals("authentication")) {
-				Config.addAuthenticationFilter(aaa);
-			} else if(name.equals("ipaddress")) {
-				Config.addIpAddressFilter(aaa);
-			} else if(name.equals("accounting")) {
-				Config.addAccountingFilter(aaa);				
-			} else if(name.equals("rewriting")) {
-				Config.addUrlRewritingFilter(aaa);
-			} else if(name.equals("control")) {
-				if(side == Side.Client || side == Side.Server) 
-					Config.addControlFilter(aaa);
-				else
-					throw new IllegalArgumentException("control filters can be only applied to either client or server side, not both");
-			} else
-				throw new IllegalArgumentException("invalid AAA element given, name=" + name);
-		}
-	}
+    /**
+     * read the configuration file.
+     * 
+     * @param fileName
+     *            the pathname of the configuration file
+     * @exception IOException
+     *                the file denoted by the file name cannot be read
+     * @throws DocumentException
+     *             parsing the config file failed.
+     */
+    public final void readConfig( String fileName ) throws FileNotFoundException
+    {
+        log.debug( "Reading configuration file={}", fileName );
+        File file = new File( fileName );
+
+        if ( file.canRead() ) {
+            readConfig( new BufferedReader( new FileReader( file ) ) );
+        }
+    }
+
+    /**
+     * read the configuration file
+     * 
+     * @param is
+     *            the input stream to read the configuration from.
+     */
+    public final void readConfig( Reader reader )
+    {
+        XMLConfiguration configuration = new XMLConfiguration();
+        try {
+            configuration.load( reader );
+        } catch ( ConfigurationException e ) {
+            log.error( "Error reading configuration file." );
+            throw new RuntimeException( e );
+        }
+
+        for ( Parameter param : Config.getAllParameters() ) {
+            try {
+                param.readConfiguration( configuration );
+                log.debug( "Parameter value: {}", param.getStringValue() );
+
+            } catch ( NoSuchElementException e ) {
+                log.debug( "Parameter NOT found: '{}'. Using default value: {}", param
+                        .getName(), param.getStringValue() );
+
+            }
+        }
+
+        Config.updateDebugSettings();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -18,196 +18,220 @@
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public class FilterBase extends IoFilterAdapter {
+public class FilterBase extends IoFilterAdapter
+{
 
-	private static Logger logger = LoggerFactory.getLogger(FilterBase.class);
-	
-	// filter name
-	private String filterName;
-	
-	// class name
-	private String className;
-	
-	// filter type
-	private String typeName;
-	
-	// running flag
-	protected boolean running = true; 
-	
-	// side
-	private Side side;
-	
-	// MBean name assigned by JMX interface
-	private ObjectName mbeanName;
-	
-	// chain name of filter
-	private String chainName;
-	
-	/**
-	 * 
-	 */
-	public FilterBase(String filterName, String className, String typeName) {
-		this.filterName = filterName;
-		this.className = className;
-		this.typeName = typeName;
-	}
+    private static Logger logger = LoggerFactory.getLogger( FilterBase.class );
 
-	/**
-	 * 
-	 */
-	public FilterBase(String filterName, String typeName) {
-		this.filterName = filterName;
-		this.typeName = typeName;
-	}
+    // filter name
+    private String filterName;
 
-	/**
-	 * query running flag
-	 */
-	public final boolean isRunning() {
-		return this.running;
-	}
-	
-	/**
-	 * suspend the filter
-	 */
-	public final void suspend() {
-		this.running = false;
-		logger.info(getChainName() + " suspended");
-	}
-	
-	/**
-	 * resume the filter
-	 */
-	public final void resume() {
-		this.running = true;
-		logger.info(getChainName() + " resumed");
-	}
-	
-	/**
-	 * get the object name of a more specific MBean 
-	 */
-	public ObjectName getDetailMBean() {
-		return null;
-	}
-	
-	/**
-	 * get the side 
-	 */
-	public Side getSide() {
-		return this.side;
-	}
-	
-	/**
-	 * set the side
-	 */
-	public void setSide(Side side) {
-		this.side = side;
-	}
+    // class name
+    private String className;
 
-	/**
-	 * @return Returns the mbeanName.
-	 */
-	public ObjectName getMbeanName() {
-		return mbeanName;
-	}
+    // filter type
+    private String typeName;
 
-	/**
-	 * Set the name of the MBean used for filter management. This property is write-once.
-	 * @param mbeanName The mbeanName to set.
-	 */
-	public void setMbeanName(ObjectName mbeanName) {
-		// once set it can not change
-		if(this.mbeanName == null)
-			this.mbeanName = mbeanName;
-	}
+    // running flag
+    protected boolean running = true;
 
-	/**
-	 * @return Returns the className.
-	 */
-	public String getClassName() {
-		return className;
-	}
+    // side
+    private Side side;
 
-	/**
-	 * @return Returns the typeName.
-	 */
-	public String getTypeName() {
-		return typeName;
-	}
-	
-	/**
-	 * get the chain name for the filter. 
-	 */
-	public String getChainName() {
-		
-		if (this.chainName == null) {
-			StringBuffer buf = new StringBuffer(this.filterName);
+    // MBean name assigned by JMX interface
+    private ObjectName mbeanName;
 
-			buf.append("/");
-			buf.append(this.typeName);
-			if (this.className != null) {
-				buf.append("/");
-				buf.append(this.className);
-			}
+    // chain name of filter
+    private String chainName;
 
-			this.chainName = buf.toString();
-		}
-		return this.chainName;
-	}
-	
-	/**
-	 * load a provider class, instantiate an object, configure and init it.
-	 * @param className the name of the provider class to load
-	 * @param requiredInterface the provider interface the loaded class should implement.
-	 * This implementation assumes that the interface is a sub-interface of GenericProvider
-	 * @param configElements the configuration elements used to configure the loaded provider
-	 */
-	protected GenericProvider loadConfigInitProvider(String className, Class requiredInterface, 
-			List<Element> configElements) {
-		GenericProvider provider = null;
-		String providerName = requiredInterface.getSimpleName();
-		Class providerClass;
-		try {
-			providerClass = Class.forName( className );
+    /**
+     * 
+     */
+    public FilterBase( String filterName, String className, String typeName )
+    {
+        this.filterName = filterName;
+        this.className = className;
+        this.typeName = typeName;
+    }
 
-		} catch ( Throwable t ) {
-			logger.error( "Invalid " + providerName + "class: " + className, t );
-			Reactor.stop();
-			return null;
-		}
+    /**
+     * 
+     */
+    public FilterBase( String filterName, String typeName )
+    {
+        this.filterName = filterName;
+        this.typeName = typeName;
+    }
 
-		// Check if the class implements the IpAddressProvider interfaces
-		boolean found = false;
-		for ( Class interFace : providerClass.getInterfaces() ) {
-			if ( requiredInterface.equals( interFace ) ) {
-				found = true;
-				break;
-			}
-		}
+    /**
+     * query running flag
+     */
+    public final boolean isRunning()
+    {
+        return this.running;
+    }
 
-		if ( !found ) {
-			logger.error( "Class (" + providerClass
-					+ ") does not implement the " + providerName + " interface." );
-			Reactor.stop();
-			return null;
-		}
+    /**
+     * suspend the filter
+     */
+    public final void suspend()
+    {
+        this.running = false;
+        logger.info( getChainName() + " suspended" );
+    }
 
-		try {
-			provider = (GenericProvider) providerClass.newInstance();
-			
-			if(provider instanceof AAAConfigurable)
-				((AAAConfigurable)provider).configure(configElements);
+    /**
+     * resume the filter
+     */
+    public final void resume()
+    {
+        this.running = true;
+        logger.info( getChainName() + " resumed" );
+    }
 
-			provider.init();
+    /**
+     * get the object name of a more specific MBean
+     */
+    public ObjectName getDetailMBean()
+    {
+        return null;
+    }
 
-		} catch ( Exception e ) {
-			logger.error( "Error starting " + providerName + ": " + e );
-			Reactor.stop();
-			return null;
-		}		
-		
-		return provider;
-	}
+    /**
+     * get the side
+     */
+    public Side getSide()
+    {
+        return this.side;
+    }
+
+    /**
+     * set the side
+     */
+    public void setSide( Side side )
+    {
+        this.side = side;
+    }
+
+    /**
+     * @return Returns the mbeanName.
+     */
+    public ObjectName getMbeanName()
+    {
+        return mbeanName;
+    }
+
+    /**
+     * Set the name of the MBean used for filter management. This property is
+     * write-once.
+     * 
+     * @param mbeanName
+     *            The mbeanName to set.
+     */
+    public void setMbeanName( ObjectName mbeanName )
+    {
+        // once set it can not change
+        if ( this.mbeanName == null )
+            this.mbeanName = mbeanName;
+    }
+
+    /**
+     * @return Returns the className.
+     */
+    public String getClassName()
+    {
+        return className;
+    }
+
+    /**
+     * @return Returns the typeName.
+     */
+    public String getTypeName()
+    {
+        return typeName;
+    }
+
+    /**
+     * get the chain name for the filter.
+     */
+    public String getChainName()
+    {
+
+        if ( this.chainName == null ) {
+            StringBuffer buf = new StringBuffer( this.filterName );
+
+            buf.append( '/' );
+            buf.append( this.typeName );
+            if ( this.className != null ) {
+                buf.append( '/' );
+                buf.append( this.className );
+            }
+
+            this.chainName = buf.toString();
+        }
+        return this.chainName;
+    }
+
+    /**
+     * load a provider class, instantiate an object, configure and init it.
+     * 
+     * @param className
+     *            the name of the provider class to load
+     * @param requiredInterface
+     *            the provider interface the loaded class should implement. This
+     *            implementation assumes that the interface is a sub-interface
+     *            of GenericProvider
+     * @param configElements
+     *            the configuration elements used to configure the loaded
+     *            provider
+     */
+    protected GenericProvider loadConfigInitProvider( String className,
+            Class requiredInterface, List<Element> configElements )
+    {
+        GenericProvider provider = null;
+        String providerName = requiredInterface.getSimpleName();
+        Class providerClass;
+        try {
+            providerClass = Class.forName( className );
+
+        } catch ( Throwable t ) {
+            logger.error( "Invalid " + providerName + "class: " + className, t );
+            Reactor.stop();
+            return null;
+        }
+
+        // Check if the class implements the IpAddressProvider interfaces
+        boolean found = false;
+        for ( Class interFace : providerClass.getInterfaces() ) {
+            if ( requiredInterface.equals( interFace ) ) {
+                found = true;
+                break;
+            }
+        }
+
+        if ( !found ) {
+            logger.error( "Class ({}) does not implement the {} interface.", providerClass,
+                    providerName );
+            Reactor.stop();
+            return null;
+        }
+
+        try {
+            provider = (GenericProvider) providerClass.newInstance();
+
+            if ( provider instanceof AAAConfigurable )
+                ((AAAConfigurable) provider).configure( configElements );
+
+            provider.init();
+
+        } catch ( Exception e ) {
+            logger.error( "Error starting " + providerName + ": " + e );
+            Reactor.stop();
+            return null;
+        }
+
+        return provider;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,6 +1,21 @@
-/**
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - matteo.merli at gmail.com            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id: RtspFilters.java 406 2006-01-27 00:28:56Z rbieniek $
  * 
+ * $URL: https://svn.berlios.de/svnroot/repos/rtspproxy/trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java $
+ * 
  */
+
 package rtspproxy.filter;
 
 import java.util.Collections;
@@ -16,7 +31,6 @@
 import rtspproxy.filter.accounting.AccountingFilter;
 import rtspproxy.filter.authentication.AuthenticationFilter;
 import rtspproxy.filter.control.ClientControlFilter;
-import rtspproxy.filter.control.ControlFilter;
 import rtspproxy.filter.control.ServerControlFilter;
 import rtspproxy.filter.ipaddress.IpAddressFilter;
 import rtspproxy.filter.rewrite.ClientUrlRewritingFilter;
@@ -36,31 +50,31 @@
 	private static Logger logger = LoggerFactory.getLogger(FilterRegistry.class);
 
 	// client side address filters
-	private LinkedList<IpAddressFilter> clientAddressFilters = new LinkedList<IpAddressFilter>();
+	private List<IpAddressFilter> clientAddressFilters = new LinkedList<IpAddressFilter>();
 	
 	// server side address filters
-	private LinkedList<IpAddressFilter> serverAddressFilters = new LinkedList<IpAddressFilter>();
+	private List<IpAddressFilter> serverAddressFilters = new LinkedList<IpAddressFilter>();
 
 	// client side authentication filters
-	private LinkedList<AuthenticationFilter> clientAuthenticationFilters = new LinkedList<AuthenticationFilter>();
+	private List<AuthenticationFilter> clientAuthenticationFilters = new LinkedList<AuthenticationFilter>();
 	
 	// client side accounting filter
-	private LinkedList<AccountingFilter> clientAccountingFilters = new LinkedList<AccountingFilter>();
+	private List<AccountingFilter> clientAccountingFilters = new LinkedList<AccountingFilter>();
 	
 	// server side accounting filter
-	private LinkedList<AccountingFilter> serverAccountingFilters = new LinkedList<AccountingFilter>();
+	private List<AccountingFilter> serverAccountingFilters = new LinkedList<AccountingFilter>();
 	
 	// client side rewriting filters
-	private LinkedList<UrlRewritingFilter> clientUrlRewritingFilters = new LinkedList<UrlRewritingFilter>();
+	private List<UrlRewritingFilter> clientUrlRewritingFilters = new LinkedList<UrlRewritingFilter>();
 	
 	// server side rewriting filters
-	private LinkedList<UrlRewritingFilter> serverUrlRewritingFilters = new LinkedList<UrlRewritingFilter>();
+	private List<UrlRewritingFilter> serverUrlRewritingFilters = new LinkedList<UrlRewritingFilter>();
 	
 	// client side control traffic filters
-	private LinkedList<ClientControlFilter> clientControlFilters = new LinkedList<ClientControlFilter>();
+	private List<ClientControlFilter> clientControlFilters = new LinkedList<ClientControlFilter>();
 	
 	// client side control traffic filters
-	private LinkedList<ServerControlFilter> serverControlFilters = new LinkedList<ServerControlFilter>();
+	private List<ServerControlFilter> serverControlFilters = new LinkedList<ServerControlFilter>();
 	
 	/**
 	 * 
@@ -180,7 +194,7 @@
 	}
 	
 	private void registerFilterMBean(FilterBase filter) {
-		if(Config.proxyManagementEnable.getValue())
+		if(Config.jmxEnable.getValue())
 			JmxAgent.getInstance().registerFilter(filter);
 	}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -48,150 +48,136 @@
 public abstract class RtspFilters implements IoFilterChainBuilder
 {
 
-	private static ProtocolCodecFactory codecFactory = new ProtocolCodecFactory()
-	{
+    private static ProtocolCodecFactory codecFactory = new ProtocolCodecFactory()
+    {
 
-		// Decoders can be shared
-		private ProtocolEncoder rtspEncoder = new RtspEncoder();
+        // Decoders can be shared
+        private final ProtocolEncoder rtspEncoder = new RtspEncoder();
 
-		private ProtocolDecoder rtspDecoder = new RtspDecoder();
+        private final ProtocolDecoder rtspDecoder = new RtspDecoder();
 
-		public ProtocolEncoder getEncoder()
-		{
-			return rtspEncoder;
-		}
+        public ProtocolEncoder getEncoder()
+        {
+            return rtspEncoder;
+        }
 
-		public ProtocolDecoder getDecoder()
-		{
-			return rtspDecoder;
-		}
-	};
+        public ProtocolDecoder getDecoder()
+        {
+            return rtspDecoder;
+        }
+    };
 
-	private static final IoFilter codecFilter = new ProtocolCodecFilter( codecFactory );
+    private static final IoFilter codecFilter = new ProtocolCodecFilter( codecFactory );
 
-	public static final String rtspCodecNAME = "rtspCodec";
+    public static final String rtspCodecNAME = "rtspCodec";
 
-	/**
-	 * IP Address filter.
-	 * <p>
-	 * This needs to be the first filter in the chain to block blacklisted host
-	 * in the early stage of the connection, preventing network and computation
-	 * load from unwanted hosts.
-	 */
-	protected void addIpAddressFilter( IoFilterChain chain, Side side )
-	{
-		List<IpAddressFilter> filters;
-		
-		if(side == Side.Client)
-			filters = FilterRegistry.getInstance().getClientAddressFilters();
-		else
-			filters = FilterRegistry.getInstance().getServerAddressFilters();
-		
-		for(IpAddressFilter ipAddressFilter : filters) {
+    /**
+     * IP Address filter.
+     * <p>
+     * This needs to be the first filter in the chain to block blacklisted host
+     * in the early stage of the connection, preventing network and computation
+     * load from unwanted hosts.
+     */
+    protected void addIpAddressFilter( IoFilterChain chain, Side side )
+    {
+        // XXX: disabled
+        /*
+         * List<IpAddressFilter> filters;
+         * 
+         * if(side == Side.Client) filters =
+         * FilterRegistry.getInstance().getClientAddressFilters(); else filters =
+         * FilterRegistry.getInstance().getServerAddressFilters();
+         * 
+         * for(IpAddressFilter ipAddressFilter : filters) {
+         * 
+         * chain.addAfter( ProxyServiceRegistry.threadPoolFilterNAME,
+         * ipAddressFilter.getChainName(), ipAddressFilter );
+         *  }
+         */
+    }
 
-			chain.addAfter( ProxyServiceRegistry.threadPoolFilterNAME,
-					ipAddressFilter.getChainName(), ipAddressFilter );
-			
-		}
-		
-	}
+    /**
+     * The RTSP codec filter is always present. Translates the incoming streams
+     * into RTSP messages.
+     */
+    protected void addRtspCodecFilter( IoFilterChain chain )
+    {
+        chain.addLast( rtspCodecNAME, codecFilter );
+    }
 
-	/**
-	 * The RTSP codec filter is always present. Translates the incoming streams
-	 * into RTSP messages.
-	 */
-	protected void addRtspCodecFilter( IoFilterChain chain )
-	{
-		chain.addLast( rtspCodecNAME, codecFilter );
-	}
+    /**
+     * Authentication filter.
+     */
+    protected void addAuthenticationFilter( IoFilterChain chain )
+    {
+        for ( AuthenticationFilter authenticationFilter : FilterRegistry.getInstance()
+                .getClientAuthenticationFilters() ) {
+            chain.addAfter( rtspCodecNAME, authenticationFilter.getChainName(),
+                    authenticationFilter );
+        }
+    }
 
-	/**
-	 * Authentication filter.
-	 */
-	protected void addAuthenticationFilter( IoFilterChain chain )
-	{
-		for(AuthenticationFilter authenticationFilter : FilterRegistry.getInstance().getClientAuthenticationFilters()) {
-			chain.addAfter( rtspCodecNAME, authenticationFilter.getChainName(),
-					authenticationFilter );
-			
-		}
-	}
+    protected void addAccountingFilter( IoFilterChain chain, Side side )
+    {
+        // XXX: disabled
+        /*
+        List<AccountingFilter> filters;
 
-	protected void addAccountingFilter( IoFilterChain chain, Side side )
-	{
-		List<AccountingFilter> filters;
-		
-		if(side == Side.Client) {
-			filters = FilterRegistry.getInstance().getClientAccountingFilters();
+        if ( side == Side.Client ) {
+            filters = FilterRegistry.getInstance().getClientAccountingFilters();
 
-			for(AccountingFilter accountingFilter : filters) {
-				chain.addAfter( rtspCodecNAME,
-						accountingFilter.getChainName(), accountingFilter );
-			}
-		} else {
-			filters = FilterRegistry.getInstance().getServerAccountingFilters();
+            for ( AccountingFilter accountingFilter : filters ) {
+                chain.addAfter( rtspCodecNAME, accountingFilter.getChainName(),
+                        accountingFilter );
+            }
+        } else {
+            filters = FilterRegistry.getInstance().getServerAccountingFilters();
 
-			for(AccountingFilter accountingFilter : filters) {
-				chain.addAfter( rtspCodecNAME,
-						accountingFilter.getChainName(), accountingFilter );
-			}
-		}
-		
-		/*
-		boolean enableAccountingFilter = Config.proxyFilterAccountingEnable.getValue();
+            for ( AccountingFilter accountingFilter : filters ) {
+                chain.addAfter( rtspCodecNAME, accountingFilter.getChainName(),
+                        accountingFilter );
+            }
+        }
+        */
+    }
 
-		if ( enableAccountingFilter ) {
-			if ( accountingFilter == null ) {
-				accountingFilter = new AccountingFilter();
-			}
-			if ( chain.contains( authenticationFilterNAME ) ) {
-				/ *
-				 * If we have the authentication filter in the chain, it's
-				 * preferable to have the accounting after that, to see the user
-				 * identity if authenticated.
-				 * /
-				chain.addAfter( authenticationFilterNAME, accountingFilterNAME,
-						accountingFilter );
-			} else {
-				/ *
-				 * At least we want to have it after the RTSP codec, because it
-				 * deals with already parsed RTSP messages.
-				 * /
-				chain.addAfter( rtspCodecNAME, accountingFilterNAME, accountingFilter );
-			}
-		}
-		*/
-	}
+    protected void addRewriteFilter( IoFilterChain chain, Side side )
+    {
+        // XXX: disabled
+        /*
+        List<UrlRewritingFilter> filters;
 
-	protected void addRewriteFilter( IoFilterChain chain, Side side )
-	{
-		List<UrlRewritingFilter> filters;
-		
-		if(side == Side.Client)
-			filters = FilterRegistry.getInstance().getClientUrlRewritingFilters();
-		else
-			filters = FilterRegistry.getInstance().getServerUrlRewritingFilters();
-		
-		for(UrlRewritingFilter urlRewritingFilter : filters) {
+        if ( side == Side.Client )
+            filters = FilterRegistry.getInstance().getClientUrlRewritingFilters();
+        else
+            filters = FilterRegistry.getInstance().getServerUrlRewritingFilters();
 
-			chain.addAfter( rtspCodecNAME, urlRewritingFilter.getChainName(), urlRewritingFilter );
-			
-		}
-	}
+        for ( UrlRewritingFilter urlRewritingFilter : filters ) {
 
-	protected void addControlFilter ( IoFilterChain chain, Side side) {
-		if(side == Side.Client) {
-			List<ClientControlFilter> filters = FilterRegistry.getInstance().getClientControlFilters();
+            chain.addAfter( rtspCodecNAME, urlRewritingFilter.getChainName(),
+                    urlRewritingFilter );
+        }
+        */
+    }
 
-			for(ControlFilter controlFilter : filters) {
-				chain.addAfter( rtspCodecNAME, controlFilter.getChainName(), controlFilter);
-			}
-		} else {
-			List<ServerControlFilter> filters = FilterRegistry.getInstance().getServerControlFilters();
-		
-			for(ControlFilter controlFilter : filters) {
-				chain.addAfter( rtspCodecNAME, controlFilter.getChainName(), controlFilter);
-			}
-		}
-	}
+    protected void addControlFilter( IoFilterChain chain, Side side )
+    {
+        if ( side == Side.Client ) {
+            List<ClientControlFilter> filters = FilterRegistry.getInstance()
+                    .getClientControlFilters();
+
+            for ( ControlFilter controlFilter : filters ) {
+                chain.addAfter( rtspCodecNAME, controlFilter.getChainName(),
+                        controlFilter );
+            }
+        } else {
+            List<ServerControlFilter> filters = FilterRegistry.getInstance()
+                    .getServerControlFilters();
+
+            for ( ControlFilter controlFilter : filters ) {
+                chain.addAfter( rtspCodecNAME, controlFilter.getChainName(),
+                        controlFilter );
+            }
+        }
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -45,162 +45,160 @@
 public class AuthenticationFilter extends FilterBase
 {
 
-	private static Logger log = LoggerFactory.getLogger( AuthenticationFilter.class );
+    private static Logger log = LoggerFactory.getLogger( AuthenticationFilter.class );
 
-	public static final String FilterNAME = "authenticationFilter";
+    public static final String FilterNAME = "authenticationFilter";
 
-	public static final String ATTR = AuthenticationFilter.class.getName() + "Attr";
+    public static final String ATTR = AuthenticationFilter.class.getName() + "Attr";
 
-	private static final Map<String, Class> schemeRegistry = new HashMap<String, Class>();
+    private static final Map<String, Class> schemeRegistry = new HashMap<String, Class>();
 
-	static {
-		// Fill in known schemes
-		schemeRegistry.put( "basic", BasicAuthentication.class );
-		schemeRegistry.put( "digest", DigestAuthentication.class );
-	}
+    static {
+        // Fill in known schemes
+        schemeRegistry.put( "basic", BasicAuthentication.class );
+        schemeRegistry.put( "digest", DigestAuthentication.class );
+    }
 
-	/**
-	 * Backend provider.
-	 */
-	private AuthenticationProvider provider;
+    /**
+     * Backend provider.
+     */
+    private AuthenticationProvider provider;
 
-	/** Different authentication schemes implementation */
-	private AuthenticationScheme scheme = null;
+    /** Different authentication schemes implementation */
+    private AuthenticationScheme scheme = null;
 
-	/**
-	 * Construct a new AuthenticationFilter. Looks at the configuration to load
-	 * the choseen backend implementation.
-	 */
-	public AuthenticationFilter(String className, String schemeName, List<Element> configElements)
-	{
-		super(FilterNAME, className, "authentication");
-		
-		this.provider = (AuthenticationProvider)loadConfigInitProvider(className, 
-				AuthenticationProvider.class, 
-				configElements);
-		
-		// Validate the choosen authentication scheme
-		Class schemeClass = schemeRegistry.get( schemeName.toLowerCase() );
-		if ( schemeClass == null ) {
-			// scheme not found
-			log.error( "Authentication Scheme not found: " + schemeName
-					+ ". Valid values are: "
-					+ Arrays.toString( schemeRegistry.keySet().toArray() ) );
-			Reactor.stop();
-			return;
-		}
+    /**
+     * Construct a new AuthenticationFilter. Looks at the configuration to load
+     * the choseen backend implementation.
+     */
+    public AuthenticationFilter( String className, String schemeName,
+            List<Element> configElements )
+    {
+        super( FilterNAME, className, "authentication" );
 
-		// Instanciate the selected scheme
-		try {
-			scheme = (AuthenticationScheme) schemeClass.newInstance();
-		} catch ( Exception e ) {
-		}
+        this.provider = (AuthenticationProvider) loadConfigInitProvider( className,
+                AuthenticationProvider.class, configElements );
 
-		log.info( "Using AuthenticationFilter " + scheme.getName() + " (" + className
-				+ ")" );
-	}
+        // Validate the choosen authentication scheme
+        Class schemeClass = schemeRegistry.get( schemeName.toLowerCase() );
+        if ( schemeClass == null ) {
+            // scheme not found
+            log.error( "Authentication Scheme not found: " + schemeName
+                    + ". Valid values are: "
+                    + Arrays.toString( schemeRegistry.keySet().toArray() ) );
+            Reactor.stop();
+            return;
+        }
 
-	public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( !(message instanceof RtspRequest) ) {
-			// Shouldn't happen
-			log.warn( "Object message is not a RTSP message" );
-			return;
-		}
+        // Instanciate the selected scheme
+        try {
+            scheme = (AuthenticationScheme) schemeClass.newInstance();
+        } catch ( Exception e ) {
+        }
 
-		if (isRunning()) {
-			if (session.getAttribute(ATTR) != null) {
-				// Client already autheticated
-				log
-						.debug("Already authenticaed: "
-								+ session.getAttribute(ATTR));
-				nextFilter.messageReceived(session, message);
-			}
+        log.info( "Using AuthenticationFilter " + scheme.getName() + " (" + className
+                + ")" );
+    }
 
-			String authString = ((RtspMessage) message)
-					.getHeader("Proxy-Authorization");
-			if (authString == null) {
-				log.debug("RTSP message: \n" + message);
-				RtspResponse response = RtspResponse
-						.errorResponse(RtspCode.ProxyAuthenticationRequired);
-				response.setHeader("Proxy-Authenticate", scheme.getName() + " "
-						+ scheme.getChallenge());
+    @Override
+    public void messageReceived( final NextFilter nextFilter, final IoSession session,
+            final Object message ) throws Exception
+    {
+        if ( !(message instanceof RtspRequest) ) {
+            // Shouldn't happen
+            log.warn( "Object message is not a RTSP message" );
+            return;
+        }
 
-				log.debug("Sending RTSP message: \n" + response);
+        if ( isRunning() ) {
+            if ( session.getAttribute( ATTR ) != null ) {
+                // Client already autheticated
+                log.debug( "Already authenticaed: {}", session.getAttribute( ATTR ) );
+                nextFilter.messageReceived( session, message );
+            }
 
-				session.write(response);
-				return;
-			}
+            final String authString = ((RtspMessage) message)
+                    .getHeader( "Proxy-Authorization" );
+            if ( authString == null ) {
+                log.debug( "RTSP message: \n{}", message );
+                final RtspResponse response = RtspResponse
+                        .errorResponse( RtspCode.ProxyAuthenticationRequired );
+                
+                response.setHeader( "Proxy-Authenticate", scheme.getName() + " "
+                        + scheme.getChallenge() );
 
-			if (!validateAuthenticationScheme(authString)) {
-				RtspResponse response = RtspResponse
-						.errorResponse(RtspCode.BadRequest);
+                log.debug( "Sending RTSP message: \n{}", response );
 
-				session.write(response);
-				return;
-			}
+                session.write( response );
+                return;
+            }
 
-			log.debug("RTSP message: \n" + message);
+            if ( !validateAuthenticationScheme( authString ) ) {
+                final RtspResponse response = RtspResponse
+                        .errorResponse( RtspCode.BadRequest );
 
-			// Check the authentication credentials
-			Credentials credentials = scheme
-					.getCredentials((RtspMessage) message);
+                session.write( response );
+                return;
+            }
 
-			boolean authenticationOk = false;
-			if (credentials != null) {
-				String password = provider.getPassword(credentials
-						.getUserName());
-				if (password != null)
-					if (scheme.computeAuthentication(credentials, password) == true)
-						authenticationOk = true;
-			}
+            log.debug( "RTSP message: \n{}", message );
 
-			if (!authenticationOk) {
-				log.warn("Authentication failed for user: " + credentials);
-				RtspResponse response = RtspResponse
-						.errorResponse(RtspCode.ProxyAuthenticationRequired);
-				response.setHeader("Proxy-Authenticate", scheme.getName() + " "
-						+ scheme.getChallenge());
+            // Check the authentication credentials
+            final Credentials credentials = scheme.getCredentials( (RtspMessage) message );
 
-				session.write(response);
-				return;
-			}
+            boolean authenticationOk = false;
+            if ( credentials != null ) {
+                final String password = provider.getPassword( credentials.getUserName() );
+                if ( password != null )
+                    if ( scheme.computeAuthentication( credentials, password ) == true )
+                        authenticationOk = true;
+            }
 
-			log.debug("Authentication succesfull for user: " + credentials);
+            if ( !authenticationOk ) {
+                log.warn( "Authentication failed for user: {}", credentials );
+                final RtspResponse response = RtspResponse
+                        .errorResponse( RtspCode.ProxyAuthenticationRequired );
+                response.setHeader( "Proxy-Authenticate", scheme.getName() + " "
+                        + scheme.getChallenge() );
 
-			/*
-			 * Mark the session with an "authenticated" attribute. This will
-			 * prevent the check for the credentials for every message received.
-			 */
-			session.setAttribute(ATTR, credentials.getUserName());
-		}
-		
-		// Forward message
-		nextFilter.messageReceived( session, message );
-	}
+                session.write( response );
+                return;
+            }
 
-	/**
-	 * Gets the authentication scheme stated by the client.
-	 * 
-	 * @param authString
-	 * @return
-	 */
-	private boolean validateAuthenticationScheme( String authString )
-	{
-		String schemeName;
-		try {
-			schemeName = authString.split( " " )[0];
-		} catch ( IndexOutOfBoundsException e ) {
-			// Malformed auth string
-			return false;
-		}
+            log.debug( "Authentication succesfull for user: {}", credentials );
 
-		if ( schemeName.equalsIgnoreCase( scheme.getName() ) )
-			return true;
+            /*
+             * Mark the session with an "authenticated" attribute. This will
+             * prevent the check for the credentials for every message received.
+             */
+            session.setAttribute( ATTR, credentials.getUserName() );
+        }
 
-		// Scheme not valid
-		return false;
-	}
+        // Forward message
+        nextFilter.messageReceived( session, message );
+    }
 
+    /**
+     * Gets the authentication scheme stated by the client.
+     * 
+     * @param authString
+     * @return
+     */
+    private boolean validateAuthenticationScheme( String authString )
+    {
+        String schemeName;
+        try {
+            schemeName = authString.split( " " )[0];
+        } catch ( IndexOutOfBoundsException e ) {
+            // Malformed auth string
+            return false;
+        }
+
+        if ( schemeName.equalsIgnoreCase( scheme.getName() ) )
+            return true;
+
+        // Scheme not valid
+        return false;
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -64,12 +64,13 @@
 			byte[] decBytes = Base64.decode( authString );
 			String auth = StringUtil.toString( decBytes );
 
-			log.debug( "auth: " + auth );
+			log.debug( "auth: {}", auth );
 			username = auth.split( ":", 2 )[0];
 			password = auth.split( ":", 2 )[1];
-			log.debug( "username=" + username + " - password=" + password );
+			log.debug( "username={} - password={}", username, password );
+            
 		} catch ( Exception e ) {
-			log.warn( "Malformed authString: " + authString );
+			log.warn( "Malformed authString: {}", authString );
 			return null;
 		}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/Credentials.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/Credentials.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/Credentials.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,56 +26,60 @@
 public class Credentials
 {
 
-	protected String userName;
+    protected String userName;
 
-	protected String password;
-	
-	public Credentials()
-	{
-	}
+    protected String password;
 
-	public Credentials( String userName, String password )
-	{
-		this.userName = userName;
-		this.password = password;
-	}
+    public Credentials()
+    {
+    }
 
-	/**
-	 * @return Returns the password.
-	 */
-	public String getPassword()
-	{
-		return password;
-	}
+    public Credentials( String userName, String password )
+    {
+        this.userName = userName;
+        this.password = password;
+    }
 
-	/**
-	 * @param password
-	 *            The password to set.
-	 */
-	public void setPassword( String password )
-	{
-		this.password = password;
-	}
+    /**
+     * @return Returns the password.
+     */
+    public String getPassword()
+    {
+        return password;
+    }
 
-	/**
-	 * @return Returns the userName.
-	 */
-	public String getUserName()
-	{
-		return userName;
-	}
+    /**
+     * @param password
+     *            The password to set.
+     */
+    public void setPassword( String password )
+    {
+        this.password = password;
+    }
 
-	/**
-	 * @param userName
-	 *            The userName to set.
-	 */
-	public void setUserName( String userName )
-	{
-		this.userName = userName;
-	}
+    /**
+     * @return Returns the userName.
+     */
+    public String getUserName()
+    {
+        return userName;
+    }
 
-	public String toString()
-	{
-		return "(" + userName + ":" + password + ")";
-	}
+    /**
+     * @param userName
+     *            The userName to set.
+     */
+    public void setUserName( String userName )
+    {
+        this.userName = userName;
+    }
+
+    @Override
+    public String toString()
+    {
+        final StringBuilder sb = new StringBuilder();
+        sb.append( '(' ).append( userName ).append( ':' );
+        sb.append( password ).append( ')' );
+        return sb.toString();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/DigestAuthentication.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/DigestAuthentication.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/DigestAuthentication.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -1,3 +1,21 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2005 - Matteo Merli - matteo.merli at gmail.com            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
+ * 
+ * $URL$
+ * 
+ */
+
 package rtspproxy.filter.authentication.scheme;
 
 import static rtspproxy.lib.StringUtil.getStringMap;
@@ -21,300 +39,302 @@
 public class DigestAuthentication implements AuthenticationScheme
 {
 
-	private static Logger log = LoggerFactory.getLogger( DigestAuthentication.class );
+    private static Logger log = LoggerFactory.getLogger( DigestAuthentication.class );
 
-	/** This is the value of the validity of a challenge response. */
-	private static final int NONCE_TIMEOUT = 60 * 5; // 5 minutes
+    /** This is the value of the validity of a challenge response. */
+    private static final int NONCE_TIMEOUT = 60 * 5; // 5 minutes
 
-	private UnsignedLong privateKey;
+    private UnsignedLong privateKey;
 
-	private String realm;
+    private String realm;
 
-	private MessageDigest md5;
+    private MessageDigest md5;
 
-	public DigestAuthentication()
-	{
-		// Generate the private key
-		Random random = new Random();
-		privateKey = new UnsignedLong( random );
+    public DigestAuthentication()
+    {
+        // Generate the private key
+        Random random = new Random();
+        privateKey = new UnsignedLong( random );
 
-		try {
-			md5 = MessageDigest.getInstance( "MD5" );
-		} catch ( NoSuchAlgorithmException e ) {
-		}
+        try {
+            md5 = MessageDigest.getInstance( "MD5" );
+        } catch ( NoSuchAlgorithmException e ) {
+            log.error( "No such algorithm: MD5" );
+        }
 
-		// Initiazialize the realm string
-		realm = "realm="
-				+ quote( "RtspProxy@"
-						+ RtspService.getInstance().getAddress().getHostAddress() );
-	}
+        // Initiazialize the realm string
+        realm = "realm="
+                + quote( "RtspProxy@"
+                        + RtspService.getInstance().getAddress().getHostAddress() );
+    }
 
-	public String getName()
-	{
-		return "Digest";
-	}
+    public String getName()
+    {
+        return "Digest";
+    }
 
-	public Credentials getCredentials( RtspMessage message )
-	{
-		String authString = message.getHeader( "Proxy-Authorization" );
-		authString = authString.split( " " )[1];
-		Map<String, String> params = getStringMap( authString );
-		if ( params == null )
-			return null;
+    public Credentials getCredentials( RtspMessage message )
+    {
+        String authString = message.getHeader( "Proxy-Authorization" );
+        authString = authString.split( " " )[1];
+        Map<String, String> params = getStringMap( authString );
+        if ( params == null )
+            return null;
 
-		String username = params.get( "username" );
-		String response = params.get( "response" );
-		String realm = params.get( "realm" );
-		String nonce = params.get( "nonce" );
-		String uri = params.get( "uri" );
-		String cnonce = params.get( "cnonce" );
-		String nc = params.get( "nc" );
-		if ( username == null || response == null || realm == null || nonce == null
-				|| uri == null || cnonce == null || nc == null )
-			return null;
+        String username = params.get( "username" );
+        String response = params.get( "response" );
+        String realm = params.get( "realm" );
+        String nonce = params.get( "nonce" );
+        String uri = params.get( "uri" );
+        String cnonce = params.get( "cnonce" );
+        String nc = params.get( "nc" );
+        if ( username == null || response == null || realm == null || nonce == null
+                || uri == null || cnonce == null || nc == null )
+            return null;
 
-		// Check the validity of the nonce
-		String sTimeStamp = nonce.substring( 0, 16 );
-		long timestamp = Long.valueOf( sTimeStamp, 16 );
-		long current = System.currentTimeMillis();
-		long diff = current - timestamp;
-		log.debug( "Time diff: " + ((float) diff / 1000 ) + " sec" );
-		if ( diff < 0 || diff > NONCE_TIMEOUT * 1000 )
-			// Timeout excedeed
-			return null;
+        // Check the validity of the nonce
+        String sTimeStamp = nonce.substring( 0, 16 );
+        long timestamp = Long.valueOf( sTimeStamp, 16 );
+        long current = System.currentTimeMillis();
+        long diff = current - timestamp;
+        log.debug( "Time diff: {} sec", ((float) diff / 1000) );
+        if ( diff < 0 || diff > NONCE_TIMEOUT * 1000 )
+            // Timeout excedeed
+            return null;
 
-		DigestCredentials credentials = new DigestCredentials();
-		credentials.setUserName( username );
-		credentials.setResponse( response );
-		credentials.setRealm( realm );
-		credentials.setNonce( nonce );
-		credentials.setUri( uri );
-		credentials.setMethod( ( (RtspRequest) message ).getVerbString() );
-		credentials.setCnonce( cnonce );
-		credentials.setNc( nc );
+        DigestCredentials credentials = new DigestCredentials();
+        credentials.setUserName( username );
+        credentials.setResponse( response );
+        credentials.setRealm( realm );
+        credentials.setNonce( nonce );
+        credentials.setUri( uri );
+        credentials.setMethod( ((RtspRequest) message).getVerbString() );
+        credentials.setCnonce( cnonce );
+        credentials.setNc( nc );
 
-		return credentials;
-	}
+        return credentials;
+    }
 
-	public String getChallenge()
-	{
-		StringBuilder challenge = new StringBuilder();
-		challenge.append( realm ).append( "," );
-		challenge.append( "nonce=" ).append( quote( newNonce() ) ).append( "," );
-		challenge.append( "qop=auth," );
-		challenge.append( "algorithm=" ).append( quote("MD5") );
-		return challenge.toString();
-	}
+    public String getChallenge()
+    {
+        StringBuilder challenge = new StringBuilder();
+        challenge.append( realm ).append( ',' );
+        challenge.append( "nonce=" ).append( quote( newNonce() ) ).append( ',' );
+        challenge.append( "qop=auth," );
+        challenge.append( "algorithm=" ).append( quote( "MD5" ) );
+        return challenge.toString();
+    }
 
-	/**
-	 * Generate a new nonce, defined as
-	 * <code>time-stamp H(time-stamp ":" private-key)</code>
-	 * 
-	 * encoded in Base64.
-	 * 
-	 * @return the nonce
-	 */
-	private String newNonce()
-	{
-		UnsignedLong timestamp = new UnsignedLong( System.currentTimeMillis() );
+    /**
+     * Generate a new nonce, defined as
+     * <code>time-stamp H(time-stamp ":" private-key)</code>
+     * 
+     * encoded in Base64.
+     * 
+     * @return the nonce
+     */
+    private String newNonce()
+    {
+        UnsignedLong timestamp = new UnsignedLong( System.currentTimeMillis() );
 
-		byte[] firstPart = null;
-		synchronized ( md5 ) {
-			md5.update( timestamp.getBytes() );
-			md5.update( (byte) ':' );
-			md5.update( privateKey.getBytes() );
-			firstPart = md5.digest();
-		}
+        byte[] firstPart = null;
+        synchronized ( md5 ) {
+            md5.update( timestamp.getBytes() );
+            md5.update( (byte) ':' );
+            md5.update( privateKey.getBytes() );
+            firstPart = md5.digest();
+        }
 
-		return toHexString( timestamp.getBytes() ) + toHexString( firstPart );
-	}
+        return toHexString( timestamp.getBytes() ) + toHexString( firstPart );
+    }
 
-	public boolean computeAuthentication( Credentials credentials, String storedPassword )
-	{
-		if ( !( credentials instanceof DigestCredentials ) )
-			return false;
+    /**
+     * @param credentials
+     * @param storedPassword
+     * 
+     * @return true if the user authenticate. false if the authentication fails
+     */
+    public boolean computeAuthentication( Credentials credentials, String storedPassword )
+    {
+        if ( !(credentials instanceof DigestCredentials) )
+            return false;
 
-		// response = KD ( H(A1), unq(nonce-value) ":" H(A2) )
-		// A1 = unq(username-value) ":" unq(realm-value) ":" passwd
-		// A2 = Method ":" digest-uri-value
+        // response = KD ( H(A1), unq(nonce-value) ":" H(A2) )
+        // A1 = unq(username-value) ":" unq(realm-value) ":" passwd
+        // A2 = Method ":" digest-uri-value
 
-		DigestCredentials creds = (DigestCredentials) credentials;
-		String A1 = creds.getUserName() + ":" + creds.getRealm() + ":" + storedPassword;
-		String A2 = creds.getMethod() + ":" + creds.getUri();
+        DigestCredentials creds = (DigestCredentials) credentials;
+        String A1 = creds.getUserName() + ":" + creds.getRealm() + ":" + storedPassword;
+        String A2 = creds.getMethod() + ":" + creds.getUri();
 
-		byte[] response;
-		synchronized ( md5 ) {
-			md5.update( toByteArray( A1 ) );
-			byte[] HA1 = md5.digest();
-			md5.update( toByteArray( A2 ) );
-			byte[] HA2 = md5.digest();
+        byte[] response;
+        synchronized ( md5 ) {
+            md5.update( toByteArray( A1 ) );
+            byte[] HA1 = md5.digest();
+            md5.update( toByteArray( A2 ) );
+            byte[] HA2 = md5.digest();
 
-			String sHA1 = toHexString( HA1 );
-			String sHA2 = toHexString( HA2 );
+            String sHA1 = toHexString( HA1 );
+            String sHA2 = toHexString( HA2 );
 
-			md5.update( toByteArray( sHA1 ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( creds.getNonce() ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( creds.getNc() ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( creds.getCnonce() ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( "auth" ) );
-			md5.update( (byte) ':' );
-			md5.update( toByteArray( sHA2 ) );
-			response = md5.digest();
-		}
+            md5.update( toByteArray( sHA1 ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( creds.getNonce() ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( creds.getNc() ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( creds.getCnonce() ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( "auth" ) );
+            md5.update( (byte) ':' );
+            md5.update( toByteArray( sHA2 ) );
+            response = md5.digest();
+        }
 
-		String expectedResponse = toHexString( response );
-		log.debug( "Expected: " + expectedResponse );
-		log.debug( "Got:      " + creds.getResponse() );
-		return expectedResponse.equals( creds.getResponse() );
-	}
+        String expectedResponse = toHexString( response );
+        log.debug( "Expected: {}", expectedResponse );
+        log.debug( "Got:      {}", creds.getResponse() );
+        return expectedResponse.equals( creds.getResponse() );
+    }
 
-	/**
-	 * Specialized credentials class that holds all the relevant digest data.
-	 */
-	private static class DigestCredentials extends Credentials
-	{
+    /**
+     * Specialized credentials class that holds all the relevant digest data.
+     */
+    private static class DigestCredentials extends Credentials
+    {
 
-		private String response;
+        private String response;
+        private String realm;
+        private String nonce;
+        private String uri;
+        private String method;
+        private String cnonce;
+        private String nc;
 
-		private String realm;
+        /**
+         * @return Returns the nonce.
+         */
+        public String getNonce()
+        {
+            return nonce;
+        }
 
-		private String nonce;
+        /**
+         * @param nonce
+         *            The nonce to set.
+         */
+        public void setNonce( String nonce )
+        {
+            this.nonce = nonce;
+        }
 
-		private String uri;
+        /**
+         * @return Returns the realm.
+         */
+        public String getRealm()
+        {
+            return realm;
+        }
 
-		private String method;
+        /**
+         * @param realm
+         *            The realm to set.
+         */
+        public void setRealm( String realm )
+        {
+            this.realm = realm;
+        }
 
-		private String cnonce;
+        /**
+         * @return Returns the response.
+         */
+        public String getResponse()
+        {
+            return response;
+        }
 
-		private String nc;
+        /**
+         * @param response
+         *            The response to set.
+         */
+        public void setResponse( String response )
+        {
+            this.response = response;
+        }
 
-		/**
-		 * @return Returns the nonce.
-		 */
-		public String getNonce()
-		{
-			return nonce;
-		}
+        /**
+         * @return Returns the uri.
+         */
+        public String getUri()
+        {
+            return uri;
+        }
 
-		/**
-		 * @param nonce
-		 *            The nonce to set.
-		 */
-		public void setNonce( String nonce )
-		{
-			this.nonce = nonce;
-		}
+        /**
+         * @param uri
+         *            The uri to set.
+         */
+        public void setUri( String uri )
+        {
+            this.uri = uri;
+        }
 
-		/**
-		 * @return Returns the realm.
-		 */
-		public String getRealm()
-		{
-			return realm;
-		}
+        /**
+         * @return Returns the method.
+         */
+        public String getMethod()
+        {
+            return method;
+        }
 
-		/**
-		 * @param realm
-		 *            The realm to set.
-		 */
-		public void setRealm( String realm )
-		{
-			this.realm = realm;
-		}
+        /**
+         * @param method
+         *            The method to set.
+         */
+        public void setMethod( String method )
+        {
+            this.method = method;
+        }
 
-		/**
-		 * @return Returns the response.
-		 */
-		public String getResponse()
-		{
-			return response;
-		}
+        /**
+         * @return Returns the cnonce.
+         */
+        public String getCnonce()
+        {
+            return cnonce;
+        }
 
-		/**
-		 * @param response
-		 *            The response to set.
-		 */
-		public void setResponse( String response )
-		{
-			this.response = response;
-		}
+        /**
+         * @param cnonce
+         *            The cnonce to set.
+         */
+        public void setCnonce( String cnonce )
+        {
+            this.cnonce = cnonce;
+        }
 
-		/**
-		 * @return Returns the uri.
-		 */
-		public String getUri()
-		{
-			return uri;
-		}
+        /**
+         * @return Returns the nc.
+         */
+        public String getNc()
+        {
+            return nc;
+        }
 
-		/**
-		 * @param uri
-		 *            The uri to set.
-		 */
-		public void setUri( String uri )
-		{
-			this.uri = uri;
-		}
+        /**
+         * @param nc
+         *            The nc to set.
+         */
+        public void setNc( String nc )
+        {
+            this.nc = nc;
+        }
 
-		/**
-		 * @return Returns the method.
-		 */
-		public String getMethod()
-		{
-			return method;
-		}
+        @Override
+        public String toString()
+        {
+            return "(" + userName + ":" + response + ")";
+        }
 
-		/**
-		 * @param method
-		 *            The method to set.
-		 */
-		public void setMethod( String method )
-		{
-			this.method = method;
-		}
-
-		/**
-		 * @return Returns the cnonce.
-		 */
-		public String getCnonce()
-		{
-			return cnonce;
-		}
-
-		/**
-		 * @param cnonce
-		 *            The cnonce to set.
-		 */
-		public void setCnonce( String cnonce )
-		{
-			this.cnonce = cnonce;
-		}
-
-		/**
-		 * @return Returns the nc.
-		 */
-		public String getNc()
-		{
-			return nc;
-		}
-
-		/**
-		 * @param nc
-		 *            The nc to set.
-		 */
-		public void setNc( String nc )
-		{
-			this.nc = nc;
-		}
-
-		public String toString()
-		{
-			return "(" + userName + ":" + response + ")";
-		}
-
-	}
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,7 +6,6 @@
 import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -5,26 +5,17 @@
 
 import java.util.List;
 
-import org.apache.mina.common.IdleStatus;
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import rtspproxy.filter.FilterBase;
-import rtspproxy.rtsp.RtspMessage;
-import rtspproxy.rtsp.RtspRequest;
-import rtspproxy.rtsp.RtspResponse;
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  *
  */
-public class ControlFilter extends FilterBase {
-
-	private static Logger log = LoggerFactory.getLogger(ControlFilter.class);
-	
+public class ControlFilter extends FilterBase 
+{	
 	public static final String FilterNAME = "controlFilter";
 
 	protected ControlProvider provider;

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,7 +6,6 @@
 import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -16,51 +15,53 @@
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public class ServerControlFilter extends ControlFilter {
+public class ServerControlFilter extends ControlFilter
+{
 
-	private static Logger log = LoggerFactory.getLogger(ClientControlFilter.class);
+    private static Logger log = LoggerFactory.getLogger( ClientControlFilter.class );
 
-	/**
-	 * @param className
-	 * @param configElements
-	 * @param typeName
-	 */
-	public ServerControlFilter(String className, List<Element> configElements) {
-		super(className, configElements, "serverControl");
-	}
+    /**
+     * @param className
+     * @param configElements
+     * @param typeName
+     */
+    public ServerControlFilter( String className, List<Element> configElements )
+    {
+        super( className, configElements, "serverControl" );
+    }
 
-	@Override
-	public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( provider != null && isRunning()) {
-			if(message instanceof RtspResponse)
-				provider.processResponse(session, (RtspResponse)message);
-			else
-				log.error( "Expecting a RtspResponse. Received a "
-						+ message.getClass().getName() );
-		}
+    @Override
+    public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+        if ( provider != null && isRunning() ) {
+            if ( message instanceof RtspResponse )
+                provider.processResponse( session, (RtspResponse) message );
+            else
+                log.error( "Expecting a RtspResponse. Received a {}", message.getClass()
+                        .getName() );
+        }
 
-		// Forward message
-		nextFilter.messageReceived( session, message );
-	}
+        // Forward message
+        nextFilter.messageReceived( session, message );
+    }
 
-	@Override
-	public void messageSent( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( provider != null  && isRunning()) {
-			if ( message instanceof RtspRequest )
-				provider.processRequest(session, (RtspRequest)message);
-			else
-				log.error( "Expecting a Rtsprequest. Received a "
-						+ message.getClass().getName() );
-		}
-		
-		// Forward message
-		nextFilter.messageSent( session, message );
-	}
+    @Override
+    public void messageSent( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+        if ( provider != null && isRunning() ) {
+            if ( message instanceof RtspRequest )
+                provider.processRequest( session, (RtspRequest) message );
+            else
+                log.error( "Expecting a Rtsprequest. Received a {}",
+                        message.getClass().getName() );
+        }
 
+        // Forward message
+        nextFilter.messageSent( session, message );
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,14 +6,12 @@
 import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.rtsp.RtspMessage;
 import rtspproxy.rtsp.RtspRequest;
-import rtspproxy.rtsp.RtspResponse;
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,13 +6,11 @@
 import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.rtsp.RtspMessage;
-import rtspproxy.rtsp.RtspRequest;
 import rtspproxy.rtsp.RtspResponse;
 
 /**

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -11,10 +11,7 @@
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.mina.common.IoFilter;
-import org.apache.mina.common.IoFilterAdapter;
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.IoFilter.NextFilter;
 import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -23,7 +20,6 @@
 import rtspproxy.jmx.JmxManageable;
 import rtspproxy.jmx.JmxManageable2;
 import rtspproxy.proxy.ProxyHandler;
-import rtspproxy.rtsp.RtspMessage;
 import rtspproxy.rtsp.RtspRequest;
 import rtspproxy.rtsp.RtspResponse;
 
@@ -31,155 +27,169 @@
  * @author bieniekr
  * 
  */
-public abstract class UrlRewritingFilter extends FilterBase implements JmxManageable {
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory.getLogger(UrlRewritingFilter.class);
+public abstract class UrlRewritingFilter extends FilterBase implements JmxManageable
+{
 
-	public static final String FilterNAME = "rewriting";
+    /**
+     * Logger for this class
+     */
+    private static Logger log = LoggerFactory.getLogger( UrlRewritingFilter.class );
 
-	// the filter instance
-	protected UrlRewritingProvider provider;
+    public static final String FilterNAME = "rewriting";
 
-	// list of exposed session attributes
-	private String[] exposedAttributes;
-	
-	/**
-	 * construct the IoFilter around the filter class denoted by the clazz name
-	 * parameter.
-	 */
-	public UrlRewritingFilter(String className, List<Element> configElements)
-			throws Exception {
-		super(FilterNAME, className, "rewriting");
+    // the filter instance
+    protected UrlRewritingProvider provider;
 
-		this.provider = (UrlRewritingProvider)loadConfigInitProvider(className, 
-				UrlRewritingProvider.class, 
-				configElements);
-		
-		this.exposedAttributes = this.provider.getWantedSessionAttributes();
-		if(this.exposedAttributes == null)
-			this.exposedAttributes = new String[0];
-	}
+    // list of exposed session attributes
+    private String[] exposedAttributes;
 
-	public abstract void messageReceived(NextFilter nextFilter, IoSession session,
-			Object message) throws Exception;
-	
-	/**
-	 * process a request message
-	 * @return true if the caller should pass the message on, false if the message should not be
-	 * passed on
-	 */
-	protected boolean processRequest(IoSession session, RtspRequest req) {
-		boolean passOn = true;
-		
-		if (req.getUrl() != null) {
-			HashMap<String, Object> exposedSessionAttributes = new HashMap<String, Object>();
-			
-			for(String attr : this.exposedAttributes) {
-				logger.debug("exposing session attribute: " + attr);
-				if(session.containsAttribute(attr)) {
-					Object o = session.getAttribute(attr);
-					
-					logger.debug("attribute " + attr + " found in session, val=" + o);
-					exposedSessionAttributes.put(attr, o);
-				}
-				
-				if(ProxyHandler.containsSharedSessionAttribute(session, attr)) {
-					Object o = ProxyHandler.getSharedSessionAttribute(session, attr);
+    /**
+     * construct the IoFilter around the filter class denoted by the clazz name
+     * parameter.
+     */
+    public UrlRewritingFilter( String className, List<Element> configElements )
+            throws Exception
+    {
+        super( FilterNAME, className, "rewriting" );
 
-					logger.debug("attribute " + attr + " found in shared session map, val=" + o);
-					exposedSessionAttributes.put(attr, o);
-				}
-			}
-			
-			UrlRewritingResult result = this.provider.rewriteRequestUrl(req.getUrl(), req.getVerb(), 
-					session.getRemoteAddress(), req.getHeaders(), exposedSessionAttributes); 
-			
-			if(result != null) {
-				URL rewritten = result.getRewrittenUrl();
+        this.provider = (UrlRewritingProvider) loadConfigInitProvider( className,
+                UrlRewritingProvider.class, configElements );
 
-				if (rewritten != null) {
-					logger.debug("changed request URL from '" + req.getUrl()
-						+ "' to '" + rewritten + "'");
+        this.exposedAttributes = this.provider.getWantedSessionAttributes();
+        if ( this.exposedAttributes == null )
+            this.exposedAttributes = new String[0];
+    }
 
-					req.setUrl(rewritten);
-				} else if(result.getResponse() != null) {
-					RtspResponse resp = result.getResponse();
+    @Override
+    public abstract void messageReceived( NextFilter nextFilter, IoSession session,
+            Object message ) throws Exception;
 
-					resp.setCommonHeaders();
-					resp.setSequenceNumber(req.getSequenceNumber());
-					if(resp.getHeader("Session") != null)
-						resp.setHeader("Session", req.getHeader("Session"));
-					logger.debug("dropped  request, return response: " + resp);
+    /**
+     * process a request message
+     * 
+     * @return true if the caller should pass the message on, false if the
+     *         message should not be passed on
+     */
+    protected boolean processRequest( IoSession session, RtspRequest req )
+    {
+        boolean passOn = true;
 
-					session.write(resp);
-					passOn = false;
-				}
-			}
-		}
-		
-		return passOn;
-	}
-	
-	/**
-	 * process a response message
-	 */
-	protected void processResponse(RtspResponse resp) {
-		switch (resp.getRequestVerb()) {
-		case DESCRIBE:
-			rewriteUrlHeader("Content-base", resp);
-			break;
-		case PLAY:
-			// rewriteUrlHeader("RTP-Info", resp);
-			break;
-		}		
-	}
-	
-	/**
-	 * rewrite a header
-	 */
-	private void rewriteUrlHeader(String headerName, RtspResponse resp) {
-		String oldHeader = resp.getHeader(headerName);
+        if ( req.getUrl() != null ) {
+            HashMap<String, Object> exposedSessionAttributes = new HashMap<String, Object>();
 
-		if (oldHeader != null) {
-			logger.debug("old content " + headerName + " header value: "
-					+ oldHeader);
+            for ( String attr : this.exposedAttributes ) {
+                log.debug( "exposing session attribute: {}", attr );
+                if ( session.containsAttribute( attr ) ) {
+                    Object o = session.getAttribute( attr );
 
-			try {
-				URL header = this.provider.rewriteResponseHeaderUrl(new URL(
-						oldHeader));
+                    log.debug( "attribute {} found in session, val={}", attr, o );
+                    exposedSessionAttributes.put( attr, o );
+                }
 
-				if (header != null) {
-					logger.debug("changed header " + headerName + " to "
-							+ header);
+                if ( ProxyHandler.containsSharedSessionAttribute( session, attr ) ) {
+                    Object o = ProxyHandler.getSharedSessionAttribute( session, attr );
 
-					resp.setHeader(headerName, header.toString());
-				}
-			} catch (MalformedURLException mue) {
-				logger.error("failed to parse " + headerName + " header", mue);
-			}
-		}
-	}
+                    log.debug( "attribute {} found in shared session map, val={}", attr,
+                            o );
+                    exposedSessionAttributes.put( attr, o );
+                }
+            }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.jmx.JmxManageable#setMBeanServer(javax.management.MBeanServer)
-	 */
-	public void setMBeanServer(MBeanServer mbeanServer) {
-		if(this.provider instanceof JmxManageable)
-			((JmxManageable)this.provider).setMBeanServer(mbeanServer);
-	}
+            UrlRewritingResult result = this.provider.rewriteRequestUrl( req.getUrl(),
+                    req.getVerb(), session.getRemoteAddress(), req.getHeaders(),
+                    exposedSessionAttributes );
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.FilterBase#getDetailMBean()
-	 */
-	@Override
-	public ObjectName getDetailMBean() {
-		ObjectName name = null;
-		
-		if(this.provider instanceof JmxManageable2)
-			name = ((JmxManageable2)this.provider).getMBean();
-		
-		return name;
-	}
+            if ( result != null ) {
+                URL rewritten = result.getRewrittenUrl();
+
+                if ( rewritten != null ) {
+                    log.debug( "changed request URL from '{}' to '{}'", req.getUrl(),
+                            rewritten );
+
+                    req.setUrl( rewritten );
+                } else if ( result.getResponse() != null ) {
+                    RtspResponse resp = result.getResponse();
+
+                    resp.setCommonHeaders();
+                    resp.setSequenceNumber( req.getSequenceNumber() );
+                    if ( resp.getHeader( "Session" ) != null )
+                        resp.setHeader( "Session", req.getHeader( "Session" ) );
+                    log.debug( "dropped  request, return response: {}", resp );
+
+                    session.write( resp );
+                    passOn = false;
+                }
+            }
+        }
+
+        return passOn;
+    }
+
+    /**
+     * process a response message
+     */
+    protected void processResponse( RtspResponse resp )
+    {
+        switch ( resp.getRequestVerb() )
+        {
+        case DESCRIBE:
+            rewriteUrlHeader( "Content-base", resp );
+            break;
+        case PLAY:
+            // rewriteUrlHeader("RTP-Info", resp);
+            break;
+        }
+    }
+
+    /**
+     * rewrite a header
+     */
+    private void rewriteUrlHeader( String headerName, RtspResponse resp )
+    {
+        String oldHeader = resp.getHeader( headerName );
+
+        if ( oldHeader != null ) {
+            log.debug( "old content: {} header value: {}", headerName, oldHeader );
+
+            try {
+                URL header = this.provider
+                        .rewriteResponseHeaderUrl( new URL( oldHeader ) );
+
+                if ( header != null ) {
+                    log.debug( "changed header {} to {}", headerName, header );
+
+                    resp.setHeader( headerName, header.toString() );
+                }
+            } catch ( MalformedURLException mue ) {
+                log.error( "failed to parse {} header: {}", headerName, mue );
+            }
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.jmx.JmxManageable#setMBeanServer(javax.management.MBeanServer)
+     */
+    public void setMBeanServer( MBeanServer mbeanServer )
+    {
+        if ( this.provider instanceof JmxManageable )
+            ((JmxManageable) this.provider).setMBeanServer( mbeanServer );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getDetailMBean()
+     */
+    @Override
+    public ObjectName getDetailMBean()
+    {
+        ObjectName name = null;
+
+        if ( this.provider instanceof JmxManageable2 )
+            name = ((JmxManageable2) this.provider).getMBean();
+
+        return name;
+    }
 }

Added: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -0,0 +1,126 @@
+/**
+ * 
+ */
+package rtspproxy.filter.tracking;
+
+import java.net.URL;
+
+import org.apache.mina.common.IoSession;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import rtspproxy.rtsp.RtspRequest;
+import rtspproxy.rtsp.RtspTransport;
+
+/**
+ * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
+ * 
+ */
+public class RdtSessionClientTrackingFilter extends RdtSessionTrackingFilter {
+
+	private static Logger logger = LoggerFactory
+			.getLogger(RdtSessionClientTrackingFilter.class);
+
+	// session attribute
+	private static final String SessionAttribute = "lastSetupURL";
+
+	/**
+	 * @param filterName
+	 * @param typeName
+	 */
+	public RdtSessionClientTrackingFilter() {
+		super("client");
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.mina.common.IoFilterAdapter#messageSent(org.apache.mina.common.IoFilter.NextFilter,
+	 *      org.apache.mina.common.IoSession, java.lang.Object)
+	 */
+	@Override
+	public void messageSent(NextFilter nextFilter, IoSession session,
+			Object message) throws Exception {
+		handleMessage(session, message);
+
+		logger.debug("sending response to client: " + message);
+
+		nextFilter.messageSent(session, message);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see org.apache.mina.common.IoFilterAdapter#messageReceived(org.apache.mina.common.IoFilter.NextFilter,
+	 *      org.apache.mina.common.IoSession, java.lang.Object)
+	 */
+	@Override
+	public void messageReceived(NextFilter nextFilter, IoSession session,
+			Object message) throws Exception {
+		if (message instanceof RtspRequest) {
+			RtspRequest req = (RtspRequest) message;
+
+			logger.debug("having RTSP request message, message=" + req);
+			if (req.getVerb() == RtspRequest.Verb.SETUP) {
+				logger.debug("having SETUP request");
+
+				if (req.getUrl() != null) {
+					URL url = req.getUrl();
+
+					logger.debug("requesting setup for " + url);
+					session.setAttribute(SessionAttribute, url);
+				}
+			}
+		}
+
+		nextFilter.messageReceived(session, message);
+	}
+
+	@Override
+	protected void handleTransportRdtUdpUnicast(IoSession session,
+			RtspTransport transport) {
+		logger.debug("handling client-side RDT/UDP/unicast header, header="
+				+ transport);
+
+        logger.debug( "RDT tracking disabled. (merlimat)" );
+        // TODO: RDT tracking disabled. (merlimat)
+        /*
+		try {
+			if (ProxyHandler.containsSharedSessionAttribute(session,
+					RdtSessionToken.SessionAttribute)) {
+				RdtSessionToken token = (RdtSessionToken) ProxyHandler
+						.getSharedSessionAttribute(session,
+								RdtSessionToken.SessionAttribute);
+
+				logger.debug("have session token, server_addr="
+						+ token.getRemoteServer() + ", server_port="
+						+ token.getRemotePort() + ", client_addr="
+						+ session.getRemoteAddress() + ", client_port="
+						+ transport.getClientPort()[0]);
+
+				// now we can create and initialise
+				URL url = (URL) session.getAttribute(SessionAttribute);
+
+				InetSocketAddress serverAddr = new InetSocketAddress(
+						((InetSocketAddress) token.getRemoteServer())
+								.getAddress(), token.getRemotePort());
+
+				RdtTrack track;
+				if ((track = (RdtTrack) RdtTrack.getByServerAddress(serverAddr)) == null) {
+					logger.debug("creating new RdtTrack");
+
+					track = new RdtTrack(url.toString());
+
+					track.setClientAddress(((InetSocketAddress) session
+							.getRemoteAddress()).getAddress(), transport
+							.getClientPort()[0]);
+					track.setServerAddress(serverAddr.getAddress(), serverAddr
+							.getPort());
+				}
+			}
+		} catch (Throwable t) {
+			logger.error("runtime exception in RDP session handling code", t);
+		}
+        */
+	}
+}


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Added: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -0,0 +1,82 @@
+/**
+ * 
+ */
+package rtspproxy.filter.tracking;
+
+import org.apache.mina.common.IoSession;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import rtspproxy.config.Config;
+import rtspproxy.filter.FilterBase;
+import rtspproxy.rtsp.RtspRequest;
+import rtspproxy.rtsp.RtspResponse;
+import rtspproxy.rtsp.RtspTransport;
+import rtspproxy.rtsp.RtspTransportList;
+
+/**
+ * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
+ *
+ */
+public abstract class RdtSessionTrackingFilter extends FilterBase {
+	
+	private static Logger logger = LoggerFactory.getLogger(RdtSessionTrackingFilter.class);
+
+	public static final String FilterNAME = "rdtTrackingFilter";
+
+	/**
+	 * @param filterName
+	 * @param className
+	 * @param typeName
+	 */
+	public RdtSessionTrackingFilter(String typeName) {
+		super(FilterNAME, typeName);
+	}
+
+	/**
+	 * check the message for following conditions
+	 */
+	protected void handleMessage(IoSession session, Object message) {
+		if(Config.proxyTransportRdtEnable.getValue() && message instanceof RtspResponse) {
+			RtspResponse resp = (RtspResponse)message;
+			
+			logger.debug("analyzing RTSP response message");
+			if(resp.getRequestVerb() == RtspRequest.Verb.SETUP) {
+				logger.debug("found SETUP response");
+				
+				String transHdr = resp.getHeader("Transport");
+				
+				if(transHdr != null) {
+					logger.debug("SETUP response has transport header: " + transHdr);
+					
+					RtspTransportList rtl = new RtspTransportList(transHdr);
+					
+					if(rtl.count() == 1) {
+						// at this point we can only have one transport. Everything else is a protocol violation
+						RtspTransport transport = rtl.get(0);
+						
+						if(transport.getTransportProtocol() == RtspTransport.TransportProtocol.RDT) {
+							logger.debug("found RDT transport protocol");
+							
+							if(transport.getDeliveryType() == RtspTransport.DeliveryType.unicast
+									&& transport.getLowerTransport() == RtspTransport.LowerTransport.UDP) {
+								logger.debug("found RDT/UDP/unicast transport header, server_port=" 
+										+ transport.getServerPort()[0] + ", client_port=" 
+										+ transport.getClientPort()[0]);
+								
+								handleTransportRdtUdpUnicast(session, transport);
+							}
+						}
+					} else 
+						logger.error("found invalid transport header: " + transHdr);
+				}
+			}
+		}
+	}
+	
+	/**
+	 * handle the extracted RTSP response RDT/UDP/unicast transport header
+	 */
+	protected abstract void handleTransportRdtUdpUnicast(IoSession session, RtspTransport transport);
+	
+}


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Authenticator.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Authenticator.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Authenticator.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -40,45 +40,46 @@
 public class Authenticator implements JMXAuthenticator
 {
 
-	private static Logger log = LoggerFactory.getLogger( Authenticator.class );
+    private static Logger log = LoggerFactory.getLogger( Authenticator.class );
 
-	public Subject authenticate( Object credentials ) throws SecurityException
-	{
-		if ( !( credentials instanceof String[] ) )
-			throw new SecurityException( "Bad credentials" );
+    public Subject authenticate( Object credentials ) throws SecurityException
+    {
+        if ( !(credentials instanceof String[]) )
+            throw new SecurityException( "Bad credentials" );
 
-		String[] creds = (String[]) credentials;
-		if ( creds.length != 2 )
-			throw new SecurityException( "Bad credentials" );
+        String[] creds = (String[]) credentials;
+        if ( creds.length != 2 )
+            throw new SecurityException( "Bad credentials" );
 
-		String user = creds[0];
-		String password = creds[1];
+        String user = creds[0];
+        String password = creds[1];
 
-		if ( user == null ) {
-			log.info( "Authentication failed: null username" );
-			throw new SecurityException( "Bad user name" );
-		}
+        if ( user == null ) {
+            log.info( "Authentication failed: null username" );
+            throw new SecurityException( "Bad user name" );
+        }
 
-		if ( password == null ) {
-			log.info( "Authentication failed for user " + user + " null password." );
-			throw new SecurityException( "Bad password" );
-		}
+        if ( password == null ) {
+            log.info( "Authentication failed for user '{}': null password.", user );
+            throw new SecurityException( "Bad password" );
+        }
 
-		// Expected values
-		String adminUser = Config.proxyManagementUser.getValue();
-		String adminPassword = Config.proxyManagementPassword.getValue();
+        // Expected values
+        String adminUser = Config.jmxUser.getValue();
+        String adminPassword = Config.jmxPassword.getValue();
 
-		if ( !user.equals( adminUser ) || !password.equals( adminPassword ) ) {
-			log.info( "Authentication failed for user " + user
-					+ ". Invalid username or password." );
-			throw new SecurityException( "Invalid username or password." );
-		}
+        if ( !user.equals( adminUser ) || !password.equals( adminPassword ) ) {
+            log.info( "Authentication failed for user {}. Invalid username or password.",
+                    user );
+            throw new SecurityException( "Invalid username or password." );
+        }
 
-		log.debug( "Successful Authentication for user " + user );
-		Set<JMXPrincipal> principals = new HashSet<JMXPrincipal>();
-		principals.add( new JMXPrincipal( user ) );
-		Subject subject = new Subject( true, principals, Collections.EMPTY_SET,
-				Collections.EMPTY_SET );
-		return subject;
-	}
+        log.debug( "Successful Authentication for user '{}'", user );
+        
+        Set<JMXPrincipal> principals = new HashSet<JMXPrincipal>();
+        principals.add( new JMXPrincipal( user ) );
+        Subject subject = new Subject( true, principals, Collections.EMPTY_SET,
+                Collections.EMPTY_SET );
+        return subject;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -134,14 +134,14 @@
 
 	private void startWebConsole() throws Exception
 	{
-		boolean enabled = Config.proxyManagementWebEnable.getValue();
+		boolean enabled = Config.jmxWebEnable.getValue();
 		if ( !enabled )
 			return;
 
-		String host = Config.proxyManagementHost.getValue();
-		int port = Config.proxyManagementWebPort.getValue();
-		String user = Config.proxyManagementUser.getValue();
-		String password = Config.proxyManagementPassword.getValue();
+		String host = Config.jmxAddress.getValue();
+		int port = Config.jmxWebPort.getValue();
+		String user = Config.jmxUser.getValue();
+		String password = Config.jmxPassword.getValue();
 
 		HttpAdaptor adaptor = new HttpAdaptor();
 		ObjectName name = new ObjectName( "Server:name=HttpAdaptor" );
@@ -164,7 +164,7 @@
 	@SuppressWarnings("unchecked")
 	private void startConnectorServer() throws Exception
 	{
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -177,7 +177,7 @@
 		int namingPort = ( (Integer) mbeanServer.getAttribute( namingName, "Port" ) ).intValue();
 
 		String jndiPath = "/rtspproxy";
-		String host = Config.proxyManagementHost.getValue();
+		String host = Config.jmxAddress.getValue();
 		String uri = "service:jmx:rmi://" + host + "/jndi/rmi://" + host + ":"
 				+ namingPort + jndiPath;
 
@@ -207,7 +207,7 @@
 	 * register a MBean as a management facade to a filter implementation
 	 */
 	public void registerFilter(FilterBase filter) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -287,7 +287,7 @@
 	 * 
 	 */
 	public void registerProxySession(ProxySession session) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -306,7 +306,7 @@
 	 * unregister a proxy session
 	 */
 	public void unregisterProxySession(ProxySession session) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -318,9 +318,9 @@
 				session.setObjectName(null);
 			}
 		} catch(InstanceNotFoundException infe) {
-			log.debug("internal problem: MBean not found, name=" + session.getObjectName(), infe);
+			log.debug("internal problem: MBean not found, name={}", session.getObjectName(), infe);
 		} catch(Exception e) {
-			log.error( "failed to register proxy session MBean: session=" + session, e );
+			log.error( "failed to register proxy session MBean: session={}", session, e );
 		}
 		
 	}
@@ -330,7 +330,7 @@
 	 * 
 	 */
 	public void registerPortRangeRtpServerSessionfactory(PortrangeRtpServerSessionFactory sessionFactory) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -348,7 +348,7 @@
 	 * 
 	 */
 	public void unregisterPortRangeRtpServerSessionfactory() {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 
@@ -367,7 +367,7 @@
 	 * register a generated RTP server session in the portrange case
 	 */
 	public void registerPortrangeRtpServerSession(PortrangeRtpServerSession session) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 		
@@ -378,7 +378,7 @@
 			mbeanServer.registerMBean(mbean, name);
 			session.setObjectName(name);
 		} catch(Exception e) {
-			log.error( "failed to register proxy session MBean: session=" + session, e );
+			log.error( "failed to register proxy session MBean: session={}", session, e );
 		}
 	}
 	
@@ -386,7 +386,7 @@
 	 * register a generated RTP server session in the portrange case
 	 */
 	public void unregisterPortrangeRtpServerSession(PortrangeRtpServerSession session) {
-		boolean enabled = Config.proxyManagementRemoteEnable.getValue();
+		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
 		if ( !enabled )
 			return;
 		
@@ -400,7 +400,7 @@
 		} catch(InstanceNotFoundException infe) {
 			log.debug("internal problem: MBean not found, name=" + session.getObjectName(), infe);
 		} catch(Exception e) {
-			log.error( "failed to register proxy session MBean: session=" + session, e );
+			log.error( "failed to register proxy session MBean: session={}", session, e );
 		}		
 	}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -6,16 +6,20 @@
 import javax.management.MBeanServer;
 
 /**
- * This interface is implemented by components that wish you expose its own MBeans to the
- * managment interface.
+ * This interface is implemented by components that wish you expose its own
+ * MBeans to the managment interface.
  * 
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  */
-public interface JmxManageable {
-	/**
-	 * set the MBeanServer instance. This method becomes called after the MBean managing the
-	 * component has been created and attached to the MBeanServer.
-	 * @param mbeanServer the MBeanServer instance used to manage the RTSPProxy.
-	 */
-	public void setMBeanServer(MBeanServer mbeanServer);
+public interface JmxManageable
+{
+
+    /**
+     * Set the MBeanServer instance. This method becomes called after the MBean
+     * managing the component has been created and attached to the MBeanServer.
+     * 
+     * @param mbeanServer
+     *            the MBeanServer instance used to manage the RTSPProxy.
+     */
+    public void setMBeanServer( MBeanServer mbeanServer );
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/ParametersMBean.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/ParametersMBean.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/ParametersMBean.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -157,7 +157,7 @@
 		for ( Object obj : attributes ) {
 
 			attr = (Attribute) obj;
-			parameter = Config.getParameter( ((Attribute) attr).getName() );
+			parameter = Config.getParameter( attr.getName() );
 			if ( parameter == null )
 				continue;
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -2,47 +2,49 @@
 
 /**
  * Encodes and decodes to and from Base64 notation.
- *
+ * 
  * <p>
  * Change Log:
  * </p>
  * <ul>
- *  <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added
- *   some convenience methods for reading and writing to and from files.</li>
- *  <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems
- *   with other encodings (like EBCDIC).</li>
- *  <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the
- *   encoded data was a single byte.</li>
- *  <li>v2.0 - I got rid of methods that used booleans to set options. 
- *   Now everything is more consolidated and cleaner. The code now detects
- *   when data that's being decoded is gzip-compressed and will decompress it
- *   automatically. Generally things are cleaner. You'll probably have to
- *   change some method calls that you were making to support the new
- *   options format (<tt>int</tt>s that you "OR" together).</li>
- *  <li>v1.5.1 - Fixed bug when decompressing and decoding to a             
- *   byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>.      
- *   Added the ability to "suspend" encoding in the Output Stream so        
- *   you can turn on and off the encoding if you need to embed base64       
- *   data in an otherwise "normal" stream (like an XML file).</li>  
- *  <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself.
- *      This helps when using GZIP streams.
- *      Added the ability to GZip-compress objects before encoding them.</li>
- *  <li>v1.4 - Added helper methods to read/write files.</li>
- *  <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>
- *  <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream
- *      where last buffer being read, if not completely full, was not returned.</li>
- *  <li>v1.3.4 - Fixed when "improperly padded stream" error was thrown at the wrong time.</li>
- *  <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>
+ * <li>v2.1 - Cleaned up javadoc comments and unused variables and methods.
+ * Added some convenience methods for reading and writing to and from files.</li>
+ * <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on
+ * systems with other encodings (like EBCDIC).</li>
+ * <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the
+ * encoded data was a single byte.</li>
+ * <li>v2.0 - I got rid of methods that used booleans to set options. Now
+ * everything is more consolidated and cleaner. The code now detects when data
+ * that's being decoded is gzip-compressed and will decompress it automatically.
+ * Generally things are cleaner. You'll probably have to change some method
+ * calls that you were making to support the new options format (<tt>int</tt>s
+ * that you "OR" together).</li>
+ * <li>v1.5.1 - Fixed bug when decompressing and decoding to a byte[] using
+ * <tt>decode( String s, boolean gzipCompressed )</tt>. Added the ability to
+ * "suspend" encoding in the Output Stream so you can turn on and off the
+ * encoding if you need to embed base64 data in an otherwise "normal" stream
+ * (like an XML file).</li>
+ * <li>v1.5 - Output stream pases on flush() command but doesn't do anything
+ * itself. This helps when using GZIP streams. Added the ability to
+ * GZip-compress objects before encoding them.</li>
+ * <li>v1.4 - Added helper methods to read/write files.</li>
+ * <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li>
+ * <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input
+ * stream where last buffer being read, if not completely full, was not
+ * returned.</li>
+ * <li>v1.3.4 - Fixed when "improperly padded stream" error was thrown at the
+ * wrong time.</li>
+ * <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li>
  * </ul>
- *
+ * 
  * <p>
- * I am placing this code in the Public Domain. Do with it as you will.
- * This software comes with no guarantees or warranties but with
- * plenty of well-wishing instead!
- * Please visit <a href="http://iharder.net/base64">http://iharder.net/base64</a>
- * periodically to check for updates or to contribute improvements.
+ * I am placing this code in the Public Domain. Do with it as you will. This
+ * software comes with no guarantees or warranties but with plenty of
+ * well-wishing instead! Please visit <a
+ * href="http://iharder.net/base64">http://iharder.net/base64</a> periodically
+ * to check for updates or to contribute improvements.
  * </p>
- *
+ * 
  * @author Robert Harder
  * @author rob at iharder.net
  * @version 2.1
@@ -50,1300 +52,1389 @@
 public class Base64
 {
 
-	/* ********  P U B L I C   F I E L D S  ******** */
+    /* ******** P U B L I C F I E L D S ******** */
 
-	/** No options specified. Value is zero. */
-	public final static int NO_OPTIONS = 0;
+    /** No options specified. Value is zero. */
+    public final static int NO_OPTIONS = 0;
 
-	/** Specify encoding. */
-	public final static int ENCODE = 1;
+    /** Specify encoding. */
+    public final static int ENCODE = 1;
 
-	/** Specify decoding. */
-	public final static int DECODE = 0;
+    /** Specify decoding. */
+    public final static int DECODE = 0;
 
-	/** Specify that data should be gzip-compressed. */
-	public final static int GZIP = 2;
+    /** Specify that data should be gzip-compressed. */
+    public final static int GZIP = 2;
 
-	/** Don't break lines when encoding (violates strict Base64 specification) */
-	public final static int DONT_BREAK_LINES = 8;
+    /** Don't break lines when encoding (violates strict Base64 specification) */
+    public final static int DONT_BREAK_LINES = 8;
 
-	/* ********  P R I V A T E   F I E L D S  ******** */
+    /* ******** P R I V A T E F I E L D S ******** */
 
-	/** Maximum line length (76) of Base64 output. */
-	private final static int MAX_LINE_LENGTH = 76;
+    /** Maximum line length (76) of Base64 output. */
+    private final static int MAX_LINE_LENGTH = 76;
 
-	/** The equals sign (=) as a byte. */
-	private final static byte EQUALS_SIGN = (byte) '=';
+    /** The equals sign (=) as a byte. */
+    private final static byte EQUALS_SIGN = (byte) '=';
 
-	/** The new line character (\n) as a byte. */
-	private final static byte NEW_LINE = (byte) '\n';
+    /** The new line character (\n) as a byte. */
+    private final static byte NEW_LINE = (byte) '\n';
 
-	/** Preferred encoding. */
-	private final static String PREFERRED_ENCODING = "UTF-8";
+    /** Preferred encoding. */
+    private final static String PREFERRED_ENCODING = "UTF-8";
 
-	/** The 64 valid Base64 values. */
-	private final static byte[] ALPHABET;
-	private final static byte[] _NATIVE_ALPHABET = /* May be something funny like EBCDIC */
-	{ (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G',
-			(byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M',
-			(byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S',
-			(byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y',
-			(byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
-			(byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k',
-			(byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q',
-			(byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w',
-			(byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2',
-			(byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
-			(byte) '9', (byte) '+', (byte) '/' };
+    /** The 64 valid Base64 values. */
+    private final static byte[] ALPHABET;
 
-	/** Determine which ALPHABET to use. */
-	static {
-		byte[] __bytes;
-		try {
-			__bytes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".getBytes( PREFERRED_ENCODING );
-		} // end try
-		catch ( java.io.UnsupportedEncodingException use ) {
-			__bytes = _NATIVE_ALPHABET; // Fall back to native encoding
-		} // end catch
-		ALPHABET = __bytes;
-	} // end static
+    private final static byte[] _NATIVE_ALPHABET = /*
+                                                     * May be something funny
+                                                     * like EBCDIC
+                                                     */
+    { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G',
+            (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M',
+            (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S',
+            (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y',
+            (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
+            (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k',
+            (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q',
+            (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w',
+            (byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2',
+            (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
+            (byte) '9', (byte) '+', (byte) '/' };
 
-	/** 
-	 * Translates a Base64 value to either its 6-bit reconstruction value
-	 * or a negative number indicating some other meaning.
-	 **/
-	private final static byte[] DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
-			-5, -5, // Whitespace: Tab and Linefeed
-			-9, -9, // Decimal 11 - 12
-			-5, // Whitespace: Carriage Return
-			-9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
-			-9, -9, -9, -9, -9, // Decimal 27 - 31
-			-5, // Whitespace: Space
-			-9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
-			62, // Plus sign at decimal 43
-			-9, -9, -9, // Decimal 44 - 46
-			63, // Slash at decimal 47
-			52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
-			-9, -9, -9, // Decimal 58 - 60
-			-1, // Equals sign at decimal 61
-			-9, -9, -9, // Decimal 62 - 64
-			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
-			14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
-			-9, -9, -9, -9, -9, -9, // Decimal 91 - 96
-			26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
-			39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
-			-9, -9, -9, -9 // Decimal 123 - 126
-	/*,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 127 - 139
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
-	 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
-	};
+    /** Determine which ALPHABET to use. */
+    static {
+        byte[] __bytes;
+        try {
+            __bytes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
+                    .getBytes( PREFERRED_ENCODING );
+        } // end try
+        catch ( java.io.UnsupportedEncodingException use ) {
+            __bytes = _NATIVE_ALPHABET; // Fall back to native encoding
+        } // end catch
+        ALPHABET = __bytes;
+    } // end static
 
-	// I think I end up not using the BAD_ENCODING indicator.
-	//private final static byte BAD_ENCODING    = -9; // Indicates error in encoding
-	private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in encoding
-	private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in encoding
+    /**
+     * Translates a Base64 value to either its 6-bit reconstruction value or a
+     * negative number indicating some other meaning.
+     */
+    private final static byte[] DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal
+            // 0 -
+            // 8
+            -5, -5, // Whitespace: Tab and Linefeed
+            -9, -9, // Decimal 11 - 12
+            -5, // Whitespace: Carriage Return
+            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
+            // 26
+            -9, -9, -9, -9, -9, // Decimal 27 - 31
+            -5, // Whitespace: Space
+            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
+            62, // Plus sign at decimal 43
+            -9, -9, -9, // Decimal 44 - 46
+            63, // Slash at decimal 47
+            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
+            -9, -9, -9, // Decimal 58 - 60
+            -1, // Equals sign at decimal 61
+            -9, -9, -9, // Decimal 62 - 64
+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A'
+            // through 'N'
+            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O'
+            // through 'Z'
+            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
+            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a'
+            // through 'm'
+            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n'
+            // through 'z'
+            -9, -9, -9, -9 // Decimal 123 - 126
+    /*
+     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 140 - 152
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 166 - 178
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 205 - 217
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 231 - 243
+     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
+     */
+    };
 
-	/** Defeats instantiation. */
-	private Base64()
-	{
-	}
+    // I think I end up not using the BAD_ENCODING indicator.
+    // private final static byte BAD_ENCODING = -9; // Indicates error in
+    // encoding
+    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in
 
-	/* ********  E N C O D I N G   M E T H O D S  ******** */
+    // encoding
 
-	/**
-	 * Encodes up to the first three bytes of array <var>threeBytes</var>
-	 * and returns a four-byte array in Base64 notation.
-	 * The actual number of significant bytes in your array is
-	 * given by <var>numSigBytes</var>.
-	 * The array <var>threeBytes</var> needs only be as big as
-	 * <var>numSigBytes</var>.
-	 * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.
-	 *
-	 * @param b4 A reusable byte array to reduce array instantiation
-	 * @param threeBytes the array to convert
-	 * @param numSigBytes the number of significant bytes in your array
-	 * @return four byte array in Base64 notation.
-	 * @since 1.5.1
-	 */
-	private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes )
-	{
-		encode3to4( threeBytes, 0, numSigBytes, b4, 0 );
-		return b4;
-	} // end encode3to4
+    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in
 
-	/**
-	 * Encodes up to three bytes of the array <var>source</var>
-	 * and writes the resulting four Base64 bytes to <var>destination</var>.
-	 * The source and destination arrays can be manipulated
-	 * anywhere along their length by specifying 
-	 * <var>srcOffset</var> and <var>destOffset</var>.
-	 * This method does not check to make sure your arrays
-	 * are large enough to accomodate <var>srcOffset</var> + 3 for
-	 * the <var>source</var> array or <var>destOffset</var> + 4 for
-	 * the <var>destination</var> array.
-	 * The actual number of significant bytes in your array is
-	 * given by <var>numSigBytes</var>.
-	 *
-	 * @param source the array to convert
-	 * @param srcOffset the index where conversion begins
-	 * @param numSigBytes the number of significant bytes in your array
-	 * @param destination the array to hold the conversion
-	 * @param destOffset the index where output will be put
-	 * @return the <var>destination</var> array
-	 * @since 1.3
-	 */
-	private static byte[] encode3to4( byte[] source, int srcOffset, int numSigBytes,
-			byte[] destination, int destOffset )
-	{
-		//           1         2         3  
-		// 01234567890123456789012345678901 Bit position
-		// --------000000001111111122222222 Array position from threeBytes
-		// --------|    ||    ||    ||    | Six bit groups to index ALPHABET
-		//          >>18  >>12  >> 6  >> 0  Right shift necessary
-		//                0x3f  0x3f  0x3f  Additional AND
+    // encoding
 
-		// Create buffer with zero-padding if there are only one or two
-		// significant bytes passed in the array.
-		// We have to shift left 24 in order to flush out the 1's that appear
-		// when Java treats a value as negative that is cast from a byte to an int.
-		int inBuff = ( numSigBytes > 0 ? ( ( source[srcOffset] << 24 ) >>> 8 ) : 0 )
-				| ( numSigBytes > 1 ? ( ( source[srcOffset + 1] << 24 ) >>> 16 ) : 0 )
-				| ( numSigBytes > 2 ? ( ( source[srcOffset + 2] << 24 ) >>> 24 ) : 0 );
+    /** Defeats instantiation. */
+    private Base64()
+    {
+    }
 
-		switch ( numSigBytes ) {
-			case 3:
-				destination[destOffset] = ALPHABET[( inBuff >>> 18 )];
-				destination[destOffset + 1] = ALPHABET[( inBuff >>> 12 ) & 0x3f];
-				destination[destOffset + 2] = ALPHABET[( inBuff >>> 6 ) & 0x3f];
-				destination[destOffset + 3] = ALPHABET[( inBuff ) & 0x3f];
-				return destination;
+    /* ******** E N C O D I N G M E T H O D S ******** */
 
-			case 2:
-				destination[destOffset] = ALPHABET[( inBuff >>> 18 )];
-				destination[destOffset + 1] = ALPHABET[( inBuff >>> 12 ) & 0x3f];
-				destination[destOffset + 2] = ALPHABET[( inBuff >>> 6 ) & 0x3f];
-				destination[destOffset + 3] = EQUALS_SIGN;
-				return destination;
+    /**
+     * Encodes up to the first three bytes of array <var>threeBytes</var> and
+     * returns a four-byte array in Base64 notation. The actual number of
+     * significant bytes in your array is given by <var>numSigBytes</var>. The
+     * array <var>threeBytes</var> needs only be as big as <var>numSigBytes</var>.
+     * Code can reuse a byte array by passing a four-byte array as <var>b4</var>.
+     * 
+     * @param b4
+     *            A reusable byte array to reduce array instantiation
+     * @param threeBytes
+     *            the array to convert
+     * @param numSigBytes
+     *            the number of significant bytes in your array
+     * @return four byte array in Base64 notation.
+     * @since 1.5.1
+     */
+    private static byte[] encode3to4( byte[] b4, byte[] threeBytes, int numSigBytes )
+    {
+        encode3to4( threeBytes, 0, numSigBytes, b4, 0 );
+        return b4;
+    } // end encode3to4
 
-			case 1:
-				destination[destOffset] = ALPHABET[( inBuff >>> 18 )];
-				destination[destOffset + 1] = ALPHABET[( inBuff >>> 12 ) & 0x3f];
-				destination[destOffset + 2] = EQUALS_SIGN;
-				destination[destOffset + 3] = EQUALS_SIGN;
-				return destination;
+    /**
+     * Encodes up to three bytes of the array <var>source</var> and writes the
+     * resulting four Base64 bytes to <var>destination</var>. The source and
+     * destination arrays can be manipulated anywhere along their length by
+     * specifying <var>srcOffset</var> and <var>destOffset</var>. This method
+     * does not check to make sure your arrays are large enough to accomodate
+     * <var>srcOffset</var> + 3 for the <var>source</var> array or
+     * <var>destOffset</var> + 4 for the <var>destination</var> array. The
+     * actual number of significant bytes in your array is given by
+     * <var>numSigBytes</var>.
+     * 
+     * @param source
+     *            the array to convert
+     * @param srcOffset
+     *            the index where conversion begins
+     * @param numSigBytes
+     *            the number of significant bytes in your array
+     * @param destination
+     *            the array to hold the conversion
+     * @param destOffset
+     *            the index where output will be put
+     * @return the <var>destination</var> array
+     * @since 1.3
+     */
+    private static byte[] encode3to4( byte[] source, int srcOffset, int numSigBytes,
+            byte[] destination, int destOffset )
+    {
+        // 1 2 3
+        // 01234567890123456789012345678901 Bit position
+        // --------000000001111111122222222 Array position from threeBytes
+        // --------| || || || | Six bit groups to index ALPHABET
+        // >>18 >>12 >> 6 >> 0 Right shift necessary
+        // 0x3f 0x3f 0x3f Additional AND
 
-			default:
-				return destination;
-		} // end switch
-	} // end encode3to4
+        // Create buffer with zero-padding if there are only one or two
+        // significant bytes passed in the array.
+        // We have to shift left 24 in order to flush out the 1's that appear
+        // when Java treats a value as negative that is cast from a byte to an
+        // int.
+        int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
+                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
+                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
 
-	/**
-	 * Serializes an object and returns the Base64-encoded
-	 * version of that serialized object. If the object
-	 * cannot be serialized or there is another error,
-	 * the method will return <tt>null</tt>.
-	 * The object is not GZip-compressed before being encoded.
-	 *
-	 * @param serializableObject The object to encode
-	 * @return The Base64-encoded object
-	 * @since 1.4
-	 */
-	public static String encodeObject( java.io.Serializable serializableObject )
-	{
-		return encodeObject( serializableObject, NO_OPTIONS );
-	} // end encodeObject
+        switch ( numSigBytes )
+        {
+        case 3:
+            destination[destOffset] = ALPHABET[(inBuff >>> 18)];
+            destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
+            destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
+            destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
+            return destination;
 
-	/**
-	 * Serializes an object and returns the Base64-encoded
-	 * version of that serialized object. If the object
-	 * cannot be serialized or there is another error,
-	 * the method will return <tt>null</tt>.
-	 * <p>
-	 * Valid options:<pre>
-	 *   GZIP: gzip-compresses object before encoding it.
-	 *   DONT_BREAK_LINES: don't break lines at 76 characters
-	 *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-	 * </pre>
-	 * <p>
-	 * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or
-	 * <p>
-	 * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
-	 *
-	 * @param serializableObject The object to encode
-	 * @param options Specified options
-	 * @return The Base64-encoded object
-	 * @see Base64#GZIP
-	 * @see Base64#DONT_BREAK_LINES
-	 * @since 2.0
-	 */
-	public static String encodeObject( java.io.Serializable serializableObject,
-			int options )
-	{
-		// Streams
-		java.io.ByteArrayOutputStream baos = null;
-		java.io.OutputStream b64os = null;
-		java.io.ObjectOutputStream oos = null;
-		java.util.zip.GZIPOutputStream gzos = null;
+        case 2:
+            destination[destOffset] = ALPHABET[(inBuff >>> 18)];
+            destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
+            destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
+            destination[destOffset + 3] = EQUALS_SIGN;
+            return destination;
 
-		// Isolate options
-		int gzip = ( options & GZIP );
-		int dontBreakLines = ( options & DONT_BREAK_LINES );
+        case 1:
+            destination[destOffset] = ALPHABET[(inBuff >>> 18)];
+            destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
+            destination[destOffset + 2] = EQUALS_SIGN;
+            destination[destOffset + 3] = EQUALS_SIGN;
+            return destination;
 
-		try {
-			// ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream
-			baos = new java.io.ByteArrayOutputStream();
-			b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
+        default:
+            return destination;
+        } // end switch
+    } // end encode3to4
 
-			// GZip?
-			if ( gzip == GZIP ) {
-				gzos = new java.util.zip.GZIPOutputStream( b64os );
-				oos = new java.io.ObjectOutputStream( gzos );
-			} // end if: gzip
-			else
-				oos = new java.io.ObjectOutputStream( b64os );
+    /**
+     * Serializes an object and returns the Base64-encoded version of that
+     * serialized object. If the object cannot be serialized or there is another
+     * error, the method will return <tt>null</tt>. The object is not
+     * GZip-compressed before being encoded.
+     * 
+     * @param serializableObject
+     *            The object to encode
+     * @return The Base64-encoded object
+     * @since 1.4
+     */
+    public static String encodeObject( java.io.Serializable serializableObject )
+    {
+        return encodeObject( serializableObject, NO_OPTIONS );
+    } // end encodeObject
 
-			oos.writeObject( serializableObject );
-		} // end try
-		catch ( java.io.IOException e ) {
-			Exceptions.logStackTrace( e );
-			return null;
-		} // end catch
-		finally {
-			try {
-				oos.close();
-			} catch ( Exception e ) {
-			}
-			try {
-				gzos.close();
-			} catch ( Exception e ) {
-			}
-			try {
-				b64os.close();
-			} catch ( Exception e ) {
-			}
-			try {
-				baos.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+    /**
+     * Serializes an object and returns the Base64-encoded version of that
+     * serialized object. If the object cannot be serialized or there is another
+     * error, the method will return <tt>null</tt>.
+     * <p>
+     * Valid options:
+     * 
+     * <pre>
+     *      GZIP: gzip-compresses object before encoding it.
+     *      DONT_BREAK_LINES: don't break lines at 76 characters
+     *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * </pre>
+     * 
+     * <p>
+     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or
+     * <p>
+     * Example:
+     * <code>encodeObject( myObj, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
+     * 
+     * @param serializableObject
+     *            The object to encode
+     * @param options
+     *            Specified options
+     * @return The Base64-encoded object
+     * @see Base64#GZIP
+     * @see Base64#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeObject( java.io.Serializable serializableObject,
+            int options )
+    {
+        // Streams
+        java.io.ByteArrayOutputStream baos = null;
+        java.io.OutputStream b64os = null;
+        java.io.ObjectOutputStream oos = null;
+        java.util.zip.GZIPOutputStream gzos = null;
 
-		// Return value according to relevant encoding.
-		try {
-			return new String( baos.toByteArray(), PREFERRED_ENCODING );
-		} // end try
-		catch ( java.io.UnsupportedEncodingException uue ) {
-			return new String( baos.toByteArray() );
-		} // end catch
+        // Isolate options
+        int gzip = (options & GZIP);
+        int dontBreakLines = (options & DONT_BREAK_LINES);
 
-	} // end encode
+        try {
+            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream
+            baos = new java.io.ByteArrayOutputStream();
+            b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
 
-	/**
-	 * Encodes a byte array into Base64 notation.
-	 * Does not GZip-compress data.
-	 *
-	 * @param source The data to convert
-	 * @since 1.4
-	 */
-	public static String encodeBytes( byte[] source )
-	{
-		return encodeBytes( source, 0, source.length, NO_OPTIONS );
-	} // end encodeBytes
+            // GZip?
+            if ( gzip == GZIP ) {
+                gzos = new java.util.zip.GZIPOutputStream( b64os );
+                oos = new java.io.ObjectOutputStream( gzos );
+            } // end if: gzip
+            else
+                oos = new java.io.ObjectOutputStream( b64os );
 
-	/**
-	 * Encodes a byte array into Base64 notation.
-	 * <p>
-	 * Valid options:<pre>
-	 *   GZIP: gzip-compresses object before encoding it.
-	 *   DONT_BREAK_LINES: don't break lines at 76 characters
-	 *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-	 * </pre>
-	 * <p>
-	 * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
-	 * <p>
-	 * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
-	 *
-	 *
-	 * @param source The data to convert
-	 * @param options Specified options
-	 * @see Base64#GZIP
-	 * @see Base64#DONT_BREAK_LINES
-	 * @since 2.0
-	 */
-	public static String encodeBytes( byte[] source, int options )
-	{
-		return encodeBytes( source, 0, source.length, options );
-	} // end encodeBytes
+            oos.writeObject( serializableObject );
+        } // end try
+        catch ( java.io.IOException e ) {
+            Exceptions.logStackTrace( e );
+            return null;
+        } // end catch
+        finally {
+            try {
+                oos.close();
+            } catch ( Exception e ) {
+            }
+            try {
+                gzos.close();
+            } catch ( Exception e ) {
+            }
+            try {
+                b64os.close();
+            } catch ( Exception e ) {
+            }
+            try {
+                baos.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-	/**
-	 * Encodes a byte array into Base64 notation.
-	 * Does not GZip-compress data.
-	 *
-	 * @param source The data to convert
-	 * @param off Offset in array where conversion should begin
-	 * @param len Length of data to convert
-	 * @since 1.4
-	 */
-	public static String encodeBytes( byte[] source, int off, int len )
-	{
-		return encodeBytes( source, off, len, NO_OPTIONS );
-	} // end encodeBytes
+        // Return value according to relevant encoding.
+        try {
+            return new String( baos.toByteArray(), PREFERRED_ENCODING );
+        } // end try
+        catch ( java.io.UnsupportedEncodingException uue ) {
+            return new String( baos.toByteArray() );
+        } // end catch
 
-	/**
-	 * Encodes a byte array into Base64 notation.
-	 * <p>
-	 * Valid options:<pre>
-	 *   GZIP: gzip-compresses object before encoding it.
-	 *   DONT_BREAK_LINES: don't break lines at 76 characters
-	 *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-	 * </pre>
-	 * <p>
-	 * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
-	 * <p>
-	 * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
-	 *
-	 *
-	 * @param source The data to convert
-	 * @param off Offset in array where conversion should begin
-	 * @param len Length of data to convert
-	 * @param options Specified options
-	 * @see Base64#GZIP
-	 * @see Base64#DONT_BREAK_LINES
-	 * @since 2.0
-	 */
-	public static String encodeBytes( byte[] source, int off, int len, int options )
-	{
-		// Isolate options
-		int dontBreakLines = ( options & DONT_BREAK_LINES );
-		int gzip = ( options & GZIP );
+    } // end encode
 
-		// Compress?
-		if ( gzip == GZIP ) {
-			java.io.ByteArrayOutputStream baos = null;
-			java.util.zip.GZIPOutputStream gzos = null;
-			Base64.OutputStream b64os = null;
+    /**
+     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
+     * 
+     * @param source
+     *            The data to convert
+     * @since 1.4
+     */
+    public static String encodeBytes( byte[] source )
+    {
+        return encodeBytes( source, 0, source.length, NO_OPTIONS );
+    } // end encodeBytes
 
-			try {
-				// GZip -> Base64 -> ByteArray
-				baos = new java.io.ByteArrayOutputStream();
-				b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
-				gzos = new java.util.zip.GZIPOutputStream( b64os );
+    /**
+     * Encodes a byte array into Base64 notation.
+     * <p>
+     * Valid options:
+     * 
+     * <pre>
+     *      GZIP: gzip-compresses object before encoding it.
+     *      DONT_BREAK_LINES: don't break lines at 76 characters
+     *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * </pre>
+     * 
+     * <p>
+     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
+     * <p>
+     * Example:
+     * <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
+     * 
+     * 
+     * @param source
+     *            The data to convert
+     * @param options
+     *            Specified options
+     * @see Base64#GZIP
+     * @see Base64#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeBytes( byte[] source, int options )
+    {
+        return encodeBytes( source, 0, source.length, options );
+    } // end encodeBytes
 
-				gzos.write( source, off, len );
-				gzos.close();
-			} // end try
-			catch ( java.io.IOException e ) {
-				Exceptions.logStackTrace( e );
-				return null;
-			} // end catch
-			finally {
-				try {
-					gzos.close();
-				} catch ( Exception e ) {
-				}
-				try {
-					b64os.close();
-				} catch ( Exception e ) {
-				}
-				try {
-					baos.close();
-				} catch ( Exception e ) {
-				}
-			} // end finally
+    /**
+     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
+     * 
+     * @param source
+     *            The data to convert
+     * @param off
+     *            Offset in array where conversion should begin
+     * @param len
+     *            Length of data to convert
+     * @since 1.4
+     */
+    public static String encodeBytes( byte[] source, int off, int len )
+    {
+        return encodeBytes( source, off, len, NO_OPTIONS );
+    } // end encodeBytes
 
-			// Return value according to relevant encoding.
-			try {
-				return new String( baos.toByteArray(), PREFERRED_ENCODING );
-			} // end try
-			catch ( java.io.UnsupportedEncodingException uue ) {
-				return new String( baos.toByteArray() );
-			} // end catch
-		} // end if: compress
+    /**
+     * Encodes a byte array into Base64 notation.
+     * <p>
+     * Valid options:
+     * 
+     * <pre>
+     *      GZIP: gzip-compresses object before encoding it.
+     *      DONT_BREAK_LINES: don't break lines at 76 characters
+     *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+     * </pre>
+     * 
+     * <p>
+     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
+     * <p>
+     * Example:
+     * <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
+     * 
+     * 
+     * @param source
+     *            The data to convert
+     * @param off
+     *            Offset in array where conversion should begin
+     * @param len
+     *            Length of data to convert
+     * @param options
+     *            Specified options
+     * @see Base64#GZIP
+     * @see Base64#DONT_BREAK_LINES
+     * @since 2.0
+     */
+    public static String encodeBytes( byte[] source, int off, int len, int options )
+    {
+        // Isolate options
+        int dontBreakLines = (options & DONT_BREAK_LINES);
+        int gzip = (options & GZIP);
 
-		// Else, don't compress. Better not to use streams at all then.
-		else {
-			// Convert option to boolean in way that code likes it.
-			boolean breakLines = dontBreakLines == 0;
+        // Compress?
+        if ( gzip == GZIP ) {
+            java.io.ByteArrayOutputStream baos = null;
+            java.util.zip.GZIPOutputStream gzos = null;
+            Base64.OutputStream b64os = null;
 
-			int len43 = len * 4 / 3;
-			byte[] outBuff = new byte[( len43 ) // Main 4:3
-					+ ( ( len % 3 ) > 0 ? 4 : 0 ) // Account for padding
-					+ ( breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0 )]; // New lines      
-			int d = 0;
-			int e = 0;
-			int len2 = len - 2;
-			int lineLength = 0;
-			for ( ; d < len2; d += 3, e += 4 ) {
-				encode3to4( source, d + off, 3, outBuff, e );
+            try {
+                // GZip -> Base64 -> ByteArray
+                baos = new java.io.ByteArrayOutputStream();
+                b64os = new Base64.OutputStream( baos, ENCODE | dontBreakLines );
+                gzos = new java.util.zip.GZIPOutputStream( b64os );
 
-				lineLength += 4;
-				if ( breakLines && lineLength == MAX_LINE_LENGTH ) {
-					outBuff[e + 4] = NEW_LINE;
-					e++;
-					lineLength = 0;
-				} // end if: end of line
-			} // en dfor: each piece of array
+                gzos.write( source, off, len );
+                gzos.close();
+            } // end try
+            catch ( java.io.IOException e ) {
+                Exceptions.logStackTrace( e );
+                return null;
+            } // end catch
+            finally {
+                try {
+                    gzos.close();
+                } catch ( Exception e ) {
+                }
+                try {
+                    b64os.close();
+                } catch ( Exception e ) {
+                }
+                try {
+                    baos.close();
+                } catch ( Exception e ) {
+                }
+            } // end finally
 
-			if ( d < len ) {
-				encode3to4( source, d + off, len - d, outBuff, e );
-				e += 4;
-			} // end if: some padding needed
+            // Return value according to relevant encoding.
+            try {
+                return new String( baos.toByteArray(), PREFERRED_ENCODING );
+            } // end try
+            catch ( java.io.UnsupportedEncodingException uue ) {
+                return new String( baos.toByteArray() );
+            } // end catch
+        } // end if: compress
 
-			// Return value according to relevant encoding.
-			try {
-				return new String( outBuff, 0, e, PREFERRED_ENCODING );
-			} // end try
-			catch ( java.io.UnsupportedEncodingException uue ) {
-				return new String( outBuff, 0, e );
-			} // end catch
+        // Else, don't compress. Better not to use streams at all then.
 
-		} // end else: don't compress
+        // Convert option to boolean in way that code likes it.
+        boolean breakLines = dontBreakLines == 0;
 
-	} // end encodeBytes
+        int len43 = len * 4 / 3;
+        byte[] outBuff = new byte[(len43) // Main 4:3
+                + ((len % 3) > 0 ? 4 : 0) // Account for padding
+                + (breakLines ? (len43 / MAX_LINE_LENGTH) : 0)]; // New lines
+        int d = 0;
+        int e = 0;
+        int len2 = len - 2;
+        int lineLength = 0;
+        for ( ; d < len2; d += 3, e += 4 ) {
+            encode3to4( source, d + off, 3, outBuff, e );
 
-	/* ********  D E C O D I N G   M E T H O D S  ******** */
+            lineLength += 4;
+            if ( breakLines && lineLength == MAX_LINE_LENGTH ) {
+                outBuff[e + 4] = NEW_LINE;
+                e++;
+                lineLength = 0;
+            } // end if: end of line
+        } // en dfor: each piece of array
 
-	/**
-	 * Decodes four bytes from array <var>source</var>
-	 * and writes the resulting bytes (up to three of them)
-	 * to <var>destination</var>.
-	 * The source and destination arrays can be manipulated
-	 * anywhere along their length by specifying 
-	 * <var>srcOffset</var> and <var>destOffset</var>.
-	 * This method does not check to make sure your arrays
-	 * are large enough to accomodate <var>srcOffset</var> + 4 for
-	 * the <var>source</var> array or <var>destOffset</var> + 3 for
-	 * the <var>destination</var> array.
-	 * This method returns the actual number of bytes that 
-	 * were converted from the Base64 encoding.
-	 * 
-	 *
-	 * @param source the array to convert
-	 * @param srcOffset the index where conversion begins
-	 * @param destination the array to hold the conversion
-	 * @param destOffset the index where output will be put
-	 * @return the number of decoded bytes converted
-	 * @since 1.3
-	 */
-	private static int decode4to3( byte[] source, int srcOffset, byte[] destination,
-			int destOffset )
-	{
-		// Example: Dk==
-		if ( source[srcOffset + 2] == EQUALS_SIGN ) {
-			// Two ways to do the same thing. Don't know which way I like best.
-			//int outBuff =   ( ( DECODABET[ source[ srcOffset    ] ] << 24 ) >>>  6 )
-			//              | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );
-			int outBuff = ( ( DECODABET[source[srcOffset]] & 0xFF ) << 18 )
-					| ( ( DECODABET[source[srcOffset + 1]] & 0xFF ) << 12 );
+        if ( d < len ) {
+            encode3to4( source, d + off, len - d, outBuff, e );
+            e += 4;
+        } // end if: some padding needed
 
-			destination[destOffset] = (byte) ( outBuff >>> 16 );
-			return 1;
-		}
+        // Return value according to relevant encoding.
+        try {
+            return new String( outBuff, 0, e, PREFERRED_ENCODING );
+        } // end try
+        catch ( java.io.UnsupportedEncodingException uue ) {
+            return new String( outBuff, 0, e );
+        } // end catch
 
-		// Example: DkL=
-		else
-			if ( source[srcOffset + 3] == EQUALS_SIGN ) {
-				// Two ways to do the same thing. Don't know which way I like best.
-				//int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )
-				//              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
-				//              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );
-				int outBuff = ( ( DECODABET[source[srcOffset]] & 0xFF ) << 18 )
-						| ( ( DECODABET[source[srcOffset + 1]] & 0xFF ) << 12 )
-						| ( ( DECODABET[source[srcOffset + 2]] & 0xFF ) << 6 );
+    } // end encodeBytes
 
-				destination[destOffset] = (byte) ( outBuff >>> 16 );
-				destination[destOffset + 1] = (byte) ( outBuff >>> 8 );
-				return 2;
-			}
+    /* ******** D E C O D I N G M E T H O D S ******** */
 
-			// Example: DkLE
-			else {
-				try {
-					// Two ways to do the same thing. Don't know which way I like best.
-					//int outBuff =   ( ( DECODABET[ source[ srcOffset     ] ] << 24 ) >>>  6 )
-					//              | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
-					//              | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )
-					//              | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );
-					int outBuff = ( ( DECODABET[source[srcOffset]] & 0xFF ) << 18 )
-							| ( ( DECODABET[source[srcOffset + 1]] & 0xFF ) << 12 )
-							| ( ( DECODABET[source[srcOffset + 2]] & 0xFF ) << 6 )
-							| ( ( DECODABET[source[srcOffset + 3]] & 0xFF ) );
+    /**
+     * Decodes four bytes from array <var>source</var> and writes the resulting
+     * bytes (up to three of them) to <var>destination</var>. The source and
+     * destination arrays can be manipulated anywhere along their length by
+     * specifying <var>srcOffset</var> and <var>destOffset</var>. This method
+     * does not check to make sure your arrays are large enough to accomodate
+     * <var>srcOffset</var> + 4 for the <var>source</var> array or
+     * <var>destOffset</var> + 3 for the <var>destination</var> array. This
+     * method returns the actual number of bytes that were converted from the
+     * Base64 encoding.
+     * 
+     * 
+     * @param source
+     *            the array to convert
+     * @param srcOffset
+     *            the index where conversion begins
+     * @param destination
+     *            the array to hold the conversion
+     * @param destOffset
+     *            the index where output will be put
+     * @return the number of decoded bytes converted
+     * @since 1.3
+     */
+    private static int decode4to3( byte[] source, int srcOffset, byte[] destination,
+            int destOffset )
+    {
+        // Example: Dk==
+        if ( source[srcOffset + 2] == EQUALS_SIGN ) {
+            // Two ways to do the same thing. Don't know which way I like best.
+            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 ) >>> 6
+            // )
+            // | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );
+            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
+                    | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);
 
-					destination[destOffset] = (byte) ( outBuff >> 16 );
-					destination[destOffset + 1] = (byte) ( outBuff >> 8 );
-					destination[destOffset + 2] = (byte) ( outBuff );
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            return 1;
+        }
 
-					return 3;
-				} catch ( Exception e ) {
-					System.out.println( "" + source[srcOffset] + ": "
-							+ ( DECODABET[source[srcOffset]] ) );
-					System.out.println( "" + source[srcOffset + 1] + ": "
-							+ ( DECODABET[source[srcOffset + 1]] ) );
-					System.out.println( "" + source[srcOffset + 2] + ": "
-							+ ( DECODABET[source[srcOffset + 2]] ) );
-					System.out.println( "" + source[srcOffset + 3] + ": "
-							+ ( DECODABET[source[srcOffset + 3]] ) );
-					return -1;
-				} //e nd catch
-			}
-	} // end decodeToBytes
+        // Example: DkL=
+        else if ( source[srcOffset + 3] == EQUALS_SIGN ) {
+            // Two ways to do the same thing. Don't know which way I like best.
+            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 ) >>> 6
+            // )
+            // | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
+            // | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );
+            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
+                    | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12)
+                    | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);
 
-	/**
-	 * Very low-level access to decoding ASCII characters in
-	 * the form of a byte array. Does not support automatically
-	 * gunzipping or any other "fancy" features.
-	 *
-	 * @param source The Base64 encoded data
-	 * @param off    The offset of where to begin decoding
-	 * @param len    The length of characters to decode
-	 * @return decoded data
-	 * @since 1.3
-	 */
-	public static byte[] decode( byte[] source, int off, int len )
-	{
-		int len34 = len * 3 / 4;
-		byte[] outBuff = new byte[len34]; // Upper limit on size of output
-		int outBuffPosn = 0;
+            destination[destOffset] = (byte) (outBuff >>> 16);
+            destination[destOffset + 1] = (byte) (outBuff >>> 8);
+            return 2;
+        }
 
-		byte[] b4 = new byte[4];
-		int b4Posn = 0;
-		int i = 0;
-		byte sbiCrop = 0;
-		byte sbiDecode = 0;
-		for ( i = off; i < off + len; i++ ) {
-			sbiCrop = (byte) ( source[i] & 0x7f ); // Only the low seven bits
-			sbiDecode = DECODABET[sbiCrop];
+        // Example: DkLE
+        else {
+            try {
+                // Two ways to do the same thing. Don't know which way I like
+                // best.
+                // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 )
+                // >>> 6 )
+                // | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
+                // | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )
+                // | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );
+                int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
+                        | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12)
+                        | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6)
+                        | ((DECODABET[source[srcOffset + 3]] & 0xFF));
 
-			if ( sbiDecode >= WHITE_SPACE_ENC ) // White space, Equals sign or better
-			{
-				if ( sbiDecode >= EQUALS_SIGN_ENC ) {
-					b4[b4Posn++] = sbiCrop;
-					if ( b4Posn > 3 ) {
-						outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn );
-						b4Posn = 0;
+                destination[destOffset] = (byte) (outBuff >> 16);
+                destination[destOffset + 1] = (byte) (outBuff >> 8);
+                destination[destOffset + 2] = (byte) (outBuff);
 
-						// If that was the equals sign, break out of 'for' loop
-						if ( sbiCrop == EQUALS_SIGN )
-							break;
-					} // end if: quartet built
+                return 3;
+            } catch ( Exception e ) {
+                System.out.println( "" + source[srcOffset] + ": "
+                        + (DECODABET[source[srcOffset]]) );
+                System.out.println( "" + source[srcOffset + 1] + ": "
+                        + (DECODABET[source[srcOffset + 1]]) );
+                System.out.println( "" + source[srcOffset + 2] + ": "
+                        + (DECODABET[source[srcOffset + 2]]) );
+                System.out.println( "" + source[srcOffset + 3] + ": "
+                        + (DECODABET[source[srcOffset + 3]]) );
+                return -1;
+            } // e nd catch
+        }
+    } // end decodeToBytes
 
-				} // end if: equals sign or better
+    /**
+     * Very low-level access to decoding ASCII characters in the form of a byte
+     * array. Does not support automatically gunzipping or any other "fancy"
+     * features.
+     * 
+     * @param source
+     *            The Base64 encoded data
+     * @param off
+     *            The offset of where to begin decoding
+     * @param len
+     *            The length of characters to decode
+     * @return decoded data
+     * @since 1.3
+     */
+    public static byte[] decode( byte[] source, int off, int len )
+    {
+        int len34 = len * 3 / 4;
+        byte[] outBuff = new byte[len34]; // Upper limit on size of output
+        int outBuffPosn = 0;
 
-			} // end if: white space, equals sign or better
-			else {
-				System.err.println( "Bad Base64 input character at " + i + ": "
-						+ source[i] + "(decimal)" );
-				return null;
-			} // end else: 
-		} // each input character
+        byte[] b4 = new byte[4];
+        int b4Posn = 0;
+        int i = 0;
+        byte sbiCrop = 0;
+        byte sbiDecode = 0;
+        for ( i = off; i < off + len; i++ ) {
+            sbiCrop = (byte) (source[i] & 0x7f); // Only the low seven bits
+            sbiDecode = DECODABET[sbiCrop];
 
-		byte[] out = new byte[outBuffPosn];
-		System.arraycopy( outBuff, 0, out, 0, outBuffPosn );
-		return out;
-	} // end decode
+            if ( sbiDecode >= WHITE_SPACE_ENC ) // White space, Equals sign or
+            // better
+            {
+                if ( sbiDecode >= EQUALS_SIGN_ENC ) {
+                    b4[b4Posn++] = sbiCrop;
+                    if ( b4Posn > 3 ) {
+                        outBuffPosn += decode4to3( b4, 0, outBuff, outBuffPosn );
+                        b4Posn = 0;
 
-	/**
-	 * Decodes data from Base64 notation, automatically
-	 * detecting gzip-compressed data and decompressing it.
-	 *
-	 * @param s the string to decode
-	 * @return the decoded data
-	 * @since 1.4
-	 */
-	public static byte[] decode( String s )
-	{
-		byte[] bytes;
-		try {
-			bytes = s.getBytes( PREFERRED_ENCODING );
-		} // end try
-		catch ( java.io.UnsupportedEncodingException uee ) {
-			bytes = s.getBytes();
-		} // end catch
-		//</change>
+                        // If that was the equals sign, break out of 'for' loop
+                        if ( sbiCrop == EQUALS_SIGN )
+                            break;
+                    } // end if: quartet built
 
-		// Decode
-		bytes = decode( bytes, 0, bytes.length );
+                } // end if: equals sign or better
 
-		// Check to see if it's gzip-compressed
-		// GZIP Magic Two-Byte Number: 0x8b1f (35615)
-		if ( bytes != null && bytes.length >= 4 ) {
+            } // end if: white space, equals sign or better
+            else {
+                System.err.println( "Bad Base64 input character at " + i + ": "
+                        + source[i] + "(decimal)" );
+                return null;
+            } // end else:
+        } // each input character
 
-			int head = ( (int) bytes[0] & 0xff ) | ( ( bytes[1] << 8 ) & 0xff00 );
-			if ( java.util.zip.GZIPInputStream.GZIP_MAGIC == head ) {
-				java.io.ByteArrayInputStream bais = null;
-				java.util.zip.GZIPInputStream gzis = null;
-				java.io.ByteArrayOutputStream baos = null;
-				byte[] buffer = new byte[2048];
-				int length = 0;
+        byte[] out = new byte[outBuffPosn];
+        System.arraycopy( outBuff, 0, out, 0, outBuffPosn );
+        return out;
+    } // end decode
 
-				try {
-					baos = new java.io.ByteArrayOutputStream();
-					bais = new java.io.ByteArrayInputStream( bytes );
-					gzis = new java.util.zip.GZIPInputStream( bais );
+    /**
+     * Decodes data from Base64 notation, automatically detecting
+     * gzip-compressed data and decompressing it.
+     * 
+     * @param s
+     *            the string to decode
+     * @return the decoded data
+     * @since 1.4
+     */
+    public static byte[] decode( String s )
+    {
+        byte[] bytes;
+        try {
+            bytes = s.getBytes( PREFERRED_ENCODING );
+        } // end try
+        catch ( java.io.UnsupportedEncodingException uee ) {
+            bytes = s.getBytes();
+        } // end catch
+        // </change>
 
-					while ( ( length = gzis.read( buffer ) ) >= 0 ) {
-						baos.write( buffer, 0, length );
-					} // end while: reading input
+        // Decode
+        bytes = decode( bytes, 0, bytes.length );
 
-					// No error? Get new bytes.
-					bytes = baos.toByteArray();
+        // Check to see if it's gzip-compressed
+        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
+        if ( bytes != null && bytes.length >= 4 ) {
 
-				} // end try
-				catch ( java.io.IOException e ) {
-					// Just return originally-decoded bytes
-				} // end catch
-				finally {
-					try {
-						baos.close();
-					} catch ( Exception e ) {
-					}
-					try {
-						gzis.close();
-					} catch ( Exception e ) {
-					}
-					try {
-						bais.close();
-					} catch ( Exception e ) {
-					}
-				} // end finally
+            int head = (bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);
+            if ( java.util.zip.GZIPInputStream.GZIP_MAGIC == head ) {
+                java.io.ByteArrayInputStream bais = null;
+                java.util.zip.GZIPInputStream gzis = null;
+                java.io.ByteArrayOutputStream baos = null;
+                byte[] buffer = new byte[2048];
+                int length = 0;
 
-			} // end if: gzipped
-		} // end if: bytes.length >= 2
+                try {
+                    baos = new java.io.ByteArrayOutputStream();
+                    bais = new java.io.ByteArrayInputStream( bytes );
+                    gzis = new java.util.zip.GZIPInputStream( bais );
 
-		return bytes;
-	} // end decode
+                    while ( (length = gzis.read( buffer )) >= 0 ) {
+                        baos.write( buffer, 0, length );
+                    } // end while: reading input
 
-	/**
-	 * Attempts to decode Base64 data and deserialize a Java
-	 * Object within. Returns <tt>null</tt> if there was an error.
-	 *
-	 * @param encodedObject The Base64 data to decode
-	 * @return The decoded and deserialized object
-	 * @since 1.5
-	 */
-	public static Object decodeToObject( String encodedObject )
-	{
-		// Decode and gunzip if necessary
-		byte[] objBytes = decode( encodedObject );
+                    // No error? Get new bytes.
+                    bytes = baos.toByteArray();
 
-		java.io.ByteArrayInputStream bais = null;
-		java.io.ObjectInputStream ois = null;
-		Object obj = null;
+                } // end try
+                catch ( java.io.IOException e ) {
+                    // Just return originally-decoded bytes
+                } // end catch
+                finally {
+                    try {
+                        baos.close();
+                    } catch ( Exception e ) {
+                    }
+                    try {
+                        gzis.close();
+                    } catch ( Exception e ) {
+                    }
+                    try {
+                        bais.close();
+                    } catch ( Exception e ) {
+                    }
+                } // end finally
 
-		try {
-			bais = new java.io.ByteArrayInputStream( objBytes );
-			ois = new java.io.ObjectInputStream( bais );
+            } // end if: gzipped
+        } // end if: bytes.length >= 2
 
-			obj = ois.readObject();
-		} // end try
-		catch ( java.io.IOException e ) {
-			Exceptions.logStackTrace( e );
-			obj = null;
-		} // end catch
-		catch ( java.lang.ClassNotFoundException e ) {
-			Exceptions.logStackTrace( e );
-			obj = null;
-		} // end catch
-		finally {
-			try {
-				bais.close();
-			} catch ( Exception e ) {
-			}
-			try {
-				ois.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+        return bytes;
+    } // end decode
 
-		return obj;
-	} // end decodeObject
+    /**
+     * Attempts to decode Base64 data and deserialize a Java Object within.
+     * Returns <tt>null</tt> if there was an error.
+     * 
+     * @param encodedObject
+     *            The Base64 data to decode
+     * @return The decoded and deserialized object
+     * @since 1.5
+     */
+    public static Object decodeToObject( String encodedObject )
+    {
+        // Decode and gunzip if necessary
+        byte[] objBytes = decode( encodedObject );
 
-	/**
-	 * Convenience method for encoding data to a file.
-	 *
-	 * @param dataToEncode byte array of data to encode in base64 form
-	 * @param filename Filename for saving encoded data
-	 * @return <tt>true</tt> if successful, <tt>false</tt> otherwise
-	 *
-	 * @since 2.1
-	 */
-	public static boolean encodeToFile( byte[] dataToEncode, String filename )
-	{
-		boolean success = false;
-		Base64.OutputStream bos = null;
-		try {
-			bos = new Base64.OutputStream( new java.io.FileOutputStream( filename ),
-					Base64.ENCODE );
-			bos.write( dataToEncode );
-			success = true;
-		} // end try
-		catch ( java.io.IOException e ) {
+        java.io.ByteArrayInputStream bais = null;
+        java.io.ObjectInputStream ois = null;
+        Object obj = null;
 
-			success = false;
-		} // end catch: IOException
-		finally {
-			try {
-				bos.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+        try {
+            bais = new java.io.ByteArrayInputStream( objBytes );
+            ois = new java.io.ObjectInputStream( bais );
 
-		return success;
-	} // end encodeToFile
+            obj = ois.readObject();
+        } // end try
+        catch ( java.io.IOException e ) {
+            Exceptions.logStackTrace( e );
+            obj = null;
+        } // end catch
+        catch ( java.lang.ClassNotFoundException e ) {
+            Exceptions.logStackTrace( e );
+            obj = null;
+        } // end catch
+        finally {
+            try {
+                bais.close();
+            } catch ( Exception e ) {
+            }
+            try {
+                ois.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-	/**
-	 * Convenience method for decoding data to a file.
-	 *
-	 * @param dataToDecode Base64-encoded data as a string
-	 * @param filename Filename for saving decoded data
-	 * @return <tt>true</tt> if successful, <tt>false</tt> otherwise
-	 *
-	 * @since 2.1
-	 */
-	public static boolean decodeToFile( String dataToDecode, String filename )
-	{
-		boolean success = false;
-		Base64.OutputStream bos = null;
-		try {
-			bos = new Base64.OutputStream( new java.io.FileOutputStream( filename ),
-					Base64.DECODE );
-			bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );
-			success = true;
-		} // end try
-		catch ( java.io.IOException e ) {
-			success = false;
-		} // end catch: IOException
-		finally {
-			try {
-				bos.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+        return obj;
+    } // end decodeObject
 
-		return success;
-	} // end decodeToFile
+    /**
+     * Convenience method for encoding data to a file.
+     * 
+     * @param dataToEncode
+     *            byte array of data to encode in base64 form
+     * @param filename
+     *            Filename for saving encoded data
+     * @return <tt>true</tt> if successful, <tt>false</tt> otherwise
+     * 
+     * @since 2.1
+     */
+    public static boolean encodeToFile( byte[] dataToEncode, String filename )
+    {
+        boolean success = false;
+        Base64.OutputStream bos = null;
+        try {
+            bos = new Base64.OutputStream( new java.io.FileOutputStream( filename ),
+                    Base64.ENCODE );
+            bos.write( dataToEncode );
+            success = true;
+        } // end try
+        catch ( java.io.IOException e ) {
 
-	/**
-	 * Convenience method for reading a base64-encoded
-	 * file and decoding it.
-	 *
-	 * @param filename Filename for reading encoded data
-	 * @return decoded byte array or null if unsuccessful
-	 *
-	 * @since 2.1
-	 */
-	public static byte[] decodeFromFile( String filename )
-	{
-		byte[] decodedData = null;
-		Base64.InputStream bis = null;
-		try {
-			// Set up some useful variables
-			java.io.File file = new java.io.File( filename );
-			byte[] buffer = null;
-			int length = 0;
-			int numBytes = 0;
+            success = false;
+        } // end catch: IOException
+        finally {
+            try {
+                bos.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-			// Check for size of file
-			if ( file.length() > Integer.MAX_VALUE ) {
-				System.err.println( "File is too big for this convenience method ("
-						+ file.length() + " bytes)." );
-				return null;
-			} // end if: file too big for int index
-			buffer = new byte[(int) file.length()];
+        return success;
+    } // end encodeToFile
 
-			// Open a stream
-			bis = new Base64.InputStream( new java.io.BufferedInputStream(
-					new java.io.FileInputStream( file ) ), Base64.DECODE );
+    /**
+     * Convenience method for decoding data to a file.
+     * 
+     * @param dataToDecode
+     *            Base64-encoded data as a string
+     * @param filename
+     *            Filename for saving decoded data
+     * @return <tt>true</tt> if successful, <tt>false</tt> otherwise
+     * 
+     * @since 2.1
+     */
+    public static boolean decodeToFile( String dataToDecode, String filename )
+    {
+        boolean success = false;
+        Base64.OutputStream bos = null;
+        try {
+            bos = new Base64.OutputStream( new java.io.FileOutputStream( filename ),
+                    Base64.DECODE );
+            bos.write( dataToDecode.getBytes( PREFERRED_ENCODING ) );
+            success = true;
+        } // end try
+        catch ( java.io.IOException e ) {
+            success = false;
+        } // end catch: IOException
+        finally {
+            try {
+                bos.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-			// Read until done
-			while ( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 )
-				length += numBytes;
+        return success;
+    } // end decodeToFile
 
-			// Save in a variable to return
-			decodedData = new byte[length];
-			System.arraycopy( buffer, 0, decodedData, 0, length );
+    /**
+     * Convenience method for reading a base64-encoded file and decoding it.
+     * 
+     * @param filename
+     *            Filename for reading encoded data
+     * @return decoded byte array or null if unsuccessful
+     * 
+     * @since 2.1
+     */
+    public static byte[] decodeFromFile( String filename )
+    {
+        byte[] decodedData = null;
+        Base64.InputStream bis = null;
+        try {
+            // Set up some useful variables
+            java.io.File file = new java.io.File( filename );
+            byte[] buffer = null;
+            int length = 0;
+            int numBytes = 0;
 
-		} // end try
-		catch ( java.io.IOException e ) {
-			System.err.println( "Error decoding from file " + filename );
-		} // end catch: IOException
-		finally {
-			try {
-				bis.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+            // Check for size of file
+            if ( file.length() > Integer.MAX_VALUE ) {
+                System.err.println( "File is too big for this convenience method ("
+                        + file.length() + " bytes)." );
+                return null;
+            } // end if: file too big for int index
+            buffer = new byte[(int) file.length()];
 
-		return decodedData;
-	} // end decodeFromFile
+            // Open a stream
+            bis = new Base64.InputStream( new java.io.BufferedInputStream(
+                    new java.io.FileInputStream( file ) ), Base64.DECODE );
 
-	/**
-	 * Convenience method for reading a binary file
-	 * and base64-encoding it.
-	 *
-	 * @param filename Filename for reading binary data
-	 * @return base64-encoded string or null if unsuccessful
-	 *
-	 * @since 2.1
-	 */
-	public static String encodeFromFile( String filename )
-	{
-		String encodedData = null;
-		Base64.InputStream bis = null;
-		try {
-			// Set up some useful variables
-			java.io.File file = new java.io.File( filename );
-			byte[] buffer = new byte[(int) ( file.length() * 1.4 )];
-			int length = 0;
-			int numBytes = 0;
+            // Read until done
+            while ( (numBytes = bis.read( buffer, length, 4096 )) >= 0 )
+                length += numBytes;
 
-			// Open a stream
-			bis = new Base64.InputStream( new java.io.BufferedInputStream(
-					new java.io.FileInputStream( file ) ), Base64.ENCODE );
+            // Save in a variable to return
+            decodedData = new byte[length];
+            System.arraycopy( buffer, 0, decodedData, 0, length );
 
-			// Read until done
-			while ( ( numBytes = bis.read( buffer, length, 4096 ) ) >= 0 )
-				length += numBytes;
+        } // end try
+        catch ( java.io.IOException e ) {
+            System.err.println( "Error decoding from file " + filename );
+        } // end catch: IOException
+        finally {
+            try {
+                bis.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-			// Save in a variable to return
-			encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );
+        return decodedData;
+    } // end decodeFromFile
 
-		} // end try
-		catch ( java.io.IOException e ) {
-			System.err.println( "Error encoding from file " + filename );
-		} // end catch: IOException
-		finally {
-			try {
-				bis.close();
-			} catch ( Exception e ) {
-			}
-		} // end finally
+    /**
+     * Convenience method for reading a binary file and base64-encoding it.
+     * 
+     * @param filename
+     *            Filename for reading binary data
+     * @return base64-encoded string or null if unsuccessful
+     * 
+     * @since 2.1
+     */
+    public static String encodeFromFile( String filename )
+    {
+        String encodedData = null;
+        Base64.InputStream bis = null;
+        try {
+            // Set up some useful variables
+            java.io.File file = new java.io.File( filename );
+            byte[] buffer = new byte[(int) (file.length() * 1.4)];
+            int length = 0;
+            int numBytes = 0;
 
-		return encodedData;
-	} // end encodeFromFile
+            // Open a stream
+            bis = new Base64.InputStream( new java.io.BufferedInputStream(
+                    new java.io.FileInputStream( file ) ), Base64.ENCODE );
 
-	/* ********  I N N E R   C L A S S   I N P U T S T R E A M  ******** */
+            // Read until done
+            while ( (numBytes = bis.read( buffer, length, 4096 )) >= 0 )
+                length += numBytes;
 
-	/**
-	 * A {@link Base64.InputStream} will read data from another
-	 * <tt>java.io.InputStream</tt>, given in the constructor,
-	 * and encode/decode to/from Base64 notation on the fly.
-	 *
-	 * @see Base64
-	 * @since 1.3
-	 */
-	public static class InputStream extends java.io.FilterInputStream
-	{
+            // Save in a variable to return
+            encodedData = new String( buffer, 0, length, Base64.PREFERRED_ENCODING );
 
-		private boolean encode; // Encoding or decoding
-		private int position; // Current position in the buffer
-		private byte[] buffer; // Small buffer holding converted data
-		private int bufferLength; // Length of buffer (3 or 4)
-		private int numSigBytes; // Number of meaningful bytes in the buffer
-		private int lineLength;
-		private boolean breakLines; // Break lines at less than 80 characters
+        } // end try
+        catch ( java.io.IOException e ) {
+            System.err.println( "Error encoding from file " + filename );
+        } // end catch: IOException
+        finally {
+            try {
+                bis.close();
+            } catch ( Exception e ) {
+            }
+        } // end finally
 
-		/**
-		 * Constructs a {@link Base64.InputStream} in DECODE mode.
-		 *
-		 * @param in the <tt>java.io.InputStream</tt> from which to read data.
-		 * @since 1.3
-		 */
-		public InputStream( java.io.InputStream in )
-		{
-			this( in, DECODE );
-		} // end constructor
+        return encodedData;
+    } // end encodeFromFile
 
-		/**
-		 * Constructs a {@link Base64.InputStream} in
-		 * either ENCODE or DECODE mode.
-		 * <p>
-		 * Valid options:<pre>
-		 *   ENCODE or DECODE: Encode or Decode as data is read.
-		 *   DONT_BREAK_LINES: don't break lines at 76 characters
-		 *     (only meaningful when encoding)
-		 *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-		 * </pre>
-		 * <p>
-		 * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>
-		 *
-		 *
-		 * @param in the <tt>java.io.InputStream</tt> from which to read data.
-		 * @param options Specified options
-		 * @see Base64#ENCODE
-		 * @see Base64#DECODE
-		 * @see Base64#DONT_BREAK_LINES
-		 * @since 2.0
-		 */
-		public InputStream( java.io.InputStream in, int options )
-		{
-			super( in );
-			this.breakLines = ( options & DONT_BREAK_LINES ) != DONT_BREAK_LINES;
-			this.encode = ( options & ENCODE ) == ENCODE;
-			this.bufferLength = encode ? 4 : 3;
-			this.buffer = new byte[bufferLength];
-			this.position = -1;
-			this.lineLength = 0;
-		} // end constructor
+    /* ******** I N N E R C L A S S I N P U T S T R E A M ******** */
 
-		/**
-		 * Reads enough of the input stream to convert
-		 * to/from Base64 and returns the next byte.
-		 *
-		 * @return next byte
-		 * @since 1.3
-		 */
-		public int read() throws java.io.IOException
-		{
-			// Do we need to get data?
-			if ( position < 0 ) {
-				if ( encode ) {
-					byte[] b3 = new byte[3];
-					int numBinaryBytes = 0;
-					for ( int i = 0; i < 3; i++ ) {
-						try {
-							int b = in.read();
+    /**
+     * A {@link Base64.InputStream} will read data from another
+     * <tt>java.io.InputStream</tt>, given in the constructor, and
+     * encode/decode to/from Base64 notation on the fly.
+     * 
+     * @see Base64
+     * @since 1.3
+     */
+    public static class InputStream extends java.io.FilterInputStream
+    {
 
-							// If end of stream, b is -1.
-							if ( b >= 0 ) {
-								b3[i] = (byte) b;
-								numBinaryBytes++;
-							} // end if: not end of stream
+        private boolean encode; // Encoding or decoding
 
-						} // end try: read
-						catch ( java.io.IOException e ) {
-							// Only a problem if we got no data at all.
-							if ( i == 0 )
-								throw e;
+        private int position; // Current position in the buffer
 
-						} // end catch
-					} // end for: each needed input byte
+        private byte[] buffer; // Small buffer holding converted data
 
-					if ( numBinaryBytes > 0 ) {
-						encode3to4( b3, 0, numBinaryBytes, buffer, 0 );
-						position = 0;
-						numSigBytes = 4;
-					} // end if: got data
-					else {
-						return -1;
-					} // end else
-				} // end if: encoding
+        private int bufferLength; // Length of buffer (3 or 4)
 
-				// Else decoding
-				else {
-					byte[] b4 = new byte[4];
-					int i = 0;
-					for ( i = 0; i < 4; i++ ) {
-						// Read four "meaningful" bytes:
-						int b = 0;
-						do {
-							b = in.read();
-						} while ( b >= 0 && DECODABET[b & 0x7f] <= WHITE_SPACE_ENC );
+        private int numSigBytes; // Number of meaningful bytes in the buffer
 
-						if ( b < 0 )
-							break; // Reads a -1 if end of stream
+        private int lineLength;
 
-						b4[i] = (byte) b;
-					} // end for: each needed input byte
+        private boolean breakLines; // Break lines at less than 80 characters
 
-					if ( i == 4 ) {
-						numSigBytes = decode4to3( b4, 0, buffer, 0 );
-						position = 0;
-					} // end if: got four characters
-					else
-						if ( i == 0 ) {
-							return -1;
-						} // end else if: also padded correctly
-						else {
-							// Must have broken out from above.
-							throw new java.io.IOException(
-									"Improperly padded Base64 input." );
-						} // end 
+        /**
+         * Constructs a {@link Base64.InputStream} in DECODE mode.
+         * 
+         * @param in
+         *            the <tt>java.io.InputStream</tt> from which to read
+         *            data.
+         * @since 1.3
+         */
+        public InputStream( java.io.InputStream in )
+        {
+            this( in, DECODE );
+        } // end constructor
 
-				} // end else: decode
-			} // end else: get data
+        /**
+         * Constructs a {@link Base64.InputStream} in either ENCODE or DECODE
+         * mode.
+         * <p>
+         * Valid options:
+         * 
+         * <pre>
+         *      ENCODE or DECODE: Encode or Decode as data is read.
+         *      DONT_BREAK_LINES: don't break lines at 76 characters
+         *        (only meaningful when encoding)
+         *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+         * </pre>
+         * 
+         * <p>
+         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>
+         * 
+         * 
+         * @param in
+         *            the <tt>java.io.InputStream</tt> from which to read
+         *            data.
+         * @param options
+         *            Specified options
+         * @see Base64#ENCODE
+         * @see Base64#DECODE
+         * @see Base64#DONT_BREAK_LINES
+         * @since 2.0
+         */
+        public InputStream( java.io.InputStream in, int options )
+        {
+            super( in );
+            this.breakLines = (options & DONT_BREAK_LINES) != DONT_BREAK_LINES;
+            this.encode = (options & ENCODE) == ENCODE;
+            this.bufferLength = encode ? 4 : 3;
+            this.buffer = new byte[bufferLength];
+            this.position = -1;
+            this.lineLength = 0;
+        } // end constructor
 
-			// Got data?
-			if ( position >= 0 ) {
-				// End of relevant data?
-				if ( /*!encode &&*/position >= numSigBytes )
-					return -1;
+        /**
+         * Reads enough of the input stream to convert to/from Base64 and
+         * returns the next byte.
+         * 
+         * @return next byte
+         * @since 1.3
+         */
+        @Override
+        public int read() throws java.io.IOException
+        {
+            // Do we need to get data?
+            if ( position < 0 ) {
+                if ( encode ) {
+                    byte[] b3 = new byte[3];
+                    int numBinaryBytes = 0;
+                    for ( int i = 0; i < 3; i++ ) {
+                        try {
+                            int b = in.read();
 
-				if ( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {
-					lineLength = 0;
-					return '\n';
-				} // end if
-				else {
-					lineLength++; // This isn't important when decoding
-					// but throwing an extra "if" seems
-					// just as wasteful.
+                            // If end of stream, b is -1.
+                            if ( b >= 0 ) {
+                                b3[i] = (byte) b;
+                                numBinaryBytes++;
+                            } // end if: not end of stream
 
-					int b = buffer[position++];
+                        } // end try: read
+                        catch ( java.io.IOException e ) {
+                            // Only a problem if we got no data at all.
+                            if ( i == 0 )
+                                throw e;
 
-					if ( position >= bufferLength )
-						position = -1;
+                        } // end catch
+                    } // end for: each needed input byte
 
-					return b & 0xFF; // This is how you "cast" a byte that's
-					// intended to be unsigned.
-				} // end else
-			} // end if: position >= 0
+                    if ( numBinaryBytes > 0 ) {
+                        encode3to4( b3, 0, numBinaryBytes, buffer, 0 );
+                        position = 0;
+                        numSigBytes = 4;
+                    } // end if: got data
+                    else {
+                        return -1;
+                    } // end else
+                } // end if: encoding
 
-			// Else error
-			else {
-				// When JDK1.4 is more accepted, use an assertion here.
-				throw new java.io.IOException( "Error in Base64 code reading stream." );
-			} // end else
-		} // end read
+                // Else decoding
+                else {
+                    byte[] b4 = new byte[4];
+                    int i = 0;
+                    for ( i = 0; i < 4; i++ ) {
+                        // Read four "meaningful" bytes:
+                        int b = 0;
+                        do {
+                            b = in.read();
+                        } while ( b >= 0 && DECODABET[b & 0x7f] <= WHITE_SPACE_ENC );
 
-		/**
-		 * Calls {@link #read()} repeatedly until the end of stream
-		 * is reached or <var>len</var> bytes are read.
-		 * Returns number of bytes read into array or -1 if
-		 * end of stream is encountered.
-		 *
-		 * @param dest array to hold values
-		 * @param off offset for array
-		 * @param len max number of bytes to read into array
-		 * @return bytes read into array or -1 if end of stream is encountered.
-		 * @since 1.3
-		 */
-		public int read( byte[] dest, int off, int len ) throws java.io.IOException
-		{
-			int i;
-			int b;
-			for ( i = 0; i < len; i++ ) {
-				b = read();
+                        if ( b < 0 )
+                            break; // Reads a -1 if end of stream
 
-				//if( b < 0 && i == 0 )
-				//    return -1;
+                        b4[i] = (byte) b;
+                    } // end for: each needed input byte
 
-				if ( b >= 0 )
-					dest[off + i] = (byte) b;
-				else
-					if ( i == 0 )
-						return -1;
-					else
-						break; // Out of 'for' loop
-			} // end for: each byte read
-			return i;
-		} // end read
+                    if ( i == 4 ) {
+                        numSigBytes = decode4to3( b4, 0, buffer, 0 );
+                        position = 0;
+                    } // end if: got four characters
+                    else if ( i == 0 ) {
+                        return -1;
+                    } // end else if: also padded correctly
+                    else {
+                        // Must have broken out from above.
+                        throw new java.io.IOException( "Improperly padded Base64 input." );
+                    } // end
 
-	} // end inner class InputStream
+                } // end else: decode
+            } // end else: get data
 
-	/* ********  I N N E R   C L A S S   O U T P U T S T R E A M  ******** */
+            // Got data?
+            if ( position >= 0 ) {
+                // End of relevant data?
+                if ( /* !encode && */position >= numSigBytes )
+                    return -1;
 
-	/**
-	 * A {@link Base64.OutputStream} will write data to another
-	 * <tt>java.io.OutputStream</tt>, given in the constructor,
-	 * and encode/decode to/from Base64 notation on the fly.
-	 *
-	 * @see Base64
-	 * @since 1.3
-	 */
-	public static class OutputStream extends java.io.FilterOutputStream
-	{
+                if ( encode && breakLines && lineLength >= MAX_LINE_LENGTH ) {
+                    lineLength = 0;
+                    return '\n';
+                }
 
-		private boolean encode;
-		private int position;
-		private byte[] buffer;
-		private int bufferLength;
-		private int lineLength;
-		private boolean breakLines;
-		private byte[] b4; // Scratch used in a few places
-		private boolean suspendEncoding;
+                lineLength++; // This isn't important when decoding
+                // but throwing an extra "if" seems
+                // just as wasteful.
 
-		/**
-		 * Constructs a {@link Base64.OutputStream} in ENCODE mode.
-		 *
-		 * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
-		 * @since 1.3
-		 */
-		public OutputStream( java.io.OutputStream out )
-		{
-			this( out, ENCODE );
-		} // end constructor
+                int b = buffer[position++];
 
-		/**
-		 * Constructs a {@link Base64.OutputStream} in
-		 * either ENCODE or DECODE mode.
-		 * <p>
-		 * Valid options:<pre>
-		 *   ENCODE or DECODE: Encode or Decode as data is read.
-		 *   DONT_BREAK_LINES: don't break lines at 76 characters
-		 *     (only meaningful when encoding)
-		 *     <i>Note: Technically, this makes your encoding non-compliant.</i>
-		 * </pre>
-		 * <p>
-		 * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>
-		 *
-		 * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
-		 * @param options Specified options.
-		 * @see Base64#ENCODE
-		 * @see Base64#DECODE
-		 * @see Base64#DONT_BREAK_LINES
-		 * @since 1.3
-		 */
-		public OutputStream( java.io.OutputStream out, int options )
-		{
-			super( out );
-			this.breakLines = ( options & DONT_BREAK_LINES ) != DONT_BREAK_LINES;
-			this.encode = ( options & ENCODE ) == ENCODE;
-			this.bufferLength = encode ? 3 : 4;
-			this.buffer = new byte[bufferLength];
-			this.position = 0;
-			this.lineLength = 0;
-			this.suspendEncoding = false;
-			this.b4 = new byte[4];
-		} // end constructor
+                if ( position >= bufferLength )
+                    position = -1;
 
-		/**
-		 * Writes the byte to the output stream after
-		 * converting to/from Base64 notation.
-		 * When encoding, bytes are buffered three
-		 * at a time before the output stream actually
-		 * gets a write() call.
-		 * When decoding, bytes are buffered four
-		 * at a time.
-		 *
-		 * @param theByte the byte to write
-		 * @since 1.3
-		 */
-		public void write( int theByte ) throws java.io.IOException
-		{
-			// Encoding suspended?
-			if ( suspendEncoding ) {
-				super.out.write( theByte );
-				return;
-			} // end if: supsended
+                return b & 0xFF; // This is how you "cast" a byte that's
+                // intended to be unsigned.
 
-			// Encode?
-			if ( encode ) {
-				buffer[position++] = (byte) theByte;
-				if ( position >= bufferLength ) // Enough to encode.
-				{
-					out.write( encode3to4( b4, buffer, bufferLength ) );
+            } // end if: position >= 0
 
-					lineLength += 4;
-					if ( breakLines && lineLength >= MAX_LINE_LENGTH ) {
-						out.write( NEW_LINE );
-						lineLength = 0;
-					} // end if: end of line
+            // Else error
 
-					position = 0;
-				} // end if: enough to output
-			} // end if: encoding
+            // When JDK1.4 is more accepted, use an assertion here.
+            throw new java.io.IOException( "Error in Base64 code reading stream." );
 
-			// Else, Decoding
-			else {
-				// Meaningful Base64 character?
-				if ( DECODABET[theByte & 0x7f] > WHITE_SPACE_ENC ) {
-					buffer[position++] = (byte) theByte;
-					if ( position >= bufferLength ) // Enough to output.
-					{
-						int len = Base64.decode4to3( buffer, 0, b4, 0 );
-						out.write( b4, 0, len );
-						//out.write( Base64.decode4to3( buffer ) );
-						position = 0;
-					} // end if: enough to output
-				} // end if: meaningful base64 character
-				else
-					if ( DECODABET[theByte & 0x7f] != WHITE_SPACE_ENC ) {
-						throw new java.io.IOException(
-								"Invalid character in Base64 data." );
-					} // end else: not white space either
-			} // end else: decoding
-		} // end write
+        } // end read
 
-		/**
-		 * Calls {@link #write(int)} repeatedly until <var>len</var> 
-		 * bytes are written.
-		 *
-		 * @param theBytes array from which to read bytes
-		 * @param off offset for array
-		 * @param len max number of bytes to read into array
-		 * @since 1.3
-		 */
-		public void write( byte[] theBytes, int off, int len ) throws java.io.IOException
-		{
-			// Encoding suspended?
-			if ( suspendEncoding ) {
-				super.out.write( theBytes, off, len );
-				return;
-			} // end if: supsended
+        /**
+         * Calls {@link #read()} repeatedly until the end of stream is reached
+         * or <var>len</var> bytes are read. Returns number of bytes read into
+         * array or -1 if end of stream is encountered.
+         * 
+         * @param dest
+         *            array to hold values
+         * @param off
+         *            offset for array
+         * @param len
+         *            max number of bytes to read into array
+         * @return bytes read into array or -1 if end of stream is encountered.
+         * @since 1.3
+         */
+        @Override
+        public int read( byte[] dest, int off, int len ) throws java.io.IOException
+        {
+            int i;
+            int b;
+            for ( i = 0; i < len; i++ ) {
+                b = read();
 
-			for ( int i = 0; i < len; i++ ) {
-				write( theBytes[off + i] );
-			} // end for: each byte written
+                // if( b < 0 && i == 0 )
+                // return -1;
 
-		} // end write
+                if ( b >= 0 )
+                    dest[off + i] = (byte) b;
+                else if ( i == 0 )
+                    return -1;
+                else
+                    break; // Out of 'for' loop
+            } // end for: each byte read
+            return i;
+        } // end read
 
-		/**
-		 * Method added by PHIL. [Thanks, PHIL. -Rob]
-		 * This pads the buffer without closing the stream.
-		 */
-		public void flushBase64() throws java.io.IOException
-		{
-			if ( position > 0 ) {
-				if ( encode ) {
-					out.write( encode3to4( b4, buffer, position ) );
-					position = 0;
-				} // end if: encoding
-				else {
-					throw new java.io.IOException( "Base64 input not properly padded." );
-				} // end else: decoding
-			} // end if: buffer partially full
+    } // end inner class InputStream
 
-		} // end flush
+    /* ******** I N N E R C L A S S O U T P U T S T R E A M ******** */
 
-		/** 
-		 * Flushes and closes (I think, in the superclass) the stream. 
-		 *
-		 * @since 1.3
-		 */
-		public void close() throws java.io.IOException
-		{
-			// 1. Ensure that pending characters are written
-			flushBase64();
+    /**
+     * A {@link Base64.OutputStream} will write data to another
+     * <tt>java.io.OutputStream</tt>, given in the constructor, and
+     * encode/decode to/from Base64 notation on the fly.
+     * 
+     * @see Base64
+     * @since 1.3
+     */
+    public static class OutputStream extends java.io.FilterOutputStream
+    {
 
-			// 2. Actually close the stream
-			// Base class both flushes and closes.
-			super.close();
+        private boolean encode;
 
-			buffer = null;
-			out = null;
-		} // end close
+        private int position;
 
-		/**
-		 * Suspends encoding of the stream.
-		 * May be helpful if you need to embed a piece of
-		 * base640-encoded data in a stream.
-		 *
-		 * @since 1.5.1
-		 */
-		public void suspendEncoding() throws java.io.IOException
-		{
-			flushBase64();
-			this.suspendEncoding = true;
-		} // end suspendEncoding
+        private byte[] buffer;
 
-		/**
-		 * Resumes encoding of the stream.
-		 * May be helpful if you need to embed a piece of
-		 * base640-encoded data in a stream.
-		 *
-		 * @since 1.5.1
-		 */
-		public void resumeEncoding()
-		{
-			this.suspendEncoding = false;
-		} // end resumeEncoding
+        private int bufferLength;
 
-	} // end inner class OutputStream
+        private int lineLength;
 
+        private boolean breakLines;
+
+        private byte[] b4; // Scratch used in a few places
+
+        private boolean suspendEncoding;
+
+        /**
+         * Constructs a {@link Base64.OutputStream} in ENCODE mode.
+         * 
+         * @param out
+         *            the <tt>java.io.OutputStream</tt> to which data will be
+         *            written.
+         * @since 1.3
+         */
+        public OutputStream( java.io.OutputStream out )
+        {
+            this( out, ENCODE );
+        } // end constructor
+
+        /**
+         * Constructs a {@link Base64.OutputStream} in either ENCODE or DECODE
+         * mode.
+         * <p>
+         * Valid options:
+         * 
+         * <pre>
+         *      ENCODE or DECODE: Encode or Decode as data is read.
+         *      DONT_BREAK_LINES: don't break lines at 76 characters
+         *        (only meaningful when encoding)
+         *        &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
+         * </pre>
+         * 
+         * <p>
+         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>
+         * 
+         * @param out
+         *            the <tt>java.io.OutputStream</tt> to which data will be
+         *            written.
+         * @param options
+         *            Specified options.
+         * @see Base64#ENCODE
+         * @see Base64#DECODE
+         * @see Base64#DONT_BREAK_LINES
+         * @since 1.3
+         */
+        public OutputStream( java.io.OutputStream out, int options )
+        {
+            super( out );
+            this.breakLines = (options & DONT_BREAK_LINES) != DONT_BREAK_LINES;
+            this.encode = (options & ENCODE) == ENCODE;
+            this.bufferLength = encode ? 3 : 4;
+            this.buffer = new byte[bufferLength];
+            this.position = 0;
+            this.lineLength = 0;
+            this.suspendEncoding = false;
+            this.b4 = new byte[4];
+        } // end constructor
+
+        /**
+         * Writes the byte to the output stream after converting to/from Base64
+         * notation. When encoding, bytes are buffered three at a time before
+         * the output stream actually gets a write() call. When decoding, bytes
+         * are buffered four at a time.
+         * 
+         * @param theByte
+         *            the byte to write
+         * @since 1.3
+         */
+        @Override
+        public void write( int theByte ) throws java.io.IOException
+        {
+            // Encoding suspended?
+            if ( suspendEncoding ) {
+                super.out.write( theByte );
+                return;
+            } // end if: supsended
+
+            // Encode?
+            if ( encode ) {
+                buffer[position++] = (byte) theByte;
+                if ( position >= bufferLength ) // Enough to encode.
+                {
+                    out.write( encode3to4( b4, buffer, bufferLength ) );
+
+                    lineLength += 4;
+                    if ( breakLines && lineLength >= MAX_LINE_LENGTH ) {
+                        out.write( NEW_LINE );
+                        lineLength = 0;
+                    } // end if: end of line
+
+                    position = 0;
+                } // end if: enough to output
+            } // end if: encoding
+
+            // Else, Decoding
+            else {
+                // Meaningful Base64 character?
+                if ( DECODABET[theByte & 0x7f] > WHITE_SPACE_ENC ) {
+                    buffer[position++] = (byte) theByte;
+                    if ( position >= bufferLength ) // Enough to output.
+                    {
+                        int len = Base64.decode4to3( buffer, 0, b4, 0 );
+                        out.write( b4, 0, len );
+                        // out.write( Base64.decode4to3( buffer ) );
+                        position = 0;
+                    } // end if: enough to output
+                } // end if: meaningful base64 character
+                else if ( DECODABET[theByte & 0x7f] != WHITE_SPACE_ENC ) {
+                    throw new java.io.IOException( "Invalid character in Base64 data." );
+                } // end else: not white space either
+            } // end else: decoding
+        } // end write
+
+        /**
+         * Calls {@link #write(int)} repeatedly until <var>len</var> bytes are
+         * written.
+         * 
+         * @param theBytes
+         *            array from which to read bytes
+         * @param off
+         *            offset for array
+         * @param len
+         *            max number of bytes to read into array
+         * @since 1.3
+         */
+        @Override
+        public void write( byte[] theBytes, int off, int len ) throws java.io.IOException
+        {
+            // Encoding suspended?
+            if ( suspendEncoding ) {
+                super.out.write( theBytes, off, len );
+                return;
+            } // end if: supsended
+
+            for ( int i = 0; i < len; i++ ) {
+                write( theBytes[off + i] );
+            } // end for: each byte written
+
+        } // end write
+
+        /**
+         * Method added by PHIL. [Thanks, PHIL. -Rob] This pads the buffer
+         * without closing the stream.
+         */
+        public void flushBase64() throws java.io.IOException
+        {
+            if ( position > 0 ) {
+                if ( encode ) {
+                    out.write( encode3to4( b4, buffer, position ) );
+                    position = 0;
+                } // end if: encoding
+                else {
+                    throw new java.io.IOException( "Base64 input not properly padded." );
+                } // end else: decoding
+            } // end if: buffer partially full
+
+        } // end flush
+
+        /**
+         * Flushes and closes (I think, in the superclass) the stream.
+         * 
+         * @since 1.3
+         */
+        @Override
+        public void close() throws java.io.IOException
+        {
+            // 1. Ensure that pending characters are written
+            flushBase64();
+
+            // 2. Actually close the stream
+            // Base class both flushes and closes.
+            super.close();
+
+            buffer = null;
+            out = null;
+        } // end close
+
+        /**
+         * Suspends encoding of the stream. May be helpful if you need to embed
+         * a piece of base640-encoded data in a stream.
+         * 
+         * @since 1.5.1
+         */
+        public void suspendEncoding() throws java.io.IOException
+        {
+            flushBase64();
+            this.suspendEncoding = true;
+        } // end suspendEncoding
+
+        /**
+         * Resumes encoding of the stream. May be helpful if you need to embed a
+         * piece of base640-encoded data in a stream.
+         * 
+         * @since 1.5.1
+         */
+        public void resumeEncoding()
+        {
+            this.suspendEncoding = false;
+        } // end resumeEncoding
+
+    } // end inner class OutputStream
+
 } // end class Base64

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/NetworkInterface.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/NetworkInterface.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/NetworkInterface.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -100,7 +100,7 @@
 				addresses.addAll( getAddresses( networkInterface ) );
 
 			} catch ( Exception e ) {
-				log.error( "Cannot register network interface: " + interfaceName, e );
+				log.error( "Cannot register network interface '{}': {} ", interfaceName, e );
 				return null;
 			}
 		} else {

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Npt.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Npt.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Npt.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -88,9 +88,10 @@
 		return npt;
 	}
 
-	public String toString()
+	@Override
+    public String toString()
 	{
-		StringBuilder s = new StringBuilder();
+		final StringBuilder s = new StringBuilder();
 		s.append( "npt=" );
 		if ( live )
 			s.append( "now-" );
@@ -99,7 +100,7 @@
 				s.append( "0-" );
 			else {
 				s.append( Double.toString( timeStart ) );
-				s.append( "-" );
+				s.append( '-' );
 			}
 
 			if ( timeEnd != 0.0 ) {

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/PortManager.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/PortManager.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/PortManager.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -33,140 +33,140 @@
 public class PortManager
 {
 
-	private static Logger log = LoggerFactory.getLogger( PortManager.class );
+    private static Logger log = LoggerFactory.getLogger( PortManager.class );
 
-	protected static final int minUdpPort = 6790;
-	protected static final int maxUdpPort = 49151;
-	private static Set<Integer> reservedPorts = Collections.synchronizedSet( new HashSet<Integer>() );
+    protected static final int minUdpPort = 6790;
 
-	// TODO: Using custom exceptions
-	public static void reservePort( int port ) throws Exception
-	{
-		if ( reservedPorts.contains( port ) )
-			throw new Exception( "Port " + port + "is reserved" );
+    protected static final int maxUdpPort = 49151;
 
-		reservedPorts.add( port );
-	}
+    private static Set<Integer> reservedPorts = Collections
+            .synchronizedSet( new HashSet<Integer>() );
 
-	public static void removePort( int port )
-	{
-		reservedPorts.remove( port );
-	}
+    // TODO: Using custom exceptions
+    public static void reservePort( int port ) throws Exception
+    {
+        if ( reservedPorts.contains( port ) )
+            throw new Exception( "Port " + port + "is reserved" );
 
-	/**
-	 * @param port
-	 *        To port to be tested
-	 * @return true if the port is already reserved, false if the port can be
-	 *         used.
-	 */
-	public static boolean isPortReserved( int port )
-	{
-		return reservedPorts.contains( port );
-	}
+        reservedPorts.add( port );
+    }
 
-	/**
-	 * Get the first port (starting from <i>start</i>) that does not appear in
-	 * the reservation list.
-	 * 
-	 * @param start
-	 *        the base port number to start from
-	 * @return the port number if found
-	 */
-	public static int getNextNotReservedPort( int start )
-			throws NoPortAvailableException
-	{
-		int port = start;
-		while ( reservedPorts.contains( port ) ) {
-			if ( port > maxUdpPort ) {
-				// port not found
-				throw new NoPortAvailableException();
-			}
-			port += 1;
-		}
-		return port;
-	}
+    public static void removePort( int port )
+    {
+        reservedPorts.remove( port );
+    }
 
-	public static int[] findAvailablePorts( int nPorts, int startFrom )
-		throws NoPortAvailableException
-	{
-		int dataPort, controlPort, startingPort;
+    /**
+     * @param port
+     *            To port to be tested
+     * @return true if the port is already reserved, false if the port can be
+     *         used.
+     */
+    public static boolean isPortReserved( int port )
+    {
+        return reservedPorts.contains( port );
+    }
 
-		startingPort = startFrom;
+    /**
+     * Get the first port (starting from <i>start</i>) that does not appear in
+     * the reservation list.
+     * 
+     * @param start
+     *            the base port number to start from
+     * @return the port number if found
+     */
+    public static int getNextNotReservedPort( int start ) throws NoPortAvailableException
+    {
+        int port = start;
+        while ( reservedPorts.contains( port ) ) {
+            if ( port > maxUdpPort ) {
+                // port not found
+                throw new NoPortAvailableException();
+            }
+            port += 1;
+        }
+        return port;
+    }
 
-		while ( true ) {
-			
-			startingPort = getNextNotReservedPort( startingPort );
-			dataPort = getNextPortAvailable( startingPort );
+    public static int[] findAvailablePorts( int nPorts, int startFrom )
+            throws NoPortAvailableException
+    {
+        int dataPort, controlPort, startingPort;
 
-			if ( isPortReserved( dataPort ) ) {
-				// The port is effectively unbound, but reserved in
-				// PortManager.
-				startingPort += nPorts;
-				continue;
-			}
+        startingPort = startFrom;
 
-			if ( nPorts == 1 ) {
-				// There is only the data port
-				int[] a = { dataPort };
-				log.debug( "DataPort: " + dataPort );
-				try {
-					reservePort( dataPort );
-				} catch ( Exception e ) {
-					continue;
-				}
-				return a;
+        while ( true ) {
 
-			} else if ( nPorts == 2 ) {
-				// We have to find 2 consequents free UDP ports.
-				// also: dataPort must be an even number
-				if ( ( dataPort % 2 ) != 0 ) {
-					continue;
+            startingPort = getNextNotReservedPort( startingPort );
+            dataPort = getNextPortAvailable( startingPort );
 
-				} else {
-					controlPort = getNextPortAvailable( dataPort + 1 );
+            if ( isPortReserved( dataPort ) ) {
+                // The port is effectively unbound, but reserved in
+                // PortManager.
+                startingPort += nPorts;
+                continue;
+            }
 
-					if ( controlPort != ( dataPort + 1 ) ) {
-						// port are not consequents
-						continue;
-					} else if ( isPortReserved( controlPort ) ) {
-						continue;
+            if ( nPorts == 1 ) {
+                // There is only the data port
+                int[] a = { dataPort };
+                log.debug( "DataPort: {}", dataPort );
+                try {
+                    reservePort( dataPort );
+                } catch ( Exception e ) {
+                    continue;
+                }
+                return a;
 
-					} else {
-						try {
-							reservePort( dataPort );
-							reservePort( controlPort );
-						} catch ( Exception e ) {
-							continue;
-						}
+            } else if ( nPorts == 2 ) {
+                // We have to find 2 consequents free UDP ports.
+                // also: dataPort must be an even number
+                if ( (dataPort % 2) != 0 ) {
+                    continue;
+                }
+                controlPort = getNextPortAvailable( dataPort + 1 );
 
-						int[] a = { dataPort, controlPort };
-						log.debug( "DataPort: " + dataPort + " - ControlPort: "
-								+ controlPort );
-						return a;
-					}
-				}
-			}
-		}
-	}
+                if ( controlPort != (dataPort + 1) ) {
+                    // port are not consequents
+                    continue;
+                } else if ( isPortReserved( controlPort ) ) {
+                    continue;
 
-	private static int getNextPortAvailable( int startPort )
-			throws NoPortAvailableException
-	{
+                } else {
+                    try {
+                        reservePort( dataPort );
+                        reservePort( controlPort );
+                    } catch ( Exception e ) {
+                        continue;
+                    }
 
-		for ( int port = startPort; port <= maxUdpPort; port++ ) {
-			DatagramSocket s = null;
-			try {
-				s = new DatagramSocket( port );
-				s.close();
-				return port;
+                    int[] a = { dataPort, controlPort };
+                    log.debug( "DataPort: {} - ControlPort: {}", dataPort, controlPort );
+                    return a;
+                }
 
-			} catch ( IOException e ) {
-				// Ignore
-			}
-		}
+            }
+        }
+    }
 
-		// No port is available
-		throw new NoPortAvailableException();
-	}
+    private static int getNextPortAvailable( int startPort )
+            throws NoPortAvailableException
+    {
 
+        for ( int port = startPort; port <= maxUdpPort; port++ ) {
+            DatagramSocket s = null;
+            try {
+                s = new DatagramSocket( port );
+                s.close();
+                return port;
+
+            } catch ( IOException e ) {
+                // Ignore
+            }
+        }
+
+        // No port is available
+        throw new NoPortAvailableException();
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -9,37 +9,41 @@
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  */
 public enum Side {
-	Any,     // filter is meant for any side
-	Client,  // select filters that are applied on the client-side session
-	Server;  // select filters that are applied on the server-side session
-	
-	public String toString() {
-		switch(this) {
-		case Any:
-			return "any";
-		case Client:
-			return "client";
-		case Server:
-			return "server";
-		default:
-			return "unknown";
-		}
-	}
-	
-	public static Side fromString(String value) throws IllegalArgumentException {
-		Side side;
-		
-		if(value == null || value.length() == 0)
-			side = Any;
-		else if(value.equalsIgnoreCase("server"))
-			side = Server;
-		else if(value.equalsIgnoreCase("client"))
-			side = Client;
-		else if(value.equalsIgnoreCase("any"))
-			side = Any;
-		else
-			throw new IllegalArgumentException("invalid side value given: " + value);
-		
-		return side;
-	}
-}
\ No newline at end of file
+    Any, // filter is meant for any side
+    Client, // select filters that are applied on the client-side session
+    Server; // select filters that are applied on the server-side session
+
+    @Override
+    public String toString()
+    {
+        switch ( this )
+        {
+        case Any:
+            return "any";
+        case Client:
+            return "client";
+        case Server:
+            return "server";
+        default:
+            return "unknown";
+        }
+    }
+
+    public static Side fromString( String value ) throws IllegalArgumentException
+    {
+        Side side;
+
+        if ( value == null || value.length() == 0 )
+            side = Any;
+        else if ( value.equalsIgnoreCase( "server" ) )
+            side = Server;
+        else if ( value.equalsIgnoreCase( "client" ) )
+            side = Client;
+        else if ( value.equalsIgnoreCase( "any" ) )
+            side = Any;
+        else
+            throw new IllegalArgumentException( "invalid side value given: " + value );
+
+        return side;
+    }
+}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Singleton.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Singleton.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Singleton.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -47,7 +47,8 @@
 		classMap.put( this.getClass(), this );
 	}
 
-	public void finalize()
+	@Override
+    public void finalize()
 	{
 		classMap.remove( this.getClass() );
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,6 +26,8 @@
  */
 public final class UnsignedInt extends UnsignedNumber {
 	static final long serialVersionUID = 1L;
+    
+    public static final UnsignedInt ZERO = new UnsignedInt( 0 );
 
 	private long value;
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,208 +26,227 @@
  * 
  * @author Matteo Merli
  */
-public final class UnsignedLong extends UnsignedNumber {
+public final class UnsignedLong extends UnsignedNumber
+{
 
-	private static final long serialVersionUID = 1L;
+    private static final long serialVersionUID = 1L;
 
-	private byte[] value = new byte[8];
+    private byte[] value = new byte[8];
 
-	public UnsignedLong(byte c) {
-		Arrays.fill(value, (byte) 0);
-		value[7] = c;
-	}
+    public UnsignedLong( byte c )
+    {
+        Arrays.fill( value, (byte) 0 );
+        value[7] = c;
+    }
 
-	public UnsignedLong(short c) {
-		Arrays.fill(value, (byte) 0);
-		value[6] = (byte) ((c >> 8) & 0xFF);
-		value[7] = (byte) (c & 0xFF);
-	}
+    public UnsignedLong( short c )
+    {
+        Arrays.fill( value, (byte) 0 );
+        value[6] = (byte) ((c >> 8) & 0xFF);
+        value[7] = (byte) (c & 0xFF);
+    }
 
-	public UnsignedLong(int c) {
-		Arrays.fill(value, (byte) 0);
-		value[4] = (byte) ((c >> 24) & 0xFF);
-		value[5] = (byte) ((c >> 16) & 0xFF);
-		value[6] = (byte) ((c >> 8) & 0xFF);
-		value[7] = (byte) (c & 0xFF);
-	}
+    public UnsignedLong( int c )
+    {
+        Arrays.fill( value, (byte) 0 );
+        value[4] = (byte) ((c >> 24) & 0xFF);
+        value[5] = (byte) ((c >> 16) & 0xFF);
+        value[6] = (byte) ((c >> 8) & 0xFF);
+        value[7] = (byte) (c & 0xFF);
+    }
 
-	public UnsignedLong(long c) {
-		value[0] = (byte) ((c >> 56) & 0xFF);
-		value[1] = (byte) ((c >> 48) & 0xFF);
-		value[2] = (byte) ((c >> 40) & 0xFF);
-		value[3] = (byte) ((c >> 32) & 0xFF);
-		value[4] = (byte) ((c >> 24) & 0xFF);
-		value[5] = (byte) ((c >> 16) & 0xFF);
-		value[6] = (byte) ((c >> 8) & 0xFF);
-		value[7] = (byte) (c & 0xFF);
-	}
+    public UnsignedLong( long c )
+    {
+        value[0] = (byte) ((c >> 56) & 0xFF);
+        value[1] = (byte) ((c >> 48) & 0xFF);
+        value[2] = (byte) ((c >> 40) & 0xFF);
+        value[3] = (byte) ((c >> 32) & 0xFF);
+        value[4] = (byte) ((c >> 24) & 0xFF);
+        value[5] = (byte) ((c >> 16) & 0xFF);
+        value[6] = (byte) ((c >> 8) & 0xFF);
+        value[7] = (byte) (c & 0xFF);
+    }
 
-	/**
-	 * Construct a new random UnsignedLong.
-	 * 
-	 * @param random
-	 *            a Random handler
-	 */
-	public UnsignedLong(Random random) {
-		random.nextBytes(value);
-	}
+    /**
+     * Construct a new random UnsignedLong.
+     * 
+     * @param random
+     *            a Random handler
+     */
+    public UnsignedLong( Random random )
+    {
+        random.nextBytes( value );
+    }
 
-	private UnsignedLong() {
-		Arrays.fill(value, (byte) 0);
-	}
+    private UnsignedLong()
+    {
+        Arrays.fill( value, (byte) 0 );
+    }
 
-	public static UnsignedLong fromBytes(byte[] c) {
-		return fromBytes(c, 0);
-	}
+    public static UnsignedLong fromBytes( byte[] c )
+    {
+        return fromBytes( c, 0 );
+    }
 
-	public static UnsignedLong fromBytes(byte[] c, int offset) {
-		UnsignedLong number = new UnsignedLong();
-		if ((c.length - offset) < 8)
-			throw new IllegalArgumentException(
-					"An UnsignedLong number is composed of 8 bytes.");
+    public static UnsignedLong fromBytes( byte[] c, int offset )
+    {
+        UnsignedLong number = new UnsignedLong();
+        if ( (c.length - offset) < 8 )
+            throw new IllegalArgumentException(
+                    "An UnsignedLong number is composed of 8 bytes." );
 
-		for (int i = 7; i >= 0; i--)
-			number.value[i] = c[offset + i];
-		return number;
-	}
+        for ( int i = 7; i >= 0; i-- )
+            number.value[i] = c[offset + i];
+        return number;
+    }
 
-	public static UnsignedLong fromString(String c) {
-		return fromString(c, 10);
-	}
+    public static UnsignedLong fromString( String c )
+    {
+        return fromString( c, 10 );
+    }
 
-	public static UnsignedLong fromString(String c, int radix) {
-		UnsignedLong number = new UnsignedLong();
+    public static UnsignedLong fromString( String c, int radix )
+    {
+        UnsignedLong number = new UnsignedLong();
 
-		BigInteger n = new BigInteger(c, radix);
-		byte[] bytes = n.toByteArray();
+        BigInteger n = new BigInteger( c, radix );
+        byte[] bytes = n.toByteArray();
 
-		int len = Math.min(8, bytes.length);
-		for (int i = 0; i < len; i++)
-			number.value[7 - i] = bytes[bytes.length - 1 - i];
-		return number;
-	}
+        int len = Math.min( 8, bytes.length );
+        for ( int i = 0; i < len; i++ )
+            number.value[7 - i] = bytes[bytes.length - 1 - i];
+        return number;
+    }
 
-	@Override
-	public byte[] getBytes() {
-		return value;
-	}
+    @Override
+    public byte[] getBytes()
+    {
+        return value;
+    }
 
-	@Override
-	public String toString() {
-		if ((byte) ((value[0] >> 7) & 0x01) == 1) {
-			value[0] = (byte) (value[0] & 0x7F);
-			BigInteger n = new BigInteger(value);
-			n = n.setBit(63);
-			value[0] = (byte) (value[0] | 0x80);
-			return n.toString();
-		} else {
-			BigInteger n = new BigInteger(value);
-			return n.toString();
-		}
-	}
+    @Override
+    public String toString()
+    {
+        if ( (byte) ((value[0] >> 7) & 0x01) == 1 ) {
+            value[0] = (byte) (value[0] & 0x7F);
+            BigInteger n = new BigInteger( value );
+            n = n.setBit( 63 );
+            value[0] = (byte) (value[0] | 0x80);
+            return n.toString();
+        }
+        
+        BigInteger n = new BigInteger( value );
+        return n.toString();
+    }
 
-	@Override
-	public int intValue() {
-		return (((int) value[4] << 24) & 0xFF000000 | ((int) value[5] << 16)
-				& 0xFF0000 | ((int) value[6] << 8) & 0xFF00 | ((int) value[7] & 0xFF));
-	}
+    @Override
+    public int intValue()
+    {
+        return (((int) value[4] << 24) & 0xFF000000 | ((int) value[5] << 16) & 0xFF0000
+                | ((int) value[6] << 8) & 0xFF00 | ((int) value[7] & 0xFF));
+    }
 
-	@Override
-	public long longValue() {
-		return (((long) value[0] << 56) & 0xFF00000000000000L
-				| ((long) value[1] << 48) & 0xFF000000000000L
-				| ((long) value[2] << 40) & 0xFF0000000000L
-				| ((long) value[3] << 32) & 0xFF00000000L
-				| ((long) value[4] << 24) & 0xFF000000L
-				| ((long) value[5] << 16) & 0xFF0000L | ((long) value[6] << 8)
-				& 0xFF00L | ((long) (value[7]) & 0xFFL));
-	}
+    @Override
+    public long longValue()
+    {
+        return (((long) value[0] << 56) & 0xFF00000000000000L | ((long) value[1] << 48)
+                & 0xFF000000000000L | ((long) value[2] << 40) & 0xFF0000000000L
+                | ((long) value[3] << 32) & 0xFF00000000L | ((long) value[4] << 24)
+                & 0xFF000000L | ((long) value[5] << 16) & 0xFF0000L
+                | ((long) value[6] << 8) & 0xFF00L | ((long) (value[7]) & 0xFFL));
+    }
 
-	@Override
-	public float floatValue() {
-		return (float) longValue();
-	}
+    @Override
+    public float floatValue()
+    {
+        return longValue();
+    }
 
-	@Override
-	public double doubleValue() {
-		return (double) longValue();
-	}
+    @Override
+    public double doubleValue()
+    {
+        return longValue();
+    }
 
-	@Override
-	public int compareTo(UnsignedNumber other) {
-		byte[] otherValue = other.getBytes();
-		if (otherValue.length > 8)
-			throw new IllegalArgumentException(
-					"The number is more than 8 bytes.");
+    @Override
+    public int compareTo( UnsignedNumber other )
+    {
+        byte[] otherValue = other.getBytes();
+        if ( otherValue.length > 8 )
+            throw new IllegalArgumentException( "The number is more than 8 bytes." );
 
-		byte[] normalValue = new byte[8];
-		Arrays.fill(normalValue, (byte) 0);
-		for (int i = 1; i <= otherValue.length; i++) {
-			normalValue[8 - i] = otherValue[otherValue.length - i];
-		}
+        byte[] normalValue = new byte[8];
+        Arrays.fill( normalValue, (byte) 0 );
+        for ( int i = 1; i <= otherValue.length; i++ ) {
+            normalValue[8 - i] = otherValue[otherValue.length - i];
+        }
 
-		for (int i = 0; i < 8; i++)
-			if ((char) value[i] > (char) normalValue[i])
-				return +1;
-			else if ((char) value[i] < (char) normalValue[i])
-				return -1;
-		return 0;
-	}
+        for ( int i = 0; i < 8; i++ )
+            if ( (char) value[i] > (char) normalValue[i] )
+                return +1;
+            else if ( (char) value[i] < (char) normalValue[i] )
+                return -1;
+        return 0;
+    }
 
-	@Override
-	public boolean equals(Object other) {
-		if (other instanceof UnsignedLong) {
-			// this is a special case
-			byte[] bytes = ((UnsignedLong) other).getBytes();
-			for (int i = 7; i >= 0; i--)
-				if (value[i] != bytes[i])
-					return false;
-			return true;
-		} else if (other instanceof Number)
-			return longValue() == ((Number) other).longValue();
-		else
-			return false;
-	}
-	
-	@Override
-	public int hashCode() {
-		int hashCode = 0;
+    @Override
+    public boolean equals( Object other )
+    {
+        if ( other instanceof UnsignedLong ) {
+            // this is a special case
+            byte[] bytes = ((UnsignedLong) other).getBytes();
+            for ( int i = 7; i >= 0; i-- )
+                if ( value[i] != bytes[i] )
+                    return false;
+            return true;
+        } else if ( other instanceof Number )
+            return longValue() == ((Number) other).longValue();
+        else
+            return false;
+    }
 
-		for (int i=0; i<value.length; i++)
-		    hashCode = (int)(31*hashCode + (value[i] & 0xFFFFFFFFL));
-		
-		return hashCode;
-	}
+    @Override
+    public int hashCode()
+    {
+        int hashCode = 0;
 
-	@Override
-	public void shiftRight(int nBits) {
-		if (nBits > 64 || nBits < 0)
-			throw new IllegalArgumentException("Cannot right shift " + nBits
-					+ " an UnsignedLong.");
-		if (nBits % 8 != 0)
-			throw new IllegalArgumentException("nBits must be a multiple of 8.");
+        for ( int i = 0; i < value.length; i++ )
+            hashCode = (int) (31 * hashCode + (value[i] & 0xFFFFFFFFL));
 
-		int nBytes = nBits / 8;
-		for (int i = 7; i >= nBytes; i--)
-			value[i] = value[i - nBytes];
-		for (int i = nBytes - 1; i >= 0; i--)
-			value[i] = 0;
-	}
+        return hashCode;
+    }
 
-	@Override
-	public void shiftLeft(int nBits) {
-		if (nBits > 64 || nBits < 0)
-			throw new IllegalArgumentException("Cannot left shift " + nBits
-					+ " an UnsignedLong.");
-		if (nBits % 8 != 0)
-			throw new IllegalArgumentException("nBits must be a multiple of 8.");
+    @Override
+    public void shiftRight( int nBits )
+    {
+        if ( nBits > 64 || nBits < 0 )
+            throw new IllegalArgumentException( "Cannot right shift " + nBits
+                    + " an UnsignedLong." );
+        if ( nBits % 8 != 0 )
+            throw new IllegalArgumentException( "nBits must be a multiple of 8." );
 
-		int nBytes = nBits / 8;
-		for (int i = 0; i <= 7 - nBytes; i++) {
-			value[i] = value[i + nBytes];
-		}
-		for (int i = 8 - nBytes; i < 8; i++) {
-			value[i] = 0;
-		}
-	}
+        int nBytes = nBits / 8;
+        for ( int i = 7; i >= nBytes; i-- )
+            value[i] = value[i - nBytes];
+        for ( int i = nBytes - 1; i >= 0; i-- )
+            value[i] = 0;
+    }
+
+    @Override
+    public void shiftLeft( int nBits )
+    {
+        if ( nBits > 64 || nBits < 0 )
+            throw new IllegalArgumentException( "Cannot left shift " + nBits
+                    + " an UnsignedLong." );
+        if ( nBits % 8 != 0 )
+            throw new IllegalArgumentException( "nBits must be a multiple of 8." );
+
+        int nBytes = nBits / 8;
+        for ( int i = 0; i <= 7 - nBytes; i++ ) {
+            value[i] = value[i + nBytes];
+        }
+        for ( int i = 8 - nBytes; i < 8; i++ ) {
+            value[i] = 0;
+        }
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -45,13 +45,16 @@
 	 */
 	public abstract void shiftLeft(int nBits);
 
-	public abstract String toString();
+	@Override
+    public abstract String toString();
 
 	public abstract int compareTo(UnsignedNumber other);
 
-	public abstract boolean equals(Object other);
+	@Override
+    public abstract boolean equals(Object other);
 	
-	public abstract int hashCode();
+	@Override
+    public abstract int hashCode();
 
 	public String toHexString() {
 		return toHexString(false);

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -74,12 +74,12 @@
 
 	@Override
 	public double doubleValue() {
-		return (double) value;
+		return value;
 	}
 
 	@Override
 	public float floatValue() {
-		return (float) value;
+		return value;
 	}
 
 	@Override
@@ -124,7 +124,7 @@
 	
 	@Override
 	public int hashCode() {
-		return (int)value;
+		return value;
 	}
 
 	@Override

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRdtPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRdtPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRdtPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -20,17 +20,14 @@
 
 import java.net.InetSocketAddress;
 
-import org.apache.mina.common.IoFilterChain;
 import org.apache.mina.common.IoHandlerAdapter;
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.TrafficMask;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.lib.Exceptions;
 import rtspproxy.proxy.track.RdtTrack;
 import rtspproxy.proxy.track.Track;
-import rtspproxy.rdt.RdtFilterChainBuilder;
 import rtspproxy.rdt.RdtPacket;
 
 /**
@@ -42,70 +39,67 @@
 public class ClientRdtPacketHandler extends IoHandlerAdapter
 {
 
-	private static Logger log = LoggerFactory.getLogger( ClientRdtPacketHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ClientRdtPacketHandler.class );
 
-	/**
-	 * this sessionCreated method is an ugly hack. It suspends the session for a moment and
-	 * checks the filter chain if the protocol filter has already been applied to the 
-	 * session. If not, it assembles the filter chain. This should have been done by the acceptor
-	 * (which he does not do (in mina 0.9.0))
-	 */
-	@Override
-	public void sessionCreated( IoSession session ) throws Exception
-	{
-		/*
-		log.debug("new client-side RDT session created");
+    /**
+     * this sessionCreated method is an ugly hack. It suspends the session for a
+     * moment and checks the filter chain if the protocol filter has already
+     * been applied to the session. If not, it assembles the filter chain. This
+     * should have been done by the acceptor (which he does not do (in mina
+     * 0.9.0))
+     */
+    @Override
+    public void sessionCreated( IoSession session ) throws Exception
+    {
+        /*
+         * log.debug("new client-side RDT session created");
+         * 
+         * TrafficMask mask = session.getTrafficMask();
+         * 
+         * try { session.setTrafficMask(TrafficMask.NONE);
+         * 
+         * IoFilterChain chain = session.getFilterChain();
+         * 
+         * if(!chain.contains(RdtFilterChainBuilder.rdtCODEC)) {
+         * log.debug("hot-patching filter chain"); (new
+         * RdtFilterChainBuilder()).buildFilterChain(chain); } } finally {
+         * session.setTrafficMask(mask); }
+         */
+    }
 
-		TrafficMask mask = session.getTrafficMask();
-		
-		try {
-			session.setTrafficMask(TrafficMask.NONE);
-			
-			IoFilterChain chain = session.getFilterChain();
-			
-			if(!chain.contains(RdtFilterChainBuilder.rdtCODEC)) {
-				log.debug("hot-patching filter chain");
-				(new RdtFilterChainBuilder()).buildFilterChain(chain);
-			}
-		} finally {
-			session.setTrafficMask(mask);
-		}
-		*/
-	}
+    @Override
+    public void messageReceived( IoSession session, Object buffer ) throws Exception
+    {
+        if ( buffer instanceof RdtPacket ) {
+            RdtPacket rdtPacket = (RdtPacket) buffer;
 
-	@Override
-	public void messageReceived( IoSession session, Object buffer ) throws Exception
-	{
-		if(buffer instanceof RdtPacket) {
-			RdtPacket rdtPacket = (RdtPacket)buffer;
-			
-			log.debug( "Received RDT packet from client, packet=" + rdtPacket );
+            log.debug( "Received RDT packet from client, packet={}", rdtPacket );
 
-			RdtTrack track = (RdtTrack) Track.getByClientAddress( (InetSocketAddress) session.getRemoteAddress() );
+            RdtTrack track = (RdtTrack) Track
+                    .getByClientAddress( (InetSocketAddress) session.getRemoteAddress() );
 
-			if ( track == null ) {
-				// drop packet
-				log.debug( "Invalid address: "
-						+ (InetSocketAddress) session.getRemoteAddress()
-						+ " - Class: "
-						+ ( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getClass() );
-				return;
-			}
+            if ( track == null ) {
+                // drop packet
+                log.debug( "Invalid address: {} - Class: {}", session.getRemoteAddress(),
+                        ((InetSocketAddress) session.getRemoteAddress()).getAddress()
+                                .getClass() );
+                return;
+            }
 
-			track.forwardRdtToServer( rdtPacket );			
-		} else {
-			log.debug("invalid object passed: " + buffer.getClass().getName());
-			
-			throw new IllegalStateException("invalid packet on chain");
-		}
-		
-	}
-	
-	@Override
-	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
-	{
-		log.info( "Exception: " + cause );
-		Exceptions.logStackTrace( cause );
-		session.close();
-	}
+            track.forwardRdtToServer( rdtPacket );
+        } else {
+            log.debug( "invalid object passed: {}", buffer.getClass().getName() );
+
+            throw new IllegalStateException( "invalid packet on chain" );
+        }
+
+    }
+
+    @Override
+    public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
+    {
+        log.info( "Exception: " + cause );
+        Exceptions.logStackTrace( cause );
+        session.close();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -32,46 +32,50 @@
 import rtspproxy.rtp.rtcp.RtcpPacket;
 
 /**
- * Handles RTCP packets from client and forward them to server. The RTSP 
- * session is obtained using the client IP address and port.
+ * Handles RTCP packets from client and forward them to server. The RTSP session
+ * is obtained using the client IP address and port.
  * 
  * @author Matteo Merli
  */
 public class ClientRtcpPacketHandler extends IoHandlerAdapter
 {
 
-	private static Logger log = LoggerFactory.getLogger( ClientRtcpPacketHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ClientRtcpPacketHandler.class );
 
-	@Override
-	public void sessionCreated( IoSession session ) throws Exception
-	{
-	}
+    @Override
+    public void sessionCreated( IoSession session ) throws Exception
+    {
+    }
 
-	@Override
-	public void messageReceived( IoSession session, Object buffer ) throws Exception
-	{
-		RtcpPacket packet = new RtcpPacket( (ByteBuffer) buffer );
-		// log.debug( "Received RTCP packet: " + packet.getType() );
+    @Override
+    public void messageReceived( IoSession session, Object buffer ) throws Exception
+    {
+        RtcpPacket packet = new RtcpPacket( (ByteBuffer) buffer );
+        // log.debug( "Received RTCP packet: {}", packet.getType() );
 
-		RtpTrack track = (RtpTrack)Track.getByClientAddress( (InetSocketAddress) session.getRemoteAddress() );
+        RtpTrack track = (RtpTrack) Track.getByClientAddress( (InetSocketAddress) session
+                .getRemoteAddress() );
 
-		if ( track == null ) {
-			// drop packet
-			log.debug( "Invalid address: "
-					+ (InetSocketAddress) session.getRemoteAddress()
-					+ " - Class: "
-					+ ( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getClass() );
-			return;
-		}
+        if ( track == null ) {
+            // drop packet
+            log.debug( "Invalid address: {} - Class: {}", session.getRemoteAddress(),
+                    ((InetSocketAddress) session.getRemoteAddress()).getAddress()
+                            .getClass() );
+            
+            log.debug( "Known Client Addresses: {}", Track.clientAddressMap.keySet() );
+            return;
+        }
 
-		track.forwardRtcpToServer( packet );
-	}
+        track.forwardRtcpToServer( packet );
+    }
 
-	@Override
-	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
-	{
-		log.debug( "Exception: " + cause );
-		Exceptions.logStackTrace( cause );
-		session.close();
-	}
+    @Override
+    public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
+    {
+        if ( log.isDebugEnabled() ) {
+            log.debug( "Exception: " + cause );
+            Exceptions.logStackTrace( cause );
+        }
+        session.close();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtpPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -52,13 +52,13 @@
 	public void messageReceived( IoSession session, Object buffer ) throws Exception
 	{
 		RtpPacket packet = new RtpPacket( (ByteBuffer) buffer );
-		log.debug( "Received RTP packet: " + packet.getSequence() );
+		log.debug( "Received RTP packet: {}", packet.getSequence() );
 
 		RtpTrack track = (RtpTrack)Track.getByClientAddress( (InetSocketAddress) session.getRemoteAddress() );
 
 		if ( track == null ) {
 			// drop packet
-			log.debug( "Packet received from unknown client: " + session.getRemoteAddress() ); 
+			log.debug( "Packet received from unknown client: {}", session.getRemoteAddress() ); 
 			return;
 		}
 
@@ -68,7 +68,7 @@
 	@Override
 	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
 	{
-		log.debug( "Exception: " + cause );
+		log.debug( "Exception: {}", cause );
 		Exceptions.logStackTrace( cause );
 		session.close();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientSide.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientSide.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientSide.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -41,7 +41,7 @@
 	@Override
 	public void sessionCreated( IoSession session ) throws Exception
 	{
-		log.info( "New connection from " + session.getRemoteAddress() );
+		log.info( "New connection from {}", session.getRemoteAddress() );
 		// Creates a new ProxyHandler and saves it
 		// as a Session attribute
 		ProxyHandler proxyHandler = new ProxyHandler( session );
@@ -68,7 +68,7 @@
 			return;
 		}
 		// close all: same as sessionClosed()
-		log.info( "Exception: " + cause );
+		log.info( "Exception: {}", cause );
 		Exceptions.logStackTrace( cause );
 		sessionClosed( session );
 	}
@@ -219,7 +219,7 @@
 	public void messageReceived( IoSession session, Object message )
 	{
 		RtspMessage rtspMessage = (RtspMessage) message;
-		log.debug( "Received message:\n" + message );
+		log.debug( "Received message:\n{}", message );
 
 		ProxyHandler proxyHandler = (ProxyHandler) ( session.getAttribute( ProxyHandler.ATTR ) );
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -26,13 +26,13 @@
 import java.net.UnknownHostException;
 import java.nio.channels.UnresolvedAddressException;
 import java.util.HashMap;
+import java.util.concurrent.ConcurrentHashMap;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.ConnectFuture;
 import org.apache.mina.common.IoSession;
 import org.apache.mina.transport.socket.nio.SocketConnector;
-import org.apache.mina.transport.socket.nio.SocketSession;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.RdtClientService;
 import rtspproxy.RdtServerService;
@@ -42,8 +42,6 @@
 import rtspproxy.RtpServerService;
 import rtspproxy.config.Config;
 import rtspproxy.filter.RtspServerFilters;
-import rtspproxy.lib.number.UnsignedInt;
-import rtspproxy.lib.number.UnsignedLong;
 import rtspproxy.proxy.track.RdtTrack;
 import rtspproxy.proxy.track.RtpTrack;
 import rtspproxy.rtp.range.PortrangeRtpServerSession;
@@ -58,558 +56,562 @@
 import rtspproxy.rtsp.RtspTransport.TransportProtocol;
 
 /**
- * @author mat
+ * @author Matteo Merli
  */
 public class ProxyHandler
 {
 
-	private static Logger log = LoggerFactory.getLogger( ProxyHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ProxyHandler.class );
 
-	/** Used to save a reference to this handler in the IoSession */
-	protected static final String ATTR = ProxyHandler.class.toString() + "Attr";
+    /** Used to save a reference to this handler in the IoSession */
+    protected static final String ATTR = ProxyHandler.class.toString() + "Attr";
 
-	protected static final String setupUrlATTR = ProxyHandler.class.toString()
-			+ "setupUrlATTR";
+    protected static final String setupUrlATTR = ProxyHandler.class.toString()
+            + "setupUrlATTR";
 
-	protected static final String clientPortsATTR = ProxyHandler.class.toString()
-			+ "clientPortsATTR";
+    protected static final String clientPortsATTR = ProxyHandler.class.toString()
+            + "clientPortsATTR";
 
-	protected static final String clientRdtPortATTR = ProxyHandler.class.toString()
-			+ "clientRdtPortATTR";
+    protected static final String clientRdtPortATTR = ProxyHandler.class.toString()
+            + "clientRdtPortATTR";
 
-	private IoSession clientSession = null;
+    private IoSession clientSession = null;
 
-	private IoSession serverSession = null;
+    private IoSession serverSession = null;
 
-	private HashMap<String, Object> sharedSessionObjects = new HashMap<String, Object>();
-	
-	/**
-	 * Creates a new ProxyHandler from a client side protocol session.
-	 * 
-	 * @param clientSession
-	 */
-	public ProxyHandler( IoSession clientSession )
-	{
-		this.clientSession = clientSession;
-		this.clientSession.setAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE, sharedSessionObjects);
-	}
+    private ConcurrentHashMap<String, Object> sharedSessionObjects = new ConcurrentHashMap<String, Object>();
 
-	public void passToServer( RtspMessage message )
-	{
-		log.debug( "Pass to server" );
-		if ( message.getHeader( "Session" ) != null ) {
-			ProxySession proxySession = ProxySession.getByClientSessionID( message
-					.getHeader( "Session" ) );
-			if ( proxySession != null ) {
-				// Session is Ok
-				message.setHeader( "Session", proxySession.getServerSessionId() );
-			} else {
-				// Error. The client specified a session ID but it's
-				// not valid
-				sendResponse( clientSession, RtspResponse
-						.errorResponse( RtspCode.SessionNotFound ) );
-				return;
-			}
-		}
-		if ( serverSession == null && message.getType() == RtspMessage.Type.TypeResponse ) {
-			log.error( "We can't send a response message to an uninitialized serverSide" );
-			return;
-		} else if ( serverSession == null ) {
-			RtspRequest request = (RtspRequest) message;
-			try {
-				connectServerSide( request.getUrl() );
+    /**
+     * Creates a new ProxyHandler from a client side protocol session.
+     * 
+     * @param clientSession
+     */
+    public ProxyHandler( IoSession clientSession )
+    {
+        this.clientSession = clientSession;
+        this.clientSession.setAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE,
+                sharedSessionObjects );
+    }
 
-			} catch ( IOException e ) {
-				log.error( "I/O exception", e );
-				// closeAll();
-			} finally {
-				if ( serverSession == null )
-					return;
-			}
-		}
+    public void passToServer( RtspMessage message )
+    {
+        log.debug( "Pass to server" );
+        if ( message.getHeader( "Session" ) != null ) {
+            ProxySession proxySession = ProxySession.getByClientSessionID( message
+                    .getHeader( "Session" ) );
+            if ( proxySession != null ) {
+                // Session is Ok
+                message.setHeader( "Session", proxySession.getServerSessionId() );
+            } else {
+                // Error. The client specified a session ID but it's
+                // not valid
+                sendResponse( clientSession, RtspResponse
+                        .errorResponse( RtspCode.SessionNotFound ) );
+                return;
+            }
+        }
+        if ( serverSession == null && message.getType() == RtspMessage.Type.TypeResponse ) {
+            log.error( "We can't send a response message to an uninitialized serverSide" );
+            return;
+        } else if ( serverSession == null ) {
+            RtspRequest request = (RtspRequest) message;
+            try {
+                connectServerSide( request.getUrl() );
 
-		switch ( message.getType() ) {
-		case TypeRequest:
-			serverSession.setAttribute( RtspMessage.lastRequestVerbATTR,
-					((RtspRequest) message).getVerb() );
-			sendRequest( serverSession, (RtspRequest) message );
-			break;
+            } catch ( IOException e ) {
+                log.error( "I/O exception", e );
+                // closeAll();
+            } finally {
+                if ( serverSession == null )
+                    return;
+            }
+        }
 
-		case TypeResponse:
-			sendResponse( serverSession, (RtspResponse) message );
-			break;
+        switch ( message.getType() )
+        {
+        case TypeRequest:
+            serverSession.setAttribute( RtspMessage.lastRequestVerbATTR,
+                    ((RtspRequest) message).getVerb() );
+            sendRequest( serverSession, (RtspRequest) message );
+            break;
 
-		default:
-			log.error( "Message type not valid: " + message.getType() );
-		}
-	}
+        case TypeResponse:
+            sendResponse( serverSession, (RtspResponse) message );
+            break;
 
-	public void passToClient( RtspMessage message )
-	{
-		log.debug( "Pass to client" );
-		if ( message.getHeader( "Session" ) != null ) {
-			ProxySession proxySession = ProxySession.getByServerSessionID( message
-					.getHeader( "Session" ) );
-			if ( proxySession != null ) {
-				// Session is Ok
-				message.setHeader( "Session", proxySession.getClientSessionId() );
-			} else {
-				if ( message.getType() == RtspMessage.Type.TypeResponse ) {
-					// create a proxy session on the fly if message is a
-					// response. Certain mobile handset clients
-					// tend to start a RSTP session without its own session id
-					// and wait for the session object from the
-					// remote server
-					proxySession = new ProxySession();
+        default:
+            log.error( "Message type not valid: " + message.getType() );
+        }
+    }
 
-					proxySession.setServerSessionId( message.getHeader( "Session" ) );
-					message.setHeader( "Session", proxySession.getClientSessionId() );
-					log.debug( "Created a new proxy session on-the-fly." );
-				} else {
-					// Error. The client specified a session ID but it's
-					// not valid
-					sendResponse( clientSession, RtspResponse
-							.errorResponse( RtspCode.SessionNotFound ) );
-					return;
-				}
-			}
-		}
+    public void passToClient( RtspMessage message )
+    {
+        log.debug( "Pass to client" );
+        if ( message.getHeader( "Session" ) != null ) {
+            ProxySession proxySession = ProxySession.getByServerSessionID( message
+                    .getHeader( "Session" ) );
+            if ( proxySession != null ) {
+                // Session is Ok
+                message.setHeader( "Session", proxySession.getClientSessionId() );
+            } else {
+                if ( message.getType() == RtspMessage.Type.TypeResponse ) {
+                    // create a proxy session on the fly if message is a
+                    // response. Certain mobile handset clients
+                    // tend to start a RSTP session without its own session id
+                    // and wait for the session object from the
+                    // remote server
+                    proxySession = new ProxySession();
 
-		switch ( message.getType() ) {
-		case TypeRequest:
-			clientSession.setAttribute( RtspMessage.lastRequestVerbATTR,
-					((RtspRequest) message).getVerb() );
-			sendRequest( clientSession, (RtspRequest) message );
-			break;
+                    proxySession.setServerSessionId( message.getHeader( "Session" ) );
+                    message.setHeader( "Session", proxySession.getClientSessionId() );
+                    log.debug( "Created a new proxy session on-the-fly." );
+                } else {
+                    // Error. The client specified a session ID but it's
+                    // not valid
+                    sendResponse( clientSession, RtspResponse
+                            .errorResponse( RtspCode.SessionNotFound ) );
+                    return;
+                }
+            }
+        }
 
-		case TypeResponse:
-			sendResponse( clientSession, (RtspResponse) message );
-			break;
+        switch ( message.getType() )
+        {
+        case TypeRequest:
+            clientSession.setAttribute( RtspMessage.lastRequestVerbATTR,
+                    ((RtspRequest) message).getVerb() );
+            sendRequest( clientSession, (RtspRequest) message );
+            break;
 
-		default:
-			log.error( "Message type not valid: " + message.getType() );
-		}
-	}
+        case TypeResponse:
+            sendResponse( clientSession, (RtspResponse) message );
+            break;
 
-	/**
-	 * A SETUP request should treated more carefully tha other RTSP requests.
-	 * The proxy will perform some hijacking on the communication between client
-	 * and server, such as modifying RTP/RTCP port.
-	 * 
-	 * @param request
-	 *            SETUP request message
-	 */
-	public void passSetupRequestToServer( RtspRequest request )
-	{
-		ProxySession proxySession = null;
-		PortrangeRtpServerSession portrangeRtpSession = null;
+        default:
+            log.error( "Message type not valid: " + message.getType() );
+        }
+    }
 
-		if ( request.getHeader( "Session" ) != null ) {
-			// The client already specified a session ID.
-			// Let's validate it
-			proxySession = ProxySession.getByClientSessionID( request
-					.getHeader( "Session" ) );
-			if ( proxySession != null ) {
-				// Session ID is ok
-				request.setHeader( "Session", proxySession.getServerSessionId() );
-			} else {
-				// Error. The client specified a session ID but it's
-				// not valid
-				log.debug( "Invalid sessionId: " + request.getHeader( "Session" ) );
-				sendResponse( clientSession, RtspResponse
-						.errorResponse( RtspCode.SessionNotFound ) );
-				return;
-			}
-		}
-		
-		if(serverSession == null) {
-			/**
-			 * A mobile handset client may start the RTSP dialogue directly with a 
-			 * SETUP request if it has discovered the streaming media characteristics
-			 * through any other mechanism.
-			 * --> Make sure a server-side session exists in this case.
-			 */
-			try {
-				connectServerSide( request.getUrl() );
-			} catch ( IOException e ) {
-				log.error( "I/O exception", e );
-				// closeAll();
-			} finally {
-				if ( serverSession == null )
-					return;
-			}
-		}
-		serverSession.setAttribute( RtspMessage.lastRequestVerbATTR, request.getVerb() );
+    /**
+     * A SETUP request should treated more carefully tha other RTSP requests.
+     * The proxy will perform some hijacking on the communication between client
+     * and server, such as modifying RTP/RTCP port.
+     * 
+     * @param request
+     *            SETUP request message
+     */
+    public void passSetupRequestToServer( RtspRequest request )
+    {
+        ProxySession proxySession = null;
+        PortrangeRtpServerSession portrangeRtpSession = null;
 
-		log.debug( "Client Transport:" + request.getHeader( "Transport" ) );
+        if ( request.getHeader( "Session" ) != null ) {
+            // The client already specified a session ID.
+            // Let's validate it
+            proxySession = ProxySession.getByClientSessionID( request
+                    .getHeader( "Session" ) );
+            if ( proxySession != null ) {
+                // Session ID is ok
+                request.setHeader( "Session", proxySession.getServerSessionId() );
+            } else {
+                // Error. The client specified a session ID but it's
+                // not valid
+                log.debug( "Invalid sessionId: {}", request.getHeader( "Session" ) );
+                sendResponse( clientSession, RtspResponse
+                        .errorResponse( RtspCode.SessionNotFound ) );
+                return;
+            }
+        }
 
-		RtspTransportList rtspTransportList = new RtspTransportList( request
-				.getHeader( "Transport" ) );
-		log.debug( "Parsed:" + rtspTransportList.toString() );
+        if ( serverSession == null ) {
+            /**
+             * A mobile handset client may start the RTSP dialogue directly with
+             * a SETUP request if it has discovered the streaming media
+             * characteristics through any other mechanism. --> Make sure a
+             * server-side session exists in this case.
+             */
+            try {
+                connectServerSide( request.getUrl() );
+            } catch ( IOException e ) {
+                log.error( "I/O exception", e );
+                // closeAll();
+            } finally {
+                if ( serverSession == null )
+                    return;
+            }
+        }
+        serverSession.setAttribute( RtspMessage.lastRequestVerbATTR, request.getVerb() );
 
-		if ( rtspTransportList.count() == 0 ) {
-			/**
-			 * If no one of the client specified transports is acceptable by the
-			 * proxy, direct reply with an unsupported transport error. Then the
-			 * client will have the chance to reformule the request with another
-			 * transports set.
-			 */
-			sendResponse( clientSession, RtspResponse
-					.errorResponse( RtspCode.UnsupportedTransport ) );
-			return;
-		}
+        log.debug( "Client Transport:{}", request.getHeader( "Transport" ) );
 
-		// I'm saving the client Transport header before modifying it,
-		// because I will need to know which port the client will
-		// use for RTP/RTCP connections.
-		clientSession.setAttribute( setupUrlATTR, request.getUrl().toString() );
+        RtspTransportList rtspTransportList = new RtspTransportList( request
+                .getHeader( "Transport" ) );
+        log.debug( "Parsed: {}", rtspTransportList );
 
-		for ( RtspTransport transport : rtspTransportList.getList() ) {
-			log.debug( "Transport:" + transport );
+        if ( rtspTransportList.count() == 0 ) {
+            /**
+             * If no one of the client specified transports is acceptable by the
+             * proxy, direct reply with an unsupported transport error. Then the
+             * client will have the chance to reformule the request with another
+             * transports set.
+             */
+            sendResponse( clientSession, RtspResponse
+                    .errorResponse( RtspCode.UnsupportedTransport ) );
+            return;
+        }
 
-			if ( transport.getLowerTransport() == LowerTransport.TCP ) {
-				log.debug( "Transport is TCP based." );
-			} else {
-				if ( transport.getTransportProtocol() == TransportProtocol.RTP ) {
+        // I'm saving the client Transport header before modifying it,
+        // because I will need to know which port the client will
+        // use for RTP/RTCP connections.
+        clientSession.setAttribute( setupUrlATTR, request.getUrl().toString() );
 
-					clientSession.setAttribute( clientPortsATTR, transport
-							.getClientPort() );
-					
-					int proxyRtpPort = RtpServerService.getInstance().getPort();
-					int proxyRtcpPort = RtcpServerService.getInstance().getPort();
-					
-					if(Config.proxyServerRtpMultiplePorts.getValue()) {
-						log.debug("using RTP port range");
-						
-						try {
-							portrangeRtpSession = PortrangeRtpServerSessionFactory.getInstance().getSession();
-							
-							proxyRtpPort = portrangeRtpSession.getRtpPort();
-							proxyRtcpPort = portrangeRtpSession.getRtcpPort();
-							
-							log.debug("setting local server RTP/RTCP ports to "	+ proxyRtpPort + "/" + proxyRtcpPort);
-						} catch(IOException ioe) {
-							log.info("failed to allocate local RTP/RTCP ports", ioe);
-							
-							sendResponse( clientSession, RtspResponse
-									.errorResponse( RtspCode.InternalServerError ) );
-							return;
-						}
-					}
-					transport.setClientPort( new int[] { proxyRtpPort, proxyRtcpPort } );
+        for ( RtspTransport transport : rtspTransportList.getList() ) {
+            log.debug( "Transport: {}", transport );
 
-					// offer a distinguished SSRC to the remote server
-					if(Config.proxyRtspOfferSsrcToServer.getValue()) {
-						String ssrc = ProxySession.newServerSessionID().toHexString();
-						log.debug("offering generated SSRC to remote server, ssrc=" + ssrc);
-						
-						transport.setSSRC(ssrc);
-					}
-					
-				} else if ( transport.getTransportProtocol() == TransportProtocol.RDT ) {
-					clientSession.setAttribute( clientRdtPortATTR, new Integer( transport
-							.getClientPort()[0] ) );
-					
-					int proxyRdtPort = RdtServerService.getInstance().getPort();
-					transport.setClientPort( proxyRdtPort );
-				}
-				log.debug( "Transport Rewritten: " + transport );
-			}
-		}
+            if ( transport.getLowerTransport() == LowerTransport.TCP ) {
+                log.debug( "Transport is TCP based." );
+            } else {
+                if ( transport.getTransportProtocol() == TransportProtocol.RTP ) {
 
-		if ( proxySession == null ) {
-			proxySession = new ProxySession();
-			clientSession.setAttribute( ProxySession.ATTR, proxySession );
-		}
-		if(portrangeRtpSession != null)
-			proxySession.setPortrangeRtpServerSession(portrangeRtpSession);
+                    clientSession.setAttribute( clientPortsATTR, transport
+                            .getClientPort() );
 
-		request.setHeader( "Transport", rtspTransportList.toString() );
+                    int proxyRtpPort = RtpServerService.getInstance().getPort();
+                    int proxyRtcpPort = RtcpServerService.getInstance().getPort();
 
-		log.debug( "Sending SETUP request: \n" + request );
+                    if ( Config.proxyServerRtpMultiplePorts.getValue() ) {
+                        log.debug( "using RTP port range" );
 
-		sendRequest( serverSession, request );
-	}
+                        try {
+                            portrangeRtpSession = PortrangeRtpServerSessionFactory
+                                    .getInstance().getSession();
 
-	/**
-	 * Forward a RTSP SETUP response message to client.
-	 * 
-	 * @param response
-	 *            Setup response message
-	 */
-	public void passSetupResponseToClient( RtspResponse response )
-	{
-		// If there isn't yet a proxySession, create a new one
-		ProxySession proxySession = ProxySession.getByServerSessionID( response
-				.getHeader( "Session" ) );
-		if ( proxySession == null ) {
-			proxySession = (ProxySession) clientSession.getAttribute( ProxySession.ATTR );
-			if ( proxySession == null ) {
-				proxySession = new ProxySession();
-				clientSession.setAttribute( ProxySession.ATTR, proxySession );
-			}
-		}
+                            proxyRtpPort = portrangeRtpSession.getRtpPort();
+                            proxyRtcpPort = portrangeRtpSession.getRtcpPort();
 
-		if ( proxySession.getServerSessionId() == null ) {
-			proxySession.setServerSessionId( response.getHeader( "Session" ) );
-		}
-		
-		// Modify transport parameters for the client.
-		RtspTransportList rtspTransportList = new RtspTransportList( response
-				.getHeader( "Transport" ) );
+                            log.debug( "setting local server RTP/RTCP ports to {}/{}",
+                                    proxyRtpPort, proxyRtcpPort );
+                        } catch ( IOException ioe ) {
+                            log.info( "failed to allocate local RTP/RTCP ports", ioe );
 
-		RtspTransport transport = rtspTransportList.getList().get( 0 );
-		log.debug( "Using Transport:" + transport );
+                            sendResponse( clientSession, RtspResponse
+                                    .errorResponse( RtspCode.InternalServerError ) );
+                            return;
+                        }
+                    }
+                    transport.setClientPort( new int[] { proxyRtpPort, proxyRtcpPort } );
 
-		if ( transport.getTransportProtocol() == TransportProtocol.RTP ) {
+                    // offer a distinguished SSRC to the remote server
+                    if ( Config.proxyRtspOfferSsrcToServer.getValue() ) {
+                        String ssrc = ProxySession.newServerSessionID().toHexString();
+                        log.debug( "offering generated SSRC to remote server, ssrc={}",
+                                ssrc );
 
-			// Create a new Track object
-			RtpTrack track = proxySession.addRtpTrack( (String) clientSession
-					.getAttribute( setupUrlATTR ), transport.getSSRC() );
+                        transport.setSSRC( ssrc );
+                    }
 
-			// Setting client and server info on the track
-			InetAddress serverAddress = null;
-			if ( transport.getSource() != null ) {
-				try {
-					serverAddress = InetAddress.getByName( transport.getSource() );
-				} catch ( UnknownHostException e ) {
-					log.warn( "Unknown host: " + transport.getSource() );
-				}
-			} else {
-				serverAddress = ((InetSocketAddress) serverSession.getRemoteAddress())
-						.getAddress();
-			}
-			int[] serverPorts = transport.getServerPort();
-			track.setServerAddress( serverAddress, serverPorts[0], serverPorts[1] );
+                } else if ( transport.getTransportProtocol() == TransportProtocol.RDT ) {
+                    clientSession.setAttribute( clientRdtPortATTR, new Integer( transport
+                            .getClientPort()[0] ) );
 
-			InetAddress clientAddress = null;
-			try {
-				clientAddress = Inet4Address
-						.getByName( ((InetSocketAddress) clientSession.getRemoteAddress())
-								.getHostName() );
-			} catch ( UnknownHostException e ) {
-				log.warn( "Unknown host: " + clientSession.getRemoteAddress() );
-			}
-			int clientPorts[] = (int[]) clientSession.getAttribute( clientPortsATTR );
-			track.setClientAddress( clientAddress, clientPorts[0], clientPorts[1] );
+                    int proxyRdtPort = RdtServerService.getInstance().getPort();
+                    transport.setClientPort( proxyRdtPort );
+                }
+                log.debug( "Transport Rewritten: {}", transport );
+            }
+        }
 
-			if ( transport.getLowerTransport() == RtspTransport.LowerTransport.TCP ) {
-				log.debug( "Transport is TCP based." );
-			} else {
-				transport.setSSRC( track.getProxySSRC().toHexString() );
-				int rtpPort = RtpClientService.getInstance().getPort();
-				int rtcpPort = RtcpClientService.getInstance().getPort();
-				transport.setServerPort( new int[] { rtpPort, rtcpPort } );
-				transport.setSource( RtpClientService.getInstance().getAddress().getHostAddress() );
+        if ( proxySession == null ) {
+            proxySession = new ProxySession();
+            clientSession.setAttribute( ProxySession.ATTR, proxySession );
+        }
+        if ( portrangeRtpSession != null )
+            proxySession.setPortrangeRtpServerSession( portrangeRtpSession );
 
-				// Obtaing client specified ports
-				int ports[] = (int[]) clientSession.getAttribute( clientPortsATTR );
-				transport.setClientPort( ports );
+        request.setHeader( "Transport", rtspTransportList.toString() );
 
-				log.debug( "Transport Rewritten: " + transport );
-			}
+        log.debug( "Sending SETUP request: \n{}", request );
 
-		} else if ( transport.getTransportProtocol() == TransportProtocol.RDT ) {
+        sendRequest( serverSession, request );
+    }
 
-			// Create a new Track object
-			RdtTrack track = proxySession.addRdtTrack( (String) clientSession
-					.getAttribute( setupUrlATTR ) );
-			// Setting client and server info on the track
-			InetAddress serverAddress = null;
-			if ( transport.getSource() != null ) {
-				try {
-					serverAddress = InetAddress.getByName( transport.getSource() );
-				} catch ( UnknownHostException e ) {
-					log.warn( "Unknown host: " + transport.getSource() );
-				}
-			} else {
-				serverAddress = ((InetSocketAddress) serverSession.getRemoteAddress())
-						.getAddress();
-			}
-			int[] serverPorts = transport.getServerPort();
-			track.setServerAddress( serverAddress, serverPorts[0] );
+    /**
+     * Forward a RTSP SETUP response message to client.
+     * 
+     * @param response
+     *            Setup response message
+     */
+    public void passSetupResponseToClient( RtspResponse response )
+    {
+        // If there isn't yet a proxySession, create a new one
+        ProxySession proxySession = ProxySession.getByServerSessionID( response
+                .getHeader( "Session" ) );
+        if ( proxySession == null ) {
+            proxySession = (ProxySession) clientSession.getAttribute( ProxySession.ATTR );
+            if ( proxySession == null ) {
+                proxySession = new ProxySession();
+                clientSession.setAttribute( ProxySession.ATTR, proxySession );
+            }
+        }
 
-			InetAddress clientAddress = null;
-			try {
-				clientAddress = Inet4Address
-						.getByName( ((InetSocketAddress) clientSession.getRemoteAddress())
-								.getHostName() );
-			} catch ( UnknownHostException e ) {
-				log.warn( "Unknown host: " + clientSession.getRemoteAddress() );
-			}
-			int clientRdtPort = ((Integer) clientSession.getAttribute( clientRdtPortATTR ))
-					.intValue();
-			track.setClientAddress( clientAddress, clientRdtPort );
+        if ( proxySession.getServerSessionId() == null ) {
+            proxySession.setServerSessionId( response.getHeader( "Session" ) );
+        }
 
-			if ( transport.getLowerTransport() == RtspTransport.LowerTransport.TCP ) {
-				log.debug( "Transport is TCP based." );
-			} else {
-				int rdtPort = RdtClientService.getInstance().getPort();
-				transport.setServerPort( rdtPort );
-				// transport.setSource( RdtClientService.getInstance().getAddress().getHostAddress() );
+        // Modify transport parameters for the client.
+        RtspTransportList rtspTransportList = new RtspTransportList( response
+                .getHeader( "Transport" ) );
 
-				// Obtaing client specified ports
-				int port = ((Integer) clientSession.getAttribute( clientRdtPortATTR ))
-						.intValue();
-				transport.setClientPort( port );
+        RtspTransport transport = rtspTransportList.getList().get( 0 );
+        log.debug( "Using Transport: {}", transport );
 
-				log.debug( "Transport Rewritten: " + transport );
-			}
+        if ( transport.getTransportProtocol() == TransportProtocol.RTP ) {
 
-		} else {
-			sendResponse( clientSession, RtspResponse
-					.errorResponse( RtspCode.UnsupportedTransport ) );
-			return;
-		}
+            // Create a new Track object
+            RtpTrack track = proxySession.addRtpTrack( (String) clientSession
+                    .getAttribute( setupUrlATTR ), transport.getSSRC() );
 
-		response.setHeader( "Session", proxySession.getClientSessionId() );
-		response.setHeader( "Transport", transport.toString() );
+            // Setting client and server info on the track
+            InetAddress serverAddress = null;
+            if ( transport.getSource() != null ) {
+                try {
+                    serverAddress = InetAddress.getByName( transport.getSource() );
+                } catch ( UnknownHostException e ) {
+                    log.warn( "Unknown host: " + transport.getSource() );
+                }
+            } else {
+                serverAddress = ((InetSocketAddress) serverSession.getRemoteAddress())
+                        .getAddress();
+            }
+            int[] serverPorts = transport.getServerPort();
+            track.setServerAddress( serverAddress, serverPorts[0], serverPorts[1] );
 
-		log.debug( "SENDING RESPONSE TO CLIENT:\n" + response );
+            InetAddress clientAddress = null;
+            try {
+                clientAddress = Inet4Address
+                        .getByName( ((InetSocketAddress) clientSession.getRemoteAddress())
+                                .getHostName() );
+            } catch ( UnknownHostException e ) {
+                log.warn( "Unknown host: " + clientSession.getRemoteAddress() );
+            }
+            int clientPorts[] = (int[]) clientSession.getAttribute( clientPortsATTR );
+            track.setClientAddress( clientAddress, clientPorts[0], clientPorts[1] );
 
-		sendResponse( clientSession, response );
-	}
+            if ( transport.getLowerTransport() == RtspTransport.LowerTransport.TCP ) {
+                log.debug( "Transport is TCP based." );
+            } else {
+                transport.setSSRC( track.getProxySSRC().toHexString() );
+                int rtpPort = RtpClientService.getInstance().getPort();
+                int rtcpPort = RtcpClientService.getInstance().getPort();
+                transport.setServerPort( new int[] { rtpPort, rtcpPort } );
+                transport.setSource( RtpClientService.getInstance().getAddress()
+                        .getHostAddress() );
 
-	/**
-	 * Tries to connect to remote RTSP server.
-	 * 
-	 * @param url
-	 *            the URI of the server
-	 * @throws IOException
-	 */
-	private void connectServerSide( URL url ) throws IOException
-	{
-		log.debug( "Server url: " + url );
-		String host = url.getHost();
-		int port = url.getPort();
-		if ( port == -1 )
-			port = url.getDefaultPort();
+                // Obtaing client specified ports
+                int ports[] = (int[]) clientSession.getAttribute( clientPortsATTR );
+                transport.setClientPort( ports );
 
-		// Create TCP/IP connector.
-		SocketConnector connector = new SocketConnector();
+                log.debug( "Transport Rewritten: {}", transport );
+            }
 
-		// Start communication.
-		log.debug( "Trying to connect to '" + host + "' " + port );
-		try {
+        } else if ( transport.getTransportProtocol() == TransportProtocol.RDT ) {
 
-			/*
-			 * TODO: Current implementation wait (future.join()) until the
-			 * connection with server is completed. This could block the thread
-			 * for a long time. Check how to do it in asyncronous way.
-			 */
-			ConnectFuture future = connector.connect(
-					new InetSocketAddress( host, port ), new ServerSide(),
-					new RtspServerFilters() );
-			future.join();
-			serverSession = future.getSession();
+            // Create a new Track object
+            RdtTrack track = proxySession.addRdtTrack( (String) clientSession
+                    .getAttribute( setupUrlATTR ) );
+            // Setting client and server info on the track
+            InetAddress serverAddress = null;
+            if ( transport.getSource() != null ) {
+                try {
+                    serverAddress = InetAddress.getByName( transport.getSource() );
+                } catch ( UnknownHostException e ) {
+                    log.warn( "Unknown host: " + transport.getSource() );
+                }
+            } else {
+                serverAddress = ((InetSocketAddress) serverSession.getRemoteAddress())
+                        .getAddress();
+            }
+            int[] serverPorts = transport.getServerPort();
+            track.setServerAddress( serverAddress, serverPorts[0] );
 
-			if(Config.proxyRtspKeepAlive.getValue())
-				((SocketSession)serverSession).setKeepAlive(true);
-		} catch ( UnresolvedAddressException e ) {
-			log.warn( "Destination unreachable: " + host + ":" + port );
-			sendResponse( clientSession, RtspResponse
-					.errorResponse( RtspCode.DestinationUnreachable ) );
-			clientSession.close();
-			return;
-		}
+            InetAddress clientAddress = null;
+            try {
+                clientAddress = Inet4Address
+                        .getByName( ((InetSocketAddress) clientSession.getRemoteAddress())
+                                .getHostName() );
+            } catch ( UnknownHostException e ) {
+                log.warn( "Unknown host: " + clientSession.getRemoteAddress() );
+            }
+            int clientRdtPort = ((Integer) clientSession.getAttribute( clientRdtPortATTR ))
+                    .intValue();
+            track.setClientAddress( clientAddress, clientRdtPort );
 
-		log.debug( "Connected!" );
+            if ( transport.getLowerTransport() == RtspTransport.LowerTransport.TCP ) {
+                log.debug( "Transport is TCP based." );
+            } else {
+                int rdtPort = RdtClientService.getInstance().getPort();
+                transport.setServerPort( rdtPort );
+                // transport.setSource(
+                // RdtClientService.getInstance().getAddress().getHostAddress()
+                // );
 
-		// Save current ProxyHandler into the ProtocolSession
-		serverSession.setAttribute( ProxyHandler.ATTR, this );
+                // Obtaing client specified ports
+                int port = ((Integer) clientSession.getAttribute( clientRdtPortATTR ))
+                        .intValue();
+                transport.setClientPort( port );
 
-		serverSession.setAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE, sharedSessionObjects);
-		
-		log.debug( "Server session: " + serverSession.getAttributeKeys() );
-	}
+                log.debug( "Transport Rewritten: {}", transport );
+            }
 
-	/**
-	 * set an object in the shared objects map
-	 */
-	public static void setSharedSessionAttribute(IoSession session, String name, Object value) {
-		HashMap<String, Object> map = (HashMap<String, Object>)session.getAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE);
-		
-		synchronized (map) {
-			map.put(name, value);
-		}
-	}
-	
-	public static Object getSharedSessionAttribute(IoSession session, String name) {
-		Object v = null;
-		HashMap<String, Object> map = (HashMap<String, Object>)session.getAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE);
-		
-		synchronized (map) {
-			v = map.get(name);
-		}
-		
-		return v;
-	}
-	
-	public static final boolean containsSharedSessionAttribute(IoSession session, String name) {
-		boolean v = false;
-		HashMap<String, Object> map = (HashMap<String, Object>)session.getAttribute(ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE);
-		
-		synchronized (map) {
-			v = map.containsKey(name);
-		}
-		
-		return v;
-		
-	}
-	
-	/**
-	 * Closes both sides of communication.
-	 */
-	public synchronized void closeAll()
-	{
-		if ( clientSession != null && clientSession.isConnected() )
-			clientSession.close();
-		if ( serverSession != null && serverSession.isConnected() )
-			serverSession.close();
+        } else {
+            sendResponse( clientSession, RtspResponse
+                    .errorResponse( RtspCode.UnsupportedTransport ) );
+            return;
+        }
 
-		// Remove ProxySession and Track instances
-		if ( clientSession != null ) {
-			ProxySession proxySession = (ProxySession) clientSession
-					.getAttribute( ProxySession.ATTR );
-			if ( proxySession != null )
-				proxySession.close();
-		}
-	}
+        response.setHeader( "Session", proxySession.getClientSessionId() );
+        response.setHeader( "Transport", transport.toString() );
 
-	/**
-	 * Sends an RTSP request message
-	 * 
-	 * @param session
-	 *            current IoSession
-	 * @param request
-	 *            the message
-	 */
-	private void sendRequest( IoSession session, RtspRequest request )
-	{
-		request.setCommonHeaders();
-		try {
-			session.write( request );
-		} catch ( Exception e ) {
-			log.error( "exception sending request", e.getCause() );
-		}
-	}
+        log.debug( "SENDING RESPONSE TO CLIENT:\n{}", response );
 
-	/**
-	 * Sends an RTSP response message
-	 * 
-	 * @param session
-	 *            current IoSession
-	 * @param response
-	 *            the message
-	 */
-	private void sendResponse( IoSession session, RtspResponse response )
-	{
-		response.setCommonHeaders();
-		try {
-			session.write( response );
-		} catch ( Exception e ) {
-			log.error( "exception sending response", e.getCause() );
-		}
-	}
+        sendResponse( clientSession, response );
+    }
 
+    /**
+     * Tries to connect to remote RTSP server.
+     * 
+     * @param url
+     *            the URI of the server
+     * @throws IOException
+     */
+    private void connectServerSide( URL url ) throws IOException
+    {
+        log.debug( "Server url: {}", url );
+        String host = url.getHost();
+        int port = url.getPort();
+        if ( port == -1 )
+            port = url.getDefaultPort();
+
+        // Create TCP/IP connector.
+        SocketConnector connector = new SocketConnector();
+        connector.setFilterChainBuilder( new RtspServerFilters() );
+
+        // Start communication.
+        log.debug( "Trying to connect to '{}' {}", host, port );
+        try {
+
+            /*
+             * TODO: Current implementation wait (future.join()) until the
+             * connection with server is completed. This could block the thread
+             * for a long time. Check how to do it in asyncronous way.
+             */
+            ConnectFuture future = connector.connect(
+                    new InetSocketAddress( host, port ), new ServerSide() );
+            future.join();
+            serverSession = future.getSession();
+
+            // TODO: Rtsp Keep Alive
+            // if (Config.proxyRtspKeepAlive.getValue())
+            // ((SocketSession) serverSession).setKeepAlive(true);
+        } catch ( UnresolvedAddressException e ) {
+            log.warn( "Destination unreachable: " + host + ":" + port );
+            sendResponse( clientSession, RtspResponse
+                    .errorResponse( RtspCode.DestinationUnreachable ) );
+            clientSession.close();
+            return;
+        }
+
+        log.debug( "Connected!" );
+
+        // Save current ProxyHandler into the ProtocolSession
+        serverSession.setAttribute( ProxyHandler.ATTR, this );
+
+        serverSession.setAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE,
+                sharedSessionObjects );
+
+        log.debug( "Server session: {}", serverSession.getAttributeKeys() );
+    }
+
+    /**
+     * set an object in the shared objects map
+     */
+    public static void setSharedSessionAttribute( IoSession session, String name,
+            Object value )
+    {
+        ConcurrentHashMap map = (ConcurrentHashMap) session
+                .getAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE );
+
+        map.put( name, value );
+    }
+
+    public static Object getSharedSessionAttribute( IoSession session, String name )
+    {
+        ConcurrentHashMap map = (ConcurrentHashMap) session
+                .getAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE );
+        return map.get( name );
+    }
+
+    public static final boolean containsSharedSessionAttribute( IoSession session,
+            String name )
+    {
+        HashMap map = (HashMap) session
+                .getAttribute( ProxyConstants.RSTP_SHARED_SESSION_ATTRIBUTE );
+        return map.containsKey( name );
+    }
+
+    /**
+     * Closes both sides of communication.
+     */
+    public synchronized void closeAll()
+    {
+        if ( clientSession != null && clientSession.isConnected() )
+            clientSession.close();
+        if ( serverSession != null && serverSession.isConnected() )
+            serverSession.close();
+
+        // Remove ProxySession and Track instances
+        if ( clientSession != null ) {
+            ProxySession proxySession = (ProxySession) clientSession
+                    .getAttribute( ProxySession.ATTR );
+            if ( proxySession != null )
+                proxySession.close();
+        }
+    }
+
+    /**
+     * Sends an RTSP request message
+     * 
+     * @param session
+     *            current IoSession
+     * @param request
+     *            the message
+     */
+    private void sendRequest( IoSession session, RtspRequest request )
+    {
+        request.setCommonHeaders();
+        try {
+            session.write( request );
+        } catch ( Exception e ) {
+            log.error( "exception sending request", e.getCause() );
+        }
+    }
+
+    /**
+     * Sends an RTSP response message
+     * 
+     * @param session
+     *            current IoSession
+     * @param response
+     *            the message
+     */
+    private void sendResponse( IoSession session, RtspResponse response )
+    {
+        response.setCommonHeaders();
+        try {
+            session.write( response );
+        } catch ( Exception e ) {
+            log.error( "exception sending response", e.getCause() );
+        }
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxySession.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxySession.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxySession.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -44,296 +44,305 @@
 public class ProxySession
 {
 
-	private static Logger log = LoggerFactory.getLogger( ProxySession.class );
+    private static Logger log = LoggerFactory.getLogger( ProxySession.class );
 
-	protected static final String ATTR = ProxySession.class.toString() + "Attr";
+    protected static final String ATTR = ProxySession.class.toString() + "Attr";
 
-	/** Map IDs for RTSP session with servers to ProxySession objects. */
-	private static Map<String, ProxySession> serverSessionIds = new ConcurrentHashMap<String, ProxySession>();
+    /** Map IDs for RTSP session with servers to ProxySession objects. */
+    private static Map<String, ProxySession> serverSessionIds = new ConcurrentHashMap<String, ProxySession>();
 
-	/** Map IDs for RTSP session with clients to ProxySession objects. */
-	private static Map<String, ProxySession> clientSessionIds = new ConcurrentHashMap<String, ProxySession>();
+    /** Map IDs for RTSP session with clients to ProxySession objects. */
+    private static Map<String, ProxySession> clientSessionIds = new ConcurrentHashMap<String, ProxySession>();
 
-	/**
-	 * Retrieve the ProxySession associated with the given session ID used by
-	 * the client.
-	 * 
-	 * @param clientSessionId
-	 *        a string containing the RTSP session ID
-	 * @return the associated ProxySession or null if not found
-	 */
-	public static ProxySession getByClientSessionID( String clientSessionId )
-	{
-		if ( clientSessionId == null )
-			return null;
-		else
-			return clientSessionIds.get( clientSessionId );
-	}
+    /**
+     * Retrieve the ProxySession associated with the given session ID used by
+     * the client.
+     * 
+     * @param clientSessionId
+     *            a string containing the RTSP session ID
+     * @return the associated ProxySession or null if not found
+     */
+    public static ProxySession getByClientSessionID( String clientSessionId )
+    {
+        if ( clientSessionId == null )
+            return null;
 
-	/**
-	 * Retrieve the ProxySession associated with the given session ID used by
-	 * the server.
-	 * 
-	 * @param serverSessionId
-	 *        a string containing the RTSP session ID
-	 * @return the associated ProxySession or null if not found
-	 */
-	public static ProxySession getByServerSessionID( String serverSessionId )
-	{
-		if ( serverSessionId == null )
-			return null;
-		else
-			return serverSessionIds.get( serverSessionId );
-	}
+        return clientSessionIds.get( clientSessionId );
+    }
 
-	/**
-	 * This is the session ID generated by the proxy and used for the
-	 * communication with the client.
-	 */
-	private String clientSessionId = null;
+    /**
+     * Retrieve the ProxySession associated with the given session ID used by
+     * the server.
+     * 
+     * @param serverSessionId
+     *            a string containing the RTSP session ID
+     * @return the associated ProxySession or null if not found
+     */
+    public static ProxySession getByServerSessionID( String serverSessionId )
+    {
+        if ( serverSessionId == null )
+            return null;
 
-	/**
-	 * This is the session ID assigned by the server. RTSP messages with the
-	 * server must use this ID.
-	 */
-	private String serverSessionId = null;
+        return serverSessionIds.get( serverSessionId );
+    }
 
-	/** Tells whether the proxySession has already been closed. */
-	private boolean closedFlag = false;
+    /**
+     * This is the session ID generated by the proxy and used for the
+     * communication with the client.
+     */
+    private String clientSessionId = null;
 
-	/**
-	 * Collection of Track associated with this ProxySession.
-	 */
-	private Map<String, Track> trackList = new ConcurrentHashMap<String, Track>();
+    /**
+     * This is the session ID assigned by the server. RTSP messages with the
+     * server must use this ID.
+     */
+    private String serverSessionId = null;
 
-	/**
-	 * object name of proxy session
-	 */
-	private ObjectName objectName;
+    /** Tells whether the proxySession has already been closed. */
+    private boolean closedFlag = false;
 
-	/**
-	 * the special server-side session which handles RTP sessions with different local source ports
-	 */
-	private PortrangeRtpServerSession portrangeRtpServerSession;
+    /**
+     * Collection of Track associated with this ProxySession.
+     */
+    private Map<String, Track> trackList = new ConcurrentHashMap<String, Track>();
 
-	/**
-	 * @return Returns the objectName.
-	 */
-	public ObjectName getObjectName() {
-		return objectName;
-	}
+    /**
+     * object name of proxy session
+     */
+    private ObjectName objectName;
 
-	/**
-	 * @param objectName The objectName to set.
-	 */
-	public void setObjectName(ObjectName objectName) {
-		this.objectName = objectName;
-	}
+    /**
+     * the special server-side session which handles RTP sessions with different
+     * local source ports
+     */
+    private PortrangeRtpServerSession portrangeRtpServerSession;
 
-	/**
-	 * Construct a new ProxySession. The session ID that will be used when
-	 * communicating with the client will be generated.
-	 */
-	public ProxySession()
-	{
-		setClientSessionId( newSessionID() );
-		log.debug( "\n----------\nCreated new proxy session: " + clientSessionId
-				+ " \n----------" );
-	}
+    /**
+     * @return Returns the objectName.
+     */
+    public ObjectName getObjectName()
+    {
+        return objectName;
+    }
 
-	/**
-	 * Adds a new Track associated with this ProxySession.
-	 * 
-	 * @param url
-	 *        The URL used as a control reference for the Track
-	 * @param serverSsrc
-	 *        the SSRC id given by the server or null if not provided
-	 * @return a reference to the newly created Track
-	 */
-	public synchronized RtpTrack addRtpTrack( String url, String serverSsrc )
-	{
-		RtpTrack track = new RtpTrack( url );
-		if ( serverSsrc != null )
-			track.setServerSSRC( serverSsrc );
-		if(portrangeRtpServerSession != null)
-			track.setPortrangeRtpServerSession(this.portrangeRtpServerSession);
-		
-		trackList.put( url, track );
-		log.debug( "ProxySession: " + clientSessionId + " Added track. TrackList: "
-				+ trackList );
-		return track;
-	}
-	
-	/**
-	 * Adds a new Track associated with this ProxySession.
-	 * 
-	 * @param url
-	 *        The URL used as a control reference for the Track
-	 * @param serverSsrc
-	 *        the SSRC id given by the server or null if not provided
-	 * @return a reference to the newly created Track
-	 */
-	public synchronized RdtTrack addRdtTrack( String url )
-	{
-		RdtTrack track = new RdtTrack( url );
-		trackList.put( url, track );
-		log.debug( "ProxySession: " + clientSessionId + " Added track. TrackList: "
-				+ trackList );
-		return track;
-	}
+    /**
+     * @param objectName
+     *            The objectName to set.
+     */
+    public void setObjectName( ObjectName objectName )
+    {
+        this.objectName = objectName;
+    }
 
-	/**
-	 * @return the RTSP session id used by the client in this session.
-	 */
-	public String getClientSessionId()
-	{
-		return clientSessionId;
-	}
+    /**
+     * Construct a new ProxySession. The session ID that will be used when
+     * communicating with the client will be generated.
+     */
+    public ProxySession()
+    {
+        setClientSessionId( newSessionID() );
+        log.debug( "\n----------\nCreated new proxy session: {} \n----------",
+                clientSessionId );
+    }
 
-	/**
-	 * @return the RTSP session id used by the server in this session.
-	 */
-	public String getServerSessionId()
-	{
-		return serverSessionId;
-	}
+    /**
+     * Adds a new Track associated with this ProxySession.
+     * 
+     * @param url
+     *            The URL used as a control reference for the Track
+     * @param serverSsrc
+     *            the SSRC id given by the server or null if not provided
+     * @return a reference to the newly created Track
+     */
+    public synchronized RtpTrack addRtpTrack( String url, String serverSsrc )
+    {
+        RtpTrack track = new RtpTrack( url );
+        if ( serverSsrc != null )
+            track.setServerSSRC( serverSsrc );
+        if ( portrangeRtpServerSession != null )
+            track.setPortrangeRtpServerSession( this.portrangeRtpServerSession );
 
-	/**
-	 * Sets the RTSP session id for the client.
-	 * 
-	 * @param clientSessionId
-	 *        a string containing the session id
-	 */
-	public synchronized void setClientSessionId( String clientSessionId )
-	{
-		this.clientSessionId = clientSessionId;
-		clientSessionIds.put( clientSessionId, this );
-		makeManaged();
-	}
+        trackList.put( url, track );
+        log.debug( "ProxySession: {} Added track. TrackList: {}", clientSessionId,
+                trackList );
+        return track;
+    }
 
-	/**
-	 * Sets the RTSP session id for the client.
-	 * 
-	 * @param clientSessionId
-	 *        a string containing the session id
-	 */
-	public synchronized void setServerSessionId( String serverSessionId )
-	{
-		this.serverSessionId = serverSessionId;
-		if ( serverSessionId != null )
-			serverSessionIds.put( serverSessionId, this );
-		makeManaged();
-	}
+    /**
+     * Adds a new Track associated with this ProxySession.
+     * 
+     * @param url
+     *            The URL used as a control reference for the Track
+     * @param serverSsrc
+     *            the SSRC id given by the server or null if not provided
+     * @return a reference to the newly created Track
+     */
+    public synchronized RdtTrack addRdtTrack( String url )
+    {
+        RdtTrack track = new RdtTrack( url );
+        trackList.put( url, track );
+        log.debug( "ProxySession: {} Added track. TrackList: {}", clientSessionId,
+                trackList );
+        return track;
+    }
 
-	/**
-	 * check if both client and server session id's are set and register proxy session 
-	 * facade MBean
-	 */
-	private void makeManaged() {
-		if(this.clientSessionId != null && this.serverSessionId != null)
-			JmxAgent.getInstance().registerProxySession(this);
-	}
-	
-	/**
-	 * Closes the entire proxy session and frees all associated resources.
-	 */
-	public synchronized void close()
-	{
-		if ( closedFlag )
-			return;
+    /**
+     * @return the RTSP session id used by the client in this session.
+     */
+    public String getClientSessionId()
+    {
+        return clientSessionId;
+    }
 
-		log.debug( "TrackList: " + trackList );
+    /**
+     * @return the RTSP session id used by the server in this session.
+     */
+    public String getServerSessionId()
+    {
+        return serverSessionId;
+    }
 
-		// close all associated tracks
-		for ( Map.Entry<String, Track> entry : trackList.entrySet() ) {
-			entry.getValue().close();
-		}
+    /**
+     * Sets the RTSP session id for the client.
+     * 
+     * @param clientSessionId
+     *            a string containing the session id
+     */
+    public synchronized void setClientSessionId( String clientSessionId )
+    {
+        this.clientSessionId = clientSessionId;
+        clientSessionIds.put( clientSessionId, this );
+        makeManaged();
+    }
 
-		closedFlag = true;
-		log.debug( "Closed proxySession: " + clientSessionId );
+    /**
+     * Sets the RTSP session id for the client.
+     * 
+     * @param clientSessionId
+     *            a string containing the session id
+     */
+    public synchronized void setServerSessionId( String serverSessionId )
+    {
+        this.serverSessionId = serverSessionId;
+        if ( serverSessionId != null )
+            serverSessionIds.put( serverSessionId, this );
+        makeManaged();
+    }
 
-		String s = "";
-		for ( String a : clientSessionIds.keySet() ) {
-			s += a + " ";
-		}
-		log.debug( "Clients: " + s );
-		s = "";
-		for ( String a : serverSessionIds.keySet() ) {
-			s += a + " ";
-		}
-		log.debug( "Servers: " + s );
+    /**
+     * check if both client and server session id's are set and register proxy
+     * session facade MBean
+     */
+    private void makeManaged()
+    {
+        if ( this.clientSessionId != null && this.serverSessionId != null )
+            JmxAgent.getInstance().registerProxySession( this );
+    }
 
-		if ( clientSessionId != null )
-			clientSessionIds.remove( clientSessionId );
-		if ( serverSessionId != null )
-			serverSessionIds.remove( serverSessionId );
-		
-		if(this.portrangeRtpServerSession != null)
-			PortrangeRtpServerSessionFactory.getInstance().releaseSession(this.portrangeRtpServerSession);
-		
-		// unregister session facade in MBean server
-		JmxAgent.getInstance().unregisterProxySession(this);
-	}
+    /**
+     * Closes the entire proxy session and frees all associated resources.
+     */
+    public synchronized void close()
+    {
+        if ( closedFlag )
+            return;
 
-	// ///////////////////
-	// Session ID generation
+        log.debug( "TrackList: {}", trackList );
 
-	/** Used for Session IDs generation */
-	private static Random random = new Random();
+        // close all associated tracks
+        for ( Map.Entry<String, Track> entry : trackList.entrySet() ) {
+            entry.getValue().close();
+        }
 
-	/**
-	 * Creates a unique session ID that is a 64 bit number.
-	 * 
-	 * @return the session ID string.
-	 */
-	private static String newSessionID()
-	{
-		String id;
-		while ( true ) {
-			// Create a 64 bit random number
-			synchronized ( random ) {
-				id = new UnsignedLong( random ).toString();
-			}
+        closedFlag = true;
+        log.debug( "Closed proxySession: {}", clientSessionId );
 
-			if ( clientSessionIds.get( id ) == null ) {
-				// Ok, the id is unique
-				return id;
-			}
-			// try with another id
-		}
-	}
+        String s = "";
+        for ( String a : clientSessionIds.keySet() ) {
+            s += a + " ";
+        }
+        log.debug( "Clients: {}", s );
+        s = "";
+        for ( String a : serverSessionIds.keySet() ) {
+            s += a + " ";
+        }
+        log.debug( "Servers: {}", s );
 
-	/**
-	 * Creates a unique session ID that is a 64 bit number.
-	 * 
-	 * @return the session ID string.
-	 */
-	public static UnsignedInt newServerSessionID()
-	{
-		UnsignedInt id;
-		while ( true ) {
-			// Create a 64 bit random number
-			synchronized ( random ) {
-				id = new UnsignedInt( random );
-			}
+        if ( clientSessionId != null )
+            clientSessionIds.remove( clientSessionId );
+        if ( serverSessionId != null )
+            serverSessionIds.remove( serverSessionId );
 
-			if ( serverSessionIds.get( id.toString() ) == null ) {
-				// Ok, the id is unique
-				return id;
-			}
-			// try with another id
-		}
-	}
+        if ( this.portrangeRtpServerSession != null )
+            PortrangeRtpServerSessionFactory.getInstance().releaseSession(
+                    this.portrangeRtpServerSession );
 
-	/**
-	 * @return Returns the closedFlag.
-	 */
-	public boolean isClosed() {
-		return closedFlag;
-	}
+        // unregister session facade in MBean server
+        JmxAgent.getInstance().unregisterProxySession( this );
+    }
 
-	public void setPortrangeRtpServerSession(PortrangeRtpServerSession portrangeRtpSession) {
-		this.portrangeRtpServerSession = portrangeRtpSession;
-	}
+    // ///////////////////
+    // Session ID generation
 
+    /** Used for Session IDs generation */
+    private static Random random = new Random();
+
+    /**
+     * Creates a unique session ID that is a 64 bit number.
+     * 
+     * @return the session ID string.
+     */
+    private static String newSessionID()
+    {
+        String id;
+        while ( true ) {
+            // Create a 64 bit random number
+            synchronized ( random ) {
+                id = new UnsignedLong( random ).toString();
+            }
+
+            if ( clientSessionIds.get( id ) == null ) {
+                // Ok, the id is unique
+                return id;
+            }
+            // try with another id
+        }
+    }
+
+    /**
+     * Creates a unique session ID that is a 64 bit number.
+     * 
+     * @return the session ID string.
+     */
+    public static UnsignedInt newServerSessionID()
+    {
+        UnsignedInt id;
+        while ( true ) {
+            // Create a 64 bit random number
+            synchronized ( random ) {
+                id = new UnsignedInt( random );
+            }
+
+            if ( serverSessionIds.get( id.toString() ) == null ) {
+                // Ok, the id is unique
+                return id;
+            }
+            // try with another id
+        }
+    }
+
+    /**
+     * @return Returns the closedFlag.
+     */
+    public boolean isClosed()
+    {
+        return closedFlag;
+    }
+
+    public void setPortrangeRtpServerSession(
+            PortrangeRtpServerSession portrangeRtpSession )
+    {
+        this.portrangeRtpServerSession = portrangeRtpSession;
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRdtPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRdtPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRdtPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -20,20 +20,15 @@
 
 import java.net.InetSocketAddress;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.apache.mina.common.ByteBuffer;
-import org.apache.mina.common.IoFilterChain;
 import org.apache.mina.common.IoHandlerAdapter;
 import org.apache.mina.common.IoSession;
-import org.apache.mina.common.TrafficMask;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.lib.Exceptions;
 import rtspproxy.proxy.track.RdtTrack;
 import rtspproxy.proxy.track.Track;
-import rtspproxy.rdt.RdtFilterChainBuilder;
 import rtspproxy.rdt.RdtPacket;
-import rtspproxy.rdt.RdtPacketDecoder;
 
 /**
  * Handles RDT packets from server and forward them to client. The RTSP 
@@ -81,22 +76,21 @@
 		if(buffer instanceof RdtPacket) {
 			RdtPacket rdtPacket = (RdtPacket)buffer;
 			
-			log.debug( "Received RDT packet from server, packet=" + rdtPacket );
+			log.debug( "Received RDT packet from server, packet={}", rdtPacket );
 
 			RdtTrack track = (RdtTrack)Track.getByServerAddress( (InetSocketAddress) session.getRemoteAddress() );
 
 			if ( track == null ) {
 				// drop packet
-				log.debug( "Invalid address: "
-						+ (InetSocketAddress) session.getRemoteAddress()
-						+ " - Class: "
-						+ ( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getClass() );
+				log.debug( "Invalid address: {} - Class: {}",
+						session.getRemoteAddress(),
+						( (InetSocketAddress) session.getRemoteAddress() ).getAddress().getClass() );
 				return;
 			}
 
 			track.forwardRdtToClient( rdtPacket );			
 		} else {
-			log.debug("invalid object passed: " + buffer.getClass().getName());
+			log.debug("invalid object passed: {}",  buffer.getClass().getName());
 			
 			throw new IllegalStateException("invalid packet on chain");
 		}
@@ -105,7 +99,7 @@
 	@Override
 	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
 	{
-		log.info( "Exception: " + cause );
+		log.info( "Exception: {}", cause );
 		Exceptions.logStackTrace( cause );
 		session.close();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtcpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtcpPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtcpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -38,52 +38,54 @@
 public class ServerRtcpPacketHandler extends IoHandlerAdapter
 {
 
-	private static Logger log = LoggerFactory.getLogger( ServerRtcpPacketHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ServerRtcpPacketHandler.class );
 
-	@Override
-	public void messageReceived( IoSession session, Object buffer ) throws Exception
-	{
-		RtcpPacket packet = new RtcpPacket( (ByteBuffer) buffer );
-		// log.debug( "Receive RTCP packet: " + packet.getType() );
-		RtpTrack track = null;
-		
-		if(!Config.proxyServerRtpSsrcUnreliable.getValue())
-			track = RtpTrack.getByServerSSRC( packet.getSsrc() );
+    @Override
+    public void messageReceived( IoSession session, Object buffer ) throws Exception
+    {
+        RtcpPacket packet = new RtcpPacket( (ByteBuffer) buffer );
+        // log.debug( "Receive RTCP packet: " + packet.getType() );
+        RtpTrack track = null;
 
-		if ( track == null ) {
-			if(Config.proxyServerRtpMultiplePorts.getValue())
-				track = (RtpTrack)Track.getByLocalRemoteServerAddress((InetSocketAddress)session.getLocalAddress(),
-						(InetSocketAddress)session.getRemoteAddress());
-			else
-				track = (RtpTrack)Track.getByServerAddress( (InetSocketAddress) session.getRemoteAddress() );
+        if ( !Config.proxyServerRtpSsrcUnreliable.getValue() )
+            track = RtpTrack.getByServerSSRC( packet.getSsrc() );
 
-			if ( track == null ) {
-				// drop packet
-				log.debug( "Invalid SSRC identifier: " + packet.getSsrc().toHexString() );
-				return;
-			} else {
-				// hot-wire the ssrc into the track
-				log.debug( "Adding SSRC identifier: " + packet.getSsrc().toHexString() );
-				track.setServerSSRC( packet.getSsrc() );
-			}
-		}
+        if ( track == null ) {
+            if ( Config.proxyServerRtpMultiplePorts.getValue() )
+                track = (RtpTrack) Track.getByLocalRemoteServerAddress(
+                        (InetSocketAddress) session.getLocalAddress(),
+                        (InetSocketAddress) session.getRemoteAddress() );
+            else
+                track = (RtpTrack) Track.getByServerAddress( (InetSocketAddress) session
+                        .getRemoteAddress() );
 
-		track.setRtcpServerSession( session );
-		track.forwardRtcpToClient( packet );
-	}
+            if ( track == null ) {
+                // drop packet
+                log.debug( "Invalid SSRC identifier: {}", packet.getSsrc().toHexString() );
+                return;
+            }
+            
+            // hot-wire the ssrc into the track
+            log.debug( "Adding SSRC identifier: {}", packet.getSsrc().toHexString() );
+            track.setServerSSRC( packet.getSsrc() );
+        }
 
-	@Override
-	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
-	{
-		log.debug( "Exception: " + cause );
-		Exceptions.logStackTrace( cause );
-		session.close();
-	}
+        track.setRtcpServerSession( session );
+        track.forwardRtcpToClient( packet );
+    }
 
-	@Override
-	public void sessionCreated( IoSession session ) throws Exception
-	{
+    @Override
+    public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
+    {
+        log.debug( "Exception: ", cause );
+        Exceptions.logStackTrace( cause );
+        session.close();
+    }
 
-	}
+    @Override
+    public void sessionCreated( IoSession session ) throws Exception
+    {
 
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtpPacketHandler.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerRtpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -28,6 +28,7 @@
 
 import rtspproxy.config.Config;
 import rtspproxy.lib.Exceptions;
+import rtspproxy.lib.number.UnsignedInt;
 import rtspproxy.proxy.track.RtpTrack;
 import rtspproxy.proxy.track.Track;
 import rtspproxy.rtp.RtpPacket;
@@ -38,72 +39,77 @@
 public class ServerRtpPacketHandler extends IoHandlerAdapter
 {
 
-	private static Logger log = LoggerFactory.getLogger( ServerRtpPacketHandler.class );
+    private static Logger log = LoggerFactory.getLogger( ServerRtpPacketHandler.class );
 
-	/*
-	 * @see org.apache.mina.io.IoHandlerAdapter#dataRead(org.apache.mina.io.IoSession,
-	 *      org.apache.mina.common.ByteBuffer)
-	 */
-	@Override
-	public void messageReceived( IoSession session, Object buffer ) throws Exception
-	{
-		// log.debug( "Received RTP packet" );
-		RtpPacket packet = new RtpPacket( (ByteBuffer) buffer );
-		RtpTrack track = null;
+    /*
+     * @see org.apache.mina.io.IoHandlerAdapter#dataRead(org.apache.mina.io.IoSession,
+     *      org.apache.mina.common.ByteBuffer)
+     */
+    @Override
+    public void messageReceived( IoSession session, Object buffer ) throws Exception
+    {
+        // log.debug( "Received RTP packet" );
+        RtpPacket packet = new RtpPacket( (ByteBuffer) buffer );
+        RtpTrack track = null;
 
-		if(!Config.proxyServerRtpSsrcUnreliable.getValue())
-			track = RtpTrack.getByServerSSRC( packet.getSsrc() );
-		
-		log.debug("recevied server RTP packet, SSRC=" + packet.getSsrc() + ", CSRC=" + packet.getCsrc()
-				+ ", server=" + session.getRemoteAddress() + ", local=" + session.getLocalAddress());
-		
-		if ( track == null ) {
-			if(Config.proxyServerRtpMultiplePorts.getValue())
-				track = (RtpTrack)Track.getByLocalRemoteServerAddress((InetSocketAddress)session.getLocalAddress(),
-						(InetSocketAddress)session.getRemoteAddress());
-			else
-				track = (RtpTrack)Track.getByServerAddress( (InetSocketAddress) session.getRemoteAddress() );
+        if ( !Config.proxyServerRtpSsrcUnreliable.getValue() )
+            track = RtpTrack.getByServerSSRC( packet.getSsrc() );
 
-			if ( track == null ) {
-				// drop packet
-				log.debug( "Invalid SSRC identifier: "
-						+ packet.getSsrc().toHexString() );
-				return;
-			} else {
-				// hot-wire the ssrc into the track
-				log.debug( "Adding SSRC identifier: "
-						+ packet.getSsrc().toHexString() );
-				track.setServerSSRC( packet.getSsrc() );
-			}
+        /*
+         * if ( log.isDebugEnabled() ) { log.debug( "recevied server RTP packet,
+         * SSRC=" + packet.getSsrc() + ", CSRC=" + packet.getCsrc() + ",
+         * server=" + session.getRemoteAddress() + ", local=" +
+         * session.getLocalAddress() ); }
+         */
 
-		}
+        if ( track == null ) {
+            if ( Config.proxyServerRtpMultiplePorts.getValue() )
+                track = (RtpTrack) Track.getByLocalRemoteServerAddress(
+                        (InetSocketAddress) session.getLocalAddress(),
+                        (InetSocketAddress) session.getRemoteAddress() );
+            else
+                track = (RtpTrack) Track.getByServerAddress( (InetSocketAddress) session
+                        .getRemoteAddress() );
 
-		track.setRtpServerSession( session );
-		track.forwardRtpToClient( packet );
-	}
+            if ( track == null ) {
+                // drop packet
+                log.debug( "Invalid SSRC identifier: {}", packet.getSsrc().toHexString() );
+                return;
+            }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.mina.io.IoHandlerAdapter#exceptionCaught(org.apache.mina.io.IoSession,
-	 *      java.lang.Throwable)
-	 */
-	@Override
-	public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
-	{
-		log.debug( "Exception: " + cause );
-		Exceptions.logStackTrace( cause );
-		session.close();
-	}
+            // hot-wire the ssrc into the track
+            if ( track.getServerSSRC() == UnsignedInt.ZERO ) {
+                log.debug( "Adding SSRC identifier: {}", packet.getSsrc().toHexString() );
+                track.setServerSSRC( packet.getSsrc() );
+            }
+        }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.mina.io.IoHandlerAdapter#sessionCreated(org.apache.mina.io.IoSession)
-	 */
-	@Override
-	public void sessionCreated( IoSession session ) throws Exception
-	{
-	}
+        track.setRtpServerSession( session );
+        track.forwardRtpToClient( packet );
+    }
 
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.io.IoHandlerAdapter#exceptionCaught(org.apache.mina.io.IoSession,
+     *      java.lang.Throwable)
+     */
+    @Override
+    public void exceptionCaught( IoSession session, Throwable cause ) throws Exception
+    {
+        log.debug( "Exception: {}", cause );
+        Exceptions.logStackTrace( cause );
+        session.close();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.io.IoHandlerAdapter#sessionCreated(org.apache.mina.io.IoSession)
+     */
+    @Override
+    public void sessionCreated( IoSession session ) throws Exception
+    {
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerSide.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerSide.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ServerSide.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -13,12 +13,10 @@
 
 package rtspproxy.proxy;
 
-import java.util.HashMap;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.IoHandlerAdapter;
 import org.apache.mina.common.IoSession;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.lib.Exceptions;
 import rtspproxy.rtsp.RtspCode;
@@ -37,7 +35,7 @@
 	@Override
 	public void sessionCreated( IoSession session ) throws Exception
 	{
-		log.info( "Created session to server: " + session.getRemoteAddress() );
+		log.info( "Created session to server: {}", session.getRemoteAddress() );
 	}
 
 	@Override
@@ -198,7 +196,7 @@
 	public void messageReceived( IoSession session, Object message )
 	{
 		RtspMessage rtspMessage = (RtspMessage) message;
-		log.debug( "Received message:\n" + message );
+		log.debug( "Received message:\n{}", message );
 
 		ProxyHandler proxyHandler = (ProxyHandler) ( session.getAttribute( ProxyHandler.ATTR ) );
 		if ( proxyHandler == null ) {

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RdtTrack.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RdtTrack.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RdtTrack.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,10 +3,9 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 
+import org.apache.mina.common.IoSession;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.apache.mina.common.ByteBuffer;
-import org.apache.mina.common.IoSession;
 
 import rtspproxy.RdtClientService;
 import rtspproxy.RdtServerService;
@@ -15,136 +14,138 @@
 public class RdtTrack extends Track
 {
 
-	private static Logger log = LoggerFactory.getLogger( RdtTrack.class );
+    private static Logger log = LoggerFactory.getLogger( RdtTrack.class );
 
-	/**
-	 * Cached references to IoSession objects used to send packets to server and
-	 * client.
-	 */
-	private IoSession rdtClientSession = null;
+    /**
+     * Cached references to IoSession objects used to send packets to server and
+     * client.
+     */
+    private IoSession rdtClientSession = null;
 
-	private IoSession rdtServerSession = null;
+    private IoSession rdtServerSession = null;
 
-	private int clientRdtPort;
+    private int clientRdtPort;
 
-	private int serverRdtPort;
+    private int serverRdtPort;
 
-	/**
-	 * Construct a new Track.
-	 * 
-	 * @param url
-	 *            the control name for this track.
-	 */
-	public RdtTrack( String url )
-	{
-		super( url );
-	}
+    /**
+     * Construct a new Track.
+     * 
+     * @param url
+     *            the control name for this track.
+     */
+    public RdtTrack( String url )
+    {
+        super( url );
+    }
 
-	/**
-	 * Forwards a RDT packet to client. The packet will be set to the address
-	 * indicated by the client at RDT port.
-	 * <p>
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param packet
-	 *            a buffer containing a RDT packet
-	 */
-	public void forwardRdtToClient( RdtPacket packet )
-	{
-		// modify the SSRC for the client
-		// packet.setSsrc( proxySSRC );
+    /**
+     * Forwards a RDT packet to client. The packet will be set to the address
+     * indicated by the client at RDT port.
+     * <p>
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param packet
+     *            a buffer containing a RDT packet
+     */
+    public void forwardRdtToClient( RdtPacket packet )
+    {
+        // modify the SSRC for the client
+        // packet.setSsrc( proxySSRC );
 
-		if ( rdtClientSession == null ) {
-			rdtClientSession = RdtClientService.getInstance().newSession(
-					new InetSocketAddress( clientAddress, clientRdtPort ) );
-		}
+        if ( rdtClientSession == null ) {
+            rdtClientSession = RdtClientService.getInstance().newSession(
+                    new InetSocketAddress( clientAddress, clientRdtPort ) );
+        }
 
-		log.debug( "Packet: " + packet );
-		rdtClientSession.write( packet );
-	}
+        log.debug( "Packet: {}", packet );
+        rdtClientSession.write( packet );
+    }
 
-	/**
-	 * Forwards a RDT packet to server. The packet will be set to the address
-	 * indicated by the server at RDT port.
-	 * 
-	 * @param packet
-	 *            a RDT packet
-	 */
-	public void forwardRdtToServer( RdtPacket packet )
-	{
-		if ( rdtServerSession == null || !rdtServerSession.isConnected() ) {
-			InetSocketAddress remoteAddress = new InetSocketAddress( serverAddress,
-					serverRdtPort );
-			log.debug( "Creating RDT session to: " + remoteAddress );
-			rdtServerSession = RdtServerService.getInstance().newSession( remoteAddress );
-		}
+    /**
+     * Forwards a RDT packet to server. The packet will be set to the address
+     * indicated by the server at RDT port.
+     * 
+     * @param packet
+     *            a RDT packet
+     */
+    public void forwardRdtToServer( RdtPacket packet )
+    {
+        if ( rdtServerSession == null || !rdtServerSession.isConnected() ) {
+            InetSocketAddress remoteAddress = new InetSocketAddress( serverAddress,
+                    serverRdtPort );
+            log.debug( "Creating RDT session to: {}", remoteAddress );
+            rdtServerSession = RdtServerService.getInstance().newSession( remoteAddress );
+        }
 
-		// log.debug( "Packet: " + packet );
-		// packet.reset();
-		// log.debug("Packet: " + packet );
-		// log.debug( "Written bytes1: " + rdtServerSession.getWrittenBytes() );
-		
-		rdtServerSession.write( packet );
-		// log.debug( "Written bytes2: " + rdtServerSession.getWrittenBytes() );
-	}
+        // log.debug( "Packet: {}", packet );
+        // packet.reset();
+        // log.debug("Packet: {}", packet );
+        // log.debug( "Written bytes1: {}", rdtServerSession.getWrittenBytes() );
 
-	/**
-	 * Set the address of the server associated with this track.
-	 * <p>
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param serverHost
-	 *            The serverHost to set.
-	 * @param rdtpPort
-	 *            the port number used for RDT packets
-	 */
-	public synchronized void setClientAddress( InetAddress clientAddress, int rdtPort )
-	{
-		this.clientAddress = clientAddress;
-		this.clientRdtPort = rdtPort;
+        rdtServerSession.write( packet );
+        // log.debug( "Written bytes2: {}", rdtServerSession.getWrittenBytes() );
+    }
 
-		InetSocketAddress clientAddr = new InetSocketAddress( clientAddress, rdtPort );
+    /**
+     * Set the address of the server associated with this track.
+     * <p>
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param serverHost
+     *            The serverHost to set.
+     * @param rdtpPort
+     *            the port number used for RDT packets
+     */
+    public synchronized void setClientAddress( InetAddress clientAddress, int rdtPort )
+    {
+        this.clientAddress = clientAddress;
+        this.clientRdtPort = rdtPort;
 
-		/*
-		log.debug( "Creating RDT server session to: " + clientAddr );
-		rdtClientSession = RdtClientService.getInstance().newSession( clientAddr );
-		*/
-		
-		clientAddressMap.put( clientAddr , this );
-	}
+        InetSocketAddress clientAddr = new InetSocketAddress( clientAddress, rdtPort );
 
-	/**
-	 * Set the address of the server associated with this track.
-	 * 
-	 * @param serverHost
-	 *            The serverHost to set.
-	 * @param rdtPort
-	 *            the port number used for RDT packets
-	 */
-	public synchronized void setServerAddress( InetAddress serverAddress, int rdtPort )
-	{
-		this.serverAddress = serverAddress;
-		this.serverRdtPort = rdtPort;
+        /*
+         * log.debug( "Creating RDT server session to: {}", clientAddr );
+         * rdtClientSession = RdtClientService.getInstance().newSession(
+         * clientAddr );
+         */
 
-		InetSocketAddress remoteAddress = new InetSocketAddress( serverAddress,
-				serverRdtPort );
-		
-		/*
-		log.debug( "Creating RDT server session to: " + remoteAddress );
-		rdtServerSession = RdtServerService.getInstance().newSession( remoteAddress );
-		*/
-		
-		serverAddressMap.put( remoteAddress, this );
-	}
+        clientAddressMap.put( clientAddr, this );
+    }
 
-	public synchronized void close()
-	{
-		serverAddressMap.remove( new InetSocketAddress( serverAddress, serverRdtPort ) );
-		clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRdtPort ) );
+    /**
+     * Set the address of the server associated with this track.
+     * 
+     * @param serverHost
+     *            The serverHost to set.
+     * @param rdtPort
+     *            the port number used for RDT packets
+     */
+    public synchronized void setServerAddress( InetAddress serverAddress, int rdtPort )
+    {
+        this.serverAddress = serverAddress;
+        this.serverRdtPort = rdtPort;
 
-		
-		log.debug( "Closed track " + url );
-	}
+        InetSocketAddress remoteAddress = new InetSocketAddress( serverAddress,
+                serverRdtPort );
+
+        /*
+         * log.debug( "Creating RDT server session to: {}", remoteAddress );
+         * rdtServerSession = RdtServerService.getInstance().newSession(
+         * remoteAddress );
+         */
+
+        serverAddressMap.put( remoteAddress, this );
+    }
+
+    @Override
+    public synchronized void close()
+    {
+        serverAddressMap.remove( new InetSocketAddress( serverAddress, serverRdtPort ) );
+        clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRdtPort ) );
+
+        log.debug( "Closed track {}", url );
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RtpTrack.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RtpTrack.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/RtpTrack.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -25,345 +25,355 @@
 public class RtpTrack extends Track
 {
 
-	private static Logger log = LoggerFactory.getLogger( RtpTrack.class );
+    private static Logger log = LoggerFactory.getLogger( RtpTrack.class );
 
-	/** Maps a server SSRC id to a Track */
-	private static Map<UnsignedInt, RtpTrack> serverSsrcMap = new ConcurrentHashMap<UnsignedInt, RtpTrack>();
+    /** Maps a server SSRC id to a Track */
+    private static Map<UnsignedInt, RtpTrack> serverSsrcMap = new ConcurrentHashMap<UnsignedInt, RtpTrack>();
 
-	/** Keeps track of the SSRC IDs used by the proxy, to avoid collisions. */
-	private static Set<UnsignedInt> proxySsrcList = Collections
-			.synchronizedSet( new HashSet<UnsignedInt>() );
+    /** Keeps track of the SSRC IDs used by the proxy, to avoid collisions. */
+    private static Set<UnsignedInt> proxySsrcList = Collections
+            .synchronizedSet( new HashSet<UnsignedInt>() );
 
-	/**
-	 * Get the track by looking at server SSRC id.
-	 * 
-	 * @return a Track instance if a matching SSRC is found or null
-	 */
-	public static RtpTrack getByServerSSRC( UnsignedInt serverSsrc )
-	{
-		return serverSsrcMap.get( serverSsrc );
-	}
+    /**
+     * Get the track by looking at server SSRC id.
+     * 
+     * @return a Track instance if a matching SSRC is found or null
+     */
+    public static RtpTrack getByServerSSRC( UnsignedInt serverSsrc )
+    {
+        return serverSsrcMap.get( serverSsrc );
+    }
 
-	/** SSRC id given by the server */
-	private UnsignedInt serverSSRC = new UnsignedInt( 0 );
+    /** SSRC id given by the server */
+    private UnsignedInt serverSSRC = UnsignedInt.ZERO;
 
-	/** SSRC id selected by the proxy */
-	private UnsignedInt proxySSRC = new UnsignedInt( 0 );
+    /** SSRC id selected by the proxy */
+    private UnsignedInt proxySSRC = UnsignedInt.ZERO;
 
-	/**
-	 * Cached references to IoSession objects used to send packets to server and
-	 * client.
-	 */
-	private IoSession rtpServerSession = null;
+    /**
+     * Cached references to IoSession objects used to send packets to server and
+     * client.
+     */
+    private IoSession rtpServerSession = null;
 
-	private IoSession rtcpServerSession = null;
+    private IoSession rtcpServerSession = null;
 
-	private IoSession rtpClientSession = null;
+    private IoSession rtpClientSession = null;
 
-	private IoSession rtcpClientSession = null;
+    private IoSession rtcpClientSession = null;
 
-	private int clientRtpPort;
+    private int clientRtpPort;
 
-	private int clientRtcpPort;
+    private int clientRtcpPort;
 
-	private int serverRtpPort;
+    private int serverRtpPort;
 
-	private int serverRtcpPort;
-	
-	private PortrangeRtpServerSession portrangeRtpServerSession;
+    private int serverRtcpPort;
 
-	/**
-	 * Construct a new Track.
-	 * 
-	 * @param url
-	 *            the control name for this track.
-	 */
-	public RtpTrack( String url )
-	{
-		super( url );
-		setProxySSRC( newSSRC() );
-	}
+    private PortrangeRtpServerSession portrangeRtpServerSession;
 
-	/**
-	 * @return the SSRC id used byt the proxy
-	 */
-	public UnsignedInt getProxySSRC()
-	{
-		return proxySSRC;
-	}
+    /**
+     * Construct a new Track.
+     * 
+     * @param url
+     *            the control name for this track.
+     */
+    public RtpTrack( String url )
+    {
+        super( url );
+        setProxySSRC( newSSRC() );
+    }
 
-	/**
-	 * Sets the proxy SSRC id.
-	 * 
-	 * @param proxySSRC
-	 */
-	public void setProxySSRC( String proxySSRC )
-	{
-		try {
-			this.proxySSRC = UnsignedInt.fromString( proxySSRC, 16 );
+    /**
+     * @return the SSRC id used byt the proxy
+     */
+    public UnsignedInt getProxySSRC()
+    {
+        return proxySSRC;
+    }
 
-			proxySsrcList.add( this.proxySSRC );
-		} catch ( NumberFormatException nfe ) {
-			log.debug( "Cannot convert " + proxySSRC + " to integer." );
-			throw nfe;
-		}
-	}
+    /**
+     * Sets the proxy SSRC id.
+     * 
+     * @param proxySSRC
+     */
+    public void setProxySSRC( String proxySSRC )
+    {
+        try {
+            this.proxySSRC = UnsignedInt.fromString( proxySSRC, 16 );
 
-	/**
-	 * @return the server SSRC id
-	 */
-	public UnsignedInt getServerSSRC()
-	{
-		return serverSSRC;
-	}
+            proxySsrcList.add( this.proxySSRC );
+        } catch ( NumberFormatException nfe ) {
+            log.debug( "Cannot convert {} to integer.", proxySSRC );
+            throw nfe;
+        }
+    }
 
-	/**
-	 * Sets the server SSRC id.
-	 * 
-	 * @param serverSSRC
-	 */
-	public void setServerSSRC( String serverSSRC )
-	{
-		this.serverSSRC = UnsignedInt.fromString( serverSSRC, 16 );
-		serverSsrcMap.put( this.serverSSRC, this );
-	}
+    /**
+     * @return the server SSRC id
+     */
+    public UnsignedInt getServerSSRC()
+    {
+        return serverSSRC;
+    }
 
-	/**
-	 * Sets the server SSRC id.
-	 * 
-	 * @param serverSSRC
-	 */
-	public void setServerSSRC( UnsignedInt serverSSRC )
-	{
-		this.serverSSRC = serverSSRC;
-		serverSsrcMap.put( this.serverSSRC, this );
-	}
+    /**
+     * Sets the server SSRC id.
+     * 
+     * @param serverSSRC
+     */
+    public void setServerSSRC( String serverSSRC )
+    {
+        this.serverSSRC = UnsignedInt.fromString( serverSSRC, 16 );
+        serverSsrcMap.put( this.serverSSRC, this );
+    }
 
-	public void setRtcpClientSession( IoSession rtcpClientSession )
-	{
-		this.rtcpClientSession = rtcpClientSession;
-	}
+    /**
+     * Sets the server SSRC id.
+     * 
+     * @param serverSSRC
+     */
+    public void setServerSSRC( UnsignedInt serverSSRC )
+    {
+        this.serverSSRC = serverSSRC;
+        serverSsrcMap.put( this.serverSSRC, this );
+    }
 
-	public void setRtcpServerSession( IoSession rtcpServerSession )
-	{
-		this.rtcpServerSession = rtcpServerSession;
-	}
+    public void setRtcpClientSession( IoSession rtcpClientSession )
+    {
+        this.rtcpClientSession = rtcpClientSession;
+    }
 
-	public void setRtpClientSession( IoSession rtpClientSession )
-	{
-		this.rtpClientSession = rtpClientSession;
-	}
+    public void setRtcpServerSession( IoSession rtcpServerSession )
+    {
+        this.rtcpServerSession = rtcpServerSession;
+    }
 
-	public void setRtpServerSession( IoSession rtpServerSession )
-	{
-		this.rtpServerSession = rtpServerSession;
-	}
+    public void setRtpClientSession( IoSession rtpClientSession )
+    {
+        this.rtpClientSession = rtpClientSession;
+    }
 
-	/**
-	 * Forwards a RTP packet to server. The packet will be set to the address
-	 * indicated by the server at RTP (even) port.
-	 * 
-	 * @param packet
-	 *            a RTP packet
-	 */
-	public void forwardRtpToServer( RtpPacket packet )
-	{
-		// modify the SSRC for the server
-		packet.setSsrc( proxySSRC );
+    public void setRtpServerSession( IoSession rtpServerSession )
+    {
+        this.rtpServerSession = rtpServerSession;
+    }
 
-		if ( rtpServerSession == null ) {
-			if(this.portrangeRtpServerSession != null) {
-				rtpServerSession = this.portrangeRtpServerSession.newRtpSession(new InetSocketAddress( serverAddress, 
-						serverRtpPort ));
-			} else {
-				rtpServerSession = RtpServerService.getInstance().newSession(
-						new InetSocketAddress( serverAddress, serverRtpPort ) );
-			}
-		}
+    /**
+     * Forwards a RTP packet to server. The packet will be set to the address
+     * indicated by the server at RTP (even) port.
+     * 
+     * @param packet
+     *            a RTP packet
+     */
+    public void forwardRtpToServer( RtpPacket packet )
+    {
+        // modify the SSRC for the server
+        packet.setSsrc( proxySSRC );
 
-		rtpServerSession.write( packet.toByteBuffer() );
-	}
+        if ( rtpServerSession == null ) {
+            if ( this.portrangeRtpServerSession != null ) {
+                rtpServerSession = this.portrangeRtpServerSession
+                        .newRtpSession( new InetSocketAddress( serverAddress,
+                                serverRtpPort ) );
+            } else {
+                rtpServerSession = RtpServerService.getInstance().newSession(
+                        new InetSocketAddress( serverAddress, serverRtpPort ) );
+            }
+        }
 
-	/**
-	 * Forwards a RTCP packet to server. The packet will be set to the address
-	 * indicated by the server at RTCP (odd) port.
-	 * 
-	 * @param packet
-	 *            a RTCP packet
-	 */
-	public void forwardRtcpToServer( RtcpPacket packet )
-	{
-		// modify the SSRC for the server
-		packet.setSsrc( proxySSRC );
+        rtpServerSession.write( packet.toByteBuffer() );
+    }
 
-		if ( rtcpServerSession == null ) {
-			if(this.portrangeRtpServerSession != null) {
-				rtcpServerSession = this.portrangeRtpServerSession.newRtcpSession(new InetSocketAddress( serverAddress, 
-						serverRtcpPort ));
-			} else {
-				rtcpServerSession = RtcpServerService.getInstance().newSession(
-						new InetSocketAddress( serverAddress, serverRtcpPort ) );
-			}
-		}
-		rtcpServerSession.write( packet.toByteBuffer() );
-	}
+    /**
+     * Forwards a RTCP packet to server. The packet will be set to the address
+     * indicated by the server at RTCP (odd) port.
+     * 
+     * @param packet
+     *            a RTCP packet
+     */
+    public void forwardRtcpToServer( RtcpPacket packet )
+    {
+        // modify the SSRC for the server
+        packet.setSsrc( proxySSRC );
 
-	/**
-	 * Forwards a RTP packet to client. The packet will be set to the address
-	 * indicated by the client at RTP (even) port.
-	 * <p>
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param packet
-	 *            a RTP packet
-	 */
-	public void forwardRtpToClient( RtpPacket packet )
-	{
-		// modify the SSRC for the client
-		packet.setSsrc( proxySSRC );
+        if ( rtcpServerSession == null ) {
+            if ( this.portrangeRtpServerSession != null ) {
+                rtcpServerSession = this.portrangeRtpServerSession
+                        .newRtcpSession( new InetSocketAddress( serverAddress,
+                                serverRtcpPort ) );
+            } else {
+                rtcpServerSession = RtcpServerService.getInstance().newSession(
+                        new InetSocketAddress( serverAddress, serverRtcpPort ) );
+            }
+        }
+        rtcpServerSession.write( packet.toByteBuffer() );
+    }
 
-		if ( rtpClientSession == null ) {
-			rtpClientSession = RtpClientService.getInstance().newSession(
-					new InetSocketAddress( clientAddress, clientRtpPort ) );
-		}
+    /**
+     * Forwards a RTP packet to client. The packet will be set to the address
+     * indicated by the client at RTP (even) port.
+     * <p>
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param packet
+     *            a RTP packet
+     */
+    public void forwardRtpToClient( RtpPacket packet )
+    {
+        // modify the SSRC for the client
+        packet.setSsrc( proxySSRC );
 
-		log.debug("forwarding RTP packet, SSRC=" + packet.getSsrc() + ", CSRC=" + packet.getCsrc()
-				+ ", client=" + rtpClientSession.getRemoteAddress());
-		rtpClientSession.write( packet.toByteBuffer() );
-	}
+        if ( rtpClientSession == null ) {
+            rtpClientSession = RtpClientService.getInstance().newSession(
+                    new InetSocketAddress( clientAddress, clientRtpPort ) );
+        }
 
-	/**
-	 * Forwards a RTCP packet to client. The packet will be set to the address
-	 * indicated by the client at RTCP (odd) port.
-	 * <p>
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param packet
-	 *            a RTCP packet
-	 */
-	public void forwardRtcpToClient( RtcpPacket packet )
-	{
-		// modify the SSRC for the client
-		packet.setSsrc( proxySSRC );
+        /*
+        if ( log.isDebugEnabled() ) 
+            log.debug( "forwarding RTP packet, SSRC=" + packet.getSsrc() + ", CSRC="
+                    + packet.getCsrc() + ", client=" + rtpClientSession.getRemoteAddress() );
+        */
+        rtpClientSession.write( packet.toByteBuffer() );
+    }
 
-		if ( rtcpClientSession == null ) {
-			rtcpClientSession = RtcpClientService.getInstance().newSession(
-					new InetSocketAddress( clientAddress, clientRtcpPort ) );
-		}
+    /**
+     * Forwards a RTCP packet to client. The packet will be set to the address
+     * indicated by the client at RTCP (odd) port.
+     * <p>
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param packet
+     *            a RTCP packet
+     */
+    public void forwardRtcpToClient( RtcpPacket packet )
+    {
+        // modify the SSRC for the client
+        packet.setSsrc( proxySSRC );
 
-		rtcpClientSession.write( packet.toByteBuffer() );
-	}
+        if ( rtcpClientSession == null ) {
+            rtcpClientSession = RtcpClientService.getInstance().newSession(
+                    new InetSocketAddress( clientAddress, clientRtcpPort ) );
+        }
 
-	/**
-	 * Set the address of the server associated with this track.
-	 * <p>
-	 * TODO: This will be changed to support multiple clients connected to the
-	 * same (live) track.
-	 * 
-	 * @param serverHost
-	 *            The serverHost to set.
-	 * @param rtpPort
-	 *            the port number used for RTP packets
-	 * @param rtcpPort
-	 *            the port number used for RTCP packets
-	 */
-	public synchronized void setClientAddress( InetAddress clientAddress, int rtpPort,
-			int rtcpPort )
-	{
-		this.clientAddress = clientAddress;
-		this.clientRtpPort = rtpPort;
-		this.clientRtcpPort = rtcpPort;
+        rtcpClientSession.write( packet.toByteBuffer() );
+    }
 
-		clientAddressMap.put( new InetSocketAddress( clientAddress, rtpPort ), this );
-		clientAddressMap.put( new InetSocketAddress( clientAddress, rtcpPort ), this );
-	}
+    /**
+     * Set the address of the server associated with this track.
+     * <p>
+     * TODO: This will be changed to support multiple clients connected to the
+     * same (live) track.
+     * 
+     * @param serverHost
+     *            The serverHost to set.
+     * @param rtpPort
+     *            the port number used for RTP packets
+     * @param rtcpPort
+     *            the port number used for RTCP packets
+     */
+    public synchronized void setClientAddress( InetAddress clientAddress, int rtpPort,
+            int rtcpPort )
+    {
+        this.clientAddress = clientAddress;
+        this.clientRtpPort = rtpPort;
+        this.clientRtcpPort = rtcpPort;
 
-	/**
-	 * Set the address of the server associated with this track.
-	 * 
-	 * @param serverHost
-	 *            The serverHost to set.
-	 * @param rtpPort
-	 *            the port number used for RTP packets
-	 * @param rtcpPort
-	 *            the port number used for RTCP packets
-	 */
-	public synchronized void setServerAddress( InetAddress serverAddress, int rtpPort,
-			int rtcpPort )
-	{
-		this.serverAddress = serverAddress;
-		this.serverRtpPort = rtpPort;
-		this.serverRtcpPort = rtcpPort;
+        clientAddressMap.put( new InetSocketAddress( clientAddress, rtpPort ), this );
+        clientAddressMap.put( new InetSocketAddress( clientAddress, rtcpPort ), this );
+    }
 
-		InetSocketAddress rtpSockAddr = new InetSocketAddress( serverAddress, rtpPort );
-		InetSocketAddress rtcpSockAddr = new InetSocketAddress( serverAddress, rtcpPort ); 
-		
-		serverAddressMap.put( rtpSockAddr, this );
-		serverAddressMap.put( rtcpSockAddr, this );
-		
-		if(this.portrangeRtpServerSession != null) {
-			localRemoteServerAddressMap.put(
-					new LocalRemoteAddressPair(this.portrangeRtpServerSession.getRtpSocketAddress(), rtpSockAddr), 
-					this);
-			localRemoteServerAddressMap.put(
-					new LocalRemoteAddressPair(this.portrangeRtpServerSession.getRtcpSocketAddress(), rtcpSockAddr), 
-					this);
-		}
-	}
+    /**
+     * Set the address of the server associated with this track.
+     * 
+     * @param serverHost
+     *            The serverHost to set.
+     * @param rtpPort
+     *            the port number used for RTP packets
+     * @param rtcpPort
+     *            the port number used for RTCP packets
+     */
+    public synchronized void setServerAddress( InetAddress serverAddress, int rtpPort,
+            int rtcpPort )
+    {
+        this.serverAddress = serverAddress;
+        this.serverRtpPort = rtpPort;
+        this.serverRtcpPort = rtcpPort;
 
-	public synchronized void close()
-	{
-		if ( serverSSRC != null )
-			serverSsrcMap.remove( serverSSRC );
-		
-		InetSocketAddress rtpSockAddr = new InetSocketAddress(serverAddress, serverRtpPort);
-		InetSocketAddress rtcpSockAddr = new InetSocketAddress(serverAddress, serverRtcpPort);
-		
-		serverAddressMap.remove( rtpSockAddr );
-		serverAddressMap.remove( rtcpSockAddr );
-		if(this.portrangeRtpServerSession != null) {
-			localRemoteServerAddressMap.remove(
-					new LocalRemoteAddressPair(this.portrangeRtpServerSession.getRtpSocketAddress(), rtpSockAddr));
-			localRemoteServerAddressMap.remove(
-					new LocalRemoteAddressPair(this.portrangeRtpServerSession.getRtcpSocketAddress(), rtcpSockAddr));
-		}		
-		
-		clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRtpPort ) );
-		clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRtcpPort ) );
+        InetSocketAddress rtpSockAddr = new InetSocketAddress( serverAddress, rtpPort );
+        InetSocketAddress rtcpSockAddr = new InetSocketAddress( serverAddress, rtcpPort );
 
-		if ( proxySSRC != null )
-			proxySsrcList.remove( proxySSRC );
-		log.debug( "Closed track " + url );
-	}
+        serverAddressMap.put( rtpSockAddr, this );
+        serverAddressMap.put( rtcpSockAddr, this );
 
-	// ////////////////
+        if ( this.portrangeRtpServerSession != null ) {
+            localRemoteServerAddressMap.put( new LocalRemoteAddressPair(
+                    this.portrangeRtpServerSession.getRtpSocketAddress(), rtpSockAddr ),
+                    this );
+            localRemoteServerAddressMap.put(
+                    new LocalRemoteAddressPair( this.portrangeRtpServerSession
+                            .getRtcpSocketAddress(), rtcpSockAddr ), this );
+        }
+    }
 
-	/** Used in SSRC id generation */
-	private static Random random = new Random();
+    @Override
+    public synchronized void close()
+    {
+        if ( serverSSRC != null )
+            serverSsrcMap.remove( serverSSRC );
 
-	/**
-	 * Creates a new SSRC id that is unique in the proxy.
-	 * 
-	 * @return the session ID
-	 */
-	private static String newSSRC()
-	{
-		long id;
-		while ( true ) {
-			id = random.nextLong() & 0xFFFFFFFFL;
+        final InetSocketAddress rtpSockAddr = new InetSocketAddress( serverAddress,
+                serverRtpPort );
+        final InetSocketAddress rtcpSockAddr = new InetSocketAddress( serverAddress,
+                serverRtcpPort );
 
-			if ( !proxySsrcList.contains( id ) ) {
-				// Ok, the id is unique
-				String ids = Long.toString( id, 16 );
-				return ids;
-			}
-			// try with another id
-		}
-	}
+        serverAddressMap.remove( rtpSockAddr );
+        serverAddressMap.remove( rtcpSockAddr );
+        if ( this.portrangeRtpServerSession != null ) {
+            localRemoteServerAddressMap.remove( new LocalRemoteAddressPair(
+                    this.portrangeRtpServerSession.getRtpSocketAddress(), rtpSockAddr ) );
+            localRemoteServerAddressMap
+                    .remove( new LocalRemoteAddressPair( this.portrangeRtpServerSession
+                            .getRtcpSocketAddress(), rtcpSockAddr ) );
+        }
 
-	public void setPortrangeRtpServerSession(PortrangeRtpServerSession session) {
-		this.portrangeRtpServerSession = session;
-	}
+        clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRtpPort ) );
+        clientAddressMap.remove( new InetSocketAddress( clientAddress, clientRtcpPort ) );
+
+        if ( proxySSRC != null )
+            proxySsrcList.remove( proxySSRC );
+        log.debug( "Closed track {}", url );
+    }
+
+    // ////////////////
+
+    /** Used in SSRC id generation */
+    private static Random random = new Random();
+
+    /**
+     * Creates a new SSRC id that is unique in the proxy.
+     * 
+     * @return the session ID
+     */
+    private static String newSSRC()
+    {
+        long id;
+        while ( true ) {
+            id = random.nextLong() & 0xFFFFFFFFL;
+
+            if ( !proxySsrcList.contains( id ) ) {
+                // Ok, the id is unique
+                String ids = Long.toString( id, 16 );
+                return ids;
+            }
+            // try with another id
+        }
+    }
+
+    public void setPortrangeRtpServerSession( PortrangeRtpServerSession session )
+    {
+        this.portrangeRtpServerSession = session;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -36,136 +36,151 @@
 public abstract class Track
 {
 
-	protected static class LocalRemoteAddressPair {
-		private InetSocketAddress local;
-		private InetSocketAddress remote;
-		
-		public LocalRemoteAddressPair(InetSocketAddress local, InetSocketAddress remote) {
-			this.local = local;
-			this.remote = remote;
-		}
+    protected static class LocalRemoteAddressPair
+    {
 
-		/* (non-Javadoc)
-		 * @see java.lang.Object#equals(java.lang.Object)
-		 */
-		@Override
-		public boolean equals(Object obj) {
-			boolean equal = false;
-			
-			if(obj instanceof LocalRemoteAddressPair) {
-				LocalRemoteAddressPair o = (LocalRemoteAddressPair)obj;
-				
-				equal = (this.local.equals(o.local) && this.remote.equals(o.remote));
-			}
-			return equal;
-		}
+        private InetSocketAddress local;
 
-		/* (non-Javadoc)
-		 * @see java.lang.Object#hashCode()
-		 */
-		@Override
-		public int hashCode() {
-			return (this.local.hashCode() ^ this.remote.hashCode());
-		}
-		
-		
-	}
-	
-	protected static final String ATTR = Track.class.toString() + "Attr";
+        private InetSocketAddress remote;
 
-	/** Maps a client address to a Track */
-	protected static Map<InetSocketAddress, Track> clientAddressMap = new ConcurrentHashMap<InetSocketAddress, Track>();
+        public LocalRemoteAddressPair( InetSocketAddress local, InetSocketAddress remote )
+        {
+            this.local = local;
+            this.remote = remote;
+        }
 
-	/** Maps a server address to a Track */
-	protected static Map<InetSocketAddress, Track> serverAddressMap = new ConcurrentHashMap<InetSocketAddress, Track>();
+        /*
+         * (non-Javadoc)
+         * 
+         * @see java.lang.Object#equals(java.lang.Object)
+         */
+        @Override
+        public boolean equals( Object obj )
+        {
+            boolean equal = false;
 
-	/** Maps a local server address/port and a remote address/port to a Track */
-	protected static Map<LocalRemoteAddressPair, Track> localRemoteServerAddressMap = 
-		new ConcurrentHashMap<LocalRemoteAddressPair, Track>();
-	
-	/**
-	 * Control Url of the track. This is the url handle given by the server to
-	 * control different tracks in a RTSP session.
-	 */
-	protected String url;
+            if ( obj instanceof LocalRemoteAddressPair ) {
+                LocalRemoteAddressPair o = (LocalRemoteAddressPair) obj;
 
-	/**
-	 * IP address of client and server.
-	 * <p>
-	 * TODO: When using reflection, there will be more than one connected client
-	 * at a time to the same Track. So the track should keep a list of connected
-	 * clients and forward packets to each of them.
-	 */
-	protected InetAddress clientAddress;
+                equal = (this.local.equals( o.local ) && this.remote.equals( o.remote ));
+            }
+            return equal;
+        }
 
-	protected InetAddress serverAddress;
+        /*
+         * (non-Javadoc)
+         * 
+         * @see java.lang.Object#hashCode()
+         */
+        @Override
+        public int hashCode()
+        {
+            return (this.local.hashCode() ^ this.remote.hashCode());
+        }
 
-	/**
-	 * Construct a new Track.
-	 * 
-	 * @param url
-	 *            the control name for this track.
-	 */
-	public Track( String url )
-	{
-		this.url = url;
-	}
+    }
 
-	/**
-	 * Get the track by looking at client socket address.
-	 * 
-	 * @return a Track instance if a matching pair is found or null
-	 */
-	public static Track getByClientAddress( InetSocketAddress clientAddress )
-	{
-		return clientAddressMap.get( clientAddress );
-	}
+    protected static final String ATTR = Track.class.toString() + "Attr";
 
-	/**
-	 * Get the track by looking at server socket address.
-	 * <p>
-	 * Used as a workaround for streaming servers which do not hand out a ssrc
-	 * in the setup handshake.
-	 * 
-	 * @return a Track instance if a matching pair is found or null
-	 */
-	public static Track getByServerAddress( InetSocketAddress serverAddress )
-	{
-		return serverAddressMap.get( serverAddress );
-	}
+    /** Maps a client address to a Track */
+    // TODO: bring back to protected
+    public static Map<InetSocketAddress, Track> clientAddressMap = new ConcurrentHashMap<InetSocketAddress, Track>();
 
-	/**
-	 * Get the track by looking at server socket address.
-	 * <p>
-	 * Used as a workaround for streaming servers which do not hand out a ssrc
-	 * in the setup handshake.
-	 * 
-	 * @return a Track instance if a matching pair is found or null
-	 */
-	public static Track getByLocalRemoteServerAddress( InetSocketAddress localServerAddress,
-			InetSocketAddress remoteServerAddress)
-	{
-		LocalRemoteAddressPair pair = new LocalRemoteAddressPair(localServerAddress, remoteServerAddress);
-		
-		return localRemoteServerAddressMap.get( pair );
-	}
+    /** Maps a server address to a Track */
+    protected static Map<InetSocketAddress, Track> serverAddressMap = new ConcurrentHashMap<InetSocketAddress, Track>();
 
-	// /// Member methods
+    /** Maps a local server address/port and a remote address/port to a Track */
+    protected static Map<LocalRemoteAddressPair, Track> localRemoteServerAddressMap = new ConcurrentHashMap<LocalRemoteAddressPair, Track>();
 
-	public String getUrl()
-	{
-		return url;
-	}
+    /**
+     * Control Url of the track. This is the url handle given by the server to
+     * control different tracks in a RTSP session.
+     */
+    protected String url;
 
-	public void setUrl( String url )
-	{
-		this.url = url;
-	}
+    /**
+     * IP address of client and server.
+     * <p>
+     * TODO: When using reflection, there will be more than one connected client
+     * at a time to the same Track. So the track should keep a list of connected
+     * clients and forward packets to each of them.
+     */
+    protected InetAddress clientAddress;
 
-	public abstract void close();
+    protected InetAddress serverAddress;
 
-	public String toString()
-	{
-		return "Track(url=\"" + url + "\"";
-	}
+    /**
+     * Construct a new Track.
+     * 
+     * @param url
+     *            the control name for this track.
+     */
+    public Track( String url )
+    {
+        this.url = url;
+    }
+
+    /**
+     * Get the track by looking at client socket address.
+     * 
+     * @return a Track instance if a matching pair is found or null
+     */
+    public static Track getByClientAddress( InetSocketAddress clientAddress )
+    {
+        return clientAddressMap.get( clientAddress );
+    }
+
+    /**
+     * Get the track by looking at server socket address.
+     * <p>
+     * Used as a workaround for streaming servers which do not hand out a ssrc
+     * in the setup handshake.
+     * 
+     * @return a Track instance if a matching pair is found or null
+     */
+    public static Track getByServerAddress( InetSocketAddress serverAddress )
+    {
+        return serverAddressMap.get( serverAddress );
+    }
+
+    /**
+     * Get the track by looking at server socket address.
+     * <p>
+     * Used as a workaround for streaming servers which do not hand out a ssrc
+     * in the setup handshake.
+     * 
+     * @return a Track instance if a matching pair is found or null
+     */
+    public static Track getByLocalRemoteServerAddress(
+            InetSocketAddress localServerAddress, InetSocketAddress remoteServerAddress )
+    {
+        LocalRemoteAddressPair pair = new LocalRemoteAddressPair( localServerAddress,
+                remoteServerAddress );
+
+        return localRemoteServerAddressMap.get( pair );
+    }
+
+    // /// Member methods
+
+    public String getUrl()
+    {
+        return url;
+    }
+
+    public void setUrl( String url )
+    {
+        this.url = url;
+    }
+
+    public abstract void close();
+
+    @Override
+    public String toString()
+    {
+        StringBuilder sb = new StringBuilder();
+        sb.append( "Track(url=\"" );
+        sb.append( url );
+        sb.append( "\")" );
+        return sb.toString();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -7,8 +7,6 @@
 import org.apache.mina.common.IoFilterChainBuilder;
 import org.apache.mina.filter.codec.ProtocolCodecFilter;
 
-import rtspproxy.ProxyServiceRegistry;
-
 /**
  * Builds filter chain operating on RDT connection.
  * 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -191,7 +191,8 @@
 	/**
 	 * debug output
 	 */
-	public final String toString() {
+	@Override
+    public final String toString() {
 		StringBuffer buf = new StringBuffer();
 
 		buf.append("packet[id=" + id +" type=" + type);

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,271 +3,286 @@
  */
 package rtspproxy.rdt;
 
-import java.lang.reflect.Array;
-
 import org.apache.mina.common.ByteBuffer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-
 /**
  * Decoder for RDT packets.
+ * 
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  */
-public class RdtPacketDecoder {
+public class RdtPacketDecoder
+{
 
-	// logger
-	private static Logger logger = LoggerFactory.getLogger(RdtPacketDecoder.class);
-	
-	/**
-	 * not instaniable
-	 */
-	private RdtPacketDecoder() {}
-	
-	/**
-	 * decode packet
-	 * @param buffer the byte buffer to decode packet from
-	 */
-	public static RdtPacket decode(ByteBuffer buffer) {
-		byte[] data = new byte[buffer.limit()];
+    // logger
+    private static Logger log = LoggerFactory.getLogger( RdtPacketDecoder.class );
 
-		// copy buffer content into temp array
-		buffer.rewind();
-		buffer.get(data);
+    /**
+     * not instaniable
+     */
+    private RdtPacketDecoder()
+    {
+    }
 
-		return decode(data, 0);
-	}
+    /**
+     * decode packet
+     * 
+     * @param buffer
+     *            the byte buffer to decode packet from
+     */
+    public static RdtPacket decode( ByteBuffer buffer )
+    {
+        byte[] data = new byte[buffer.limit()];
 
-	/**
-	 * decode packet
-	 * @param buffer the byte buffer to decode packet from
-	 */
-	public static RdtPacket decode(byte[] data, int ind) {
-		RdtPacket packet = null;
-		byte markerByte;
-		byte seqLo, seqHi;
-		short sequence;
-		boolean lengthIncluded = false;
-		short packetLength = -1;
-		int payloadSize = -1;
+        // copy buffer content into temp array
+        buffer.rewind();
+        buffer.get( data );
 
-		/*
-		if(logger.isDebugEnabled()) 
-			logger.debug("decoding packet data: " + formatByteArray(data));
-		*/
-		
-		// process marker byte
-		markerByte = data[ind++];
-		lengthIncluded = ((markerByte & (1<<7)) > 0);
+        return decode( data, 0 );
+    }
 
-		// process sequence / type field
-		seqHi = data[ind++];
-		seqLo = data[ind++];
-		sequence = decodeShort(seqHi, seqLo);
-		logger.debug("decoded sequence: " + Integer.toHexString(sequence));
-		
-		if((seqHi & 0xff) == 0xff ) {
-			logger.debug("decoding control packet");
+    /**
+     * decode packet
+     * 
+     * @param buffer
+     *            the byte buffer to decode packet from
+     */
+    public static RdtPacket decode( byte[] data, int ind )
+    {
+        RdtPacket packet = null;
+        byte markerByte;
+        byte seqLo, seqHi;
+        short sequence;
+        boolean lengthIncluded = false;
+        short packetLength = -1;
+        int payloadSize = -1;
 
-			// extract streamid from marker byte
-			byte streamId = (byte)((markerByte & 0x7c) >> 2);
+        /*
+         * if(logger.isDebugEnabled()) logger.debug("decoding packet data: {}",
+         * formatByteArray(data));
+         */
 
-			// control packet
-			RdtPacket.Type type = RdtPacket.Type.fromCode(sequence);
-			
-			switch(type) {
-			case RttRequest:
-				// process packet length (if included)
-				if(lengthIncluded) {
-					packetLength = (short)(decodeShort(data, ind) - 5);
-					ind += 2;
-				}
-				
-				packet = new RdtRttRequestPacket();
-				break;
-			case RttResponse:
-				// process packet length (if included)
-				if(lengthIncluded) {
-					packetLength = (short)(decodeShort(data, ind) - 5);
-					ind += 2;
-				}
-				
-				int roundtripTimestampSeconds = decodeInt(data, ind);
-				int roundtripTimestampMicroeconds = decodeInt(data, ind+4);
-				
-				ind += 8;
-				packet = new RdtRttResponsePacket(roundtripTimestampSeconds, roundtripTimestampMicroeconds);
-				
-				payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
-				
-				if(payloadSize > 0)
-					ind = attachPayload(packet, data, ind, payloadSize);
-				
-				break;
-			case LatencyReport:
-				// process packet length (if included)
-				if(lengthIncluded) {
-					packetLength = (short)(decodeShort(data, ind) - 5);
-					ind += 2;
-				}
-				
-				int serverTimeout = decodeInt(data, ind);
-				ind += 4;
-				if(lengthIncluded)
-					packetLength -= 4;
-				packet = new RdtLatencyReportPacket(serverTimeout);
-				break;
-			case Ack:
-				// process packet length (if included)
-				if(lengthIncluded) {
-					packetLength = (short)(decodeShort(data, ind) -  5);
-					ind += 2;
-				}
-				
-				boolean lostHigh = ((markerByte & (1<<6)) > 0);
-				payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
+        // process marker byte
+        markerByte = data[ind++];
+        lengthIncluded = ((markerByte & (1 << 7)) > 0);
 
-				packet = new RdtAckPacket(lostHigh);
-				if(payloadSize > 0)
-					ind = attachPayload(packet, data, ind, payloadSize);
-				
-				break;
-			case StreamEnd:
-				// in the stream end packet, the length-included serves as need reliable field
-				boolean packetSent = ((markerByte & (1<<1)) > 0);
-				boolean extFlag = ((markerByte & (1<<0)) > 0);
-				short streamEndSequenceNumber = decodeShort(data, ind);
-				int timeout = decodeInt(data, ind+2);
-				short totalReliable = decodeShort(data, ind+6);
-				
-				ind += 8;
-				
-				// length included servers as need reliable (speical case)
-				packet = new RdtStreamEndPacket(lengthIncluded, streamId, packetSent, extFlag, 
-						streamEndSequenceNumber, timeout, totalReliable);
-				
-				payloadSize = (data.length - ind);
-				if(payloadSize > 0)
-					ind = attachPayload(packet, data, ind, payloadSize);
-				break;
-			default:
-				logger.error("unknown control packet received, code=" + sequence 
-						+ ", full packet dump: " + formatByteArray(data));
-			}
-		} else {
-			logger.debug("decoding data packet");
-			
-			// data packet
-			// process packet length (if included)
-			if(lengthIncluded) {
-				packetLength = (short)(decodeShort(data, ind) - 5);
-				ind += 2;
-			}
-			
-			// process marker byte
-			boolean needReliable = ((markerByte & (1<<6)) > 0);
-			boolean isReliable = ((markerByte & (1<<0)) > 0);
-			byte streamId = (byte)((markerByte & 0x3e) >> 1);
-			
-			// process next control byte
-			if(lengthIncluded)
-				packetLength--;
-			byte controlByte = data[ind++];
-			boolean backToBack = ((controlByte & (1<<7)) > 0);
-			boolean slowData = ((controlByte & (1<<6)) > 0);
-			byte asmRule = (byte)(controlByte & 0x3f);
-			
-			// process timestamp
-			if(lengthIncluded)
-				packetLength -= 4;
-			int timestamp = decodeInt(data, ind);
-			ind += 4;
-			
-			// process total reliable count
-			/*
-			if(lengthIncluded)
-				packetLength -= 2;
-				*/
-			packet = new RdtDataPacket(lengthIncluded, needReliable, isReliable, streamId,
-					sequence, backToBack, slowData, asmRule, timestamp);
-			if(needReliable) {
-				short totalReliable = decodeShort(data, ind);
+        // process sequence / type field
+        seqHi = data[ind++];
+        seqLo = data[ind++];
+        sequence = decodeShort( seqHi, seqLo );
+        log.debug( "decoded sequence: {}", Integer.toHexString( sequence ) );
 
-				ind += 2;
-				if(lengthIncluded)
-					packetLength -= 2;
-				((RdtDataPacket)packet).setTotalReliable(totalReliable);
-			}
+        if ( (seqHi & 0xff) == 0xff ) {
+            log.debug( "decoding control packet" );
 
-			payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
-			if(payloadSize > 0)
-				ind = attachPayload(packet, data, ind, payloadSize);
-		}
-		
-		if(ind != data.length) {
-			// handle attached subpacket
-			logger.debug("handling attached sub-packet");
-			
-			packet.setSubPacket(decode(data, ind));
-		}
-		
-		if(logger.isDebugEnabled())
-			logger.debug("decoded packet: " + packet);
-		
-		return packet;
-	}
-	
-	/**
-	 * attach payload to packet
-	 */
-	private static int attachPayload(RdtPacket packet, byte[] data, int ind, int size) {
-		byte[] buf = new byte[size];
-		
-		System.arraycopy(data, ind, buf, 0, size);
-		packet.setPayload(buf);
-		
-		return (ind + size);
-	}
-	
-	/**
-	 * decode a short from a byte array
-	 */
-	private static final short decodeShort(byte[] bytes, int ind) {
-		return decodeShort(bytes[ind], bytes[ind+1]);
-	}
+            // extract streamid from marker byte
+            byte streamId = (byte) ((markerByte & 0x7c) >> 2);
 
-	private static final short decodeShort(byte hi, byte lo) {
-		return (short)((hi & 0xff) * 256 + (lo & 0xff));
-	}
-	
-	/**
-	 * decode an int 
-	 */
-	private static final int decodeInt(byte[] bytes, int ind) {
-		return decodeInt(bytes[ind], bytes[ind+1], bytes[ind+2], bytes[ind+3]);
-	}
-	
-	private static final int decodeInt(byte b3, byte b2, byte b1, byte b0) {
-		return ((b3 & 0xff) * 16777216) + ((b2 & 0xff) * 65536) + ((b1 & 0xff) * 256) + (b0 & 0xff);
-	}
+            // control packet
+            RdtPacket.Type type = RdtPacket.Type.fromCode( sequence );
 
-	private static final char[] digits = new char[] { 
-		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
-		'a', 'b', 'c', 'd', 'e', 'f'
-	};
-	private static final String formatByteArray(byte[] data) {
-		StringBuffer buf = new StringBuffer();
-		
-		for(int i=0; i<data.length; i++) {
-			if((i % 16) == 0)
-				buf.append('\n');
-			
-			buf.append(digits[(data[i] & 0xff) / 16]);
-			buf.append(digits[(data[i] & 0xff) % 16]);
-			if((i % 16) != 0)
-				buf.append(' ');
-		}
- 		
-		return buf.toString();
-	}
+            switch ( type )
+            {
+            case RttRequest:
+                // process packet length (if included)
+                if ( lengthIncluded ) {
+                    packetLength = (short) (decodeShort( data, ind ) - 5);
+                    ind += 2;
+                }
+
+                packet = new RdtRttRequestPacket();
+                break;
+            case RttResponse:
+                // process packet length (if included)
+                if ( lengthIncluded ) {
+                    packetLength = (short) (decodeShort( data, ind ) - 5);
+                    ind += 2;
+                }
+
+                int roundtripTimestampSeconds = decodeInt( data, ind );
+                int roundtripTimestampMicroeconds = decodeInt( data, ind + 4 );
+
+                ind += 8;
+                packet = new RdtRttResponsePacket( roundtripTimestampSeconds,
+                        roundtripTimestampMicroeconds );
+
+                payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
+
+                if ( payloadSize > 0 )
+                    ind = attachPayload( packet, data, ind, payloadSize );
+
+                break;
+            case LatencyReport:
+                // process packet length (if included)
+                if ( lengthIncluded ) {
+                    packetLength = (short) (decodeShort( data, ind ) - 5);
+                    ind += 2;
+                }
+
+                int serverTimeout = decodeInt( data, ind );
+                ind += 4;
+                if ( lengthIncluded )
+                    packetLength -= 4;
+                packet = new RdtLatencyReportPacket( serverTimeout );
+                break;
+            case Ack:
+                // process packet length (if included)
+                if ( lengthIncluded ) {
+                    packetLength = (short) (decodeShort( data, ind ) - 5);
+                    ind += 2;
+                }
+
+                boolean lostHigh = ((markerByte & (1 << 6)) > 0);
+                payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
+
+                packet = new RdtAckPacket( lostHigh );
+                if ( payloadSize > 0 )
+                    ind = attachPayload( packet, data, ind, payloadSize );
+
+                break;
+            case StreamEnd:
+                // in the stream end packet, the length-included serves as need
+                // reliable field
+                boolean packetSent = ((markerByte & (1 << 1)) > 0);
+                boolean extFlag = ((markerByte & (1 << 0)) > 0);
+                short streamEndSequenceNumber = decodeShort( data, ind );
+                int timeout = decodeInt( data, ind + 2 );
+                short totalReliable = decodeShort( data, ind + 6 );
+
+                ind += 8;
+
+                // length included servers as need reliable (speical case)
+                packet = new RdtStreamEndPacket( lengthIncluded, streamId, packetSent,
+                        extFlag, streamEndSequenceNumber, timeout, totalReliable );
+
+                payloadSize = (data.length - ind);
+                if ( payloadSize > 0 )
+                    ind = attachPayload( packet, data, ind, payloadSize );
+                break;
+            default:
+                log.error(
+                        "unknown control packet received, code={}, full packet dump: {}",
+                        sequence, formatByteArray( data ) );
+            }
+        } else {
+            log.debug( "decoding data packet" );
+
+            // data packet
+            // process packet length (if included)
+            if ( lengthIncluded ) {
+                packetLength = (short) (decodeShort( data, ind ) - 5);
+                ind += 2;
+            }
+
+            // process marker byte
+            boolean needReliable = ((markerByte & (1 << 6)) > 0);
+            boolean isReliable = ((markerByte & (1 << 0)) > 0);
+            byte streamId = (byte) ((markerByte & 0x3e) >> 1);
+
+            // process next control byte
+            if ( lengthIncluded )
+                packetLength--;
+            byte controlByte = data[ind++];
+            boolean backToBack = ((controlByte & (1 << 7)) > 0);
+            boolean slowData = ((controlByte & (1 << 6)) > 0);
+            byte asmRule = (byte) (controlByte & 0x3f);
+
+            // process timestamp
+            if ( lengthIncluded )
+                packetLength -= 4;
+            int timestamp = decodeInt( data, ind );
+            ind += 4;
+
+            // process total reliable count
+            /*
+             * if(lengthIncluded) packetLength -= 2;
+             */
+            packet = new RdtDataPacket( lengthIncluded, needReliable, isReliable,
+                    streamId, sequence, backToBack, slowData, asmRule, timestamp );
+            if ( needReliable ) {
+                short totalReliable = decodeShort( data, ind );
+
+                ind += 2;
+                if ( lengthIncluded )
+                    packetLength -= 2;
+                ((RdtDataPacket) packet).setTotalReliable( totalReliable );
+            }
+
+            payloadSize = (lengthIncluded ? packetLength : (data.length - ind));
+            if ( payloadSize > 0 )
+                ind = attachPayload( packet, data, ind, payloadSize );
+        }
+
+        if ( ind != data.length ) {
+            // handle attached subpacket
+            log.debug( "handling attached sub-packet" );
+
+            packet.setSubPacket( decode( data, ind ) );
+        }
+
+        log.debug( "decoded packet: {}", packet );
+
+        return packet;
+    }
+
+    /**
+     * attach payload to packet
+     */
+    private static int attachPayload( RdtPacket packet, byte[] data, int ind, int size )
+    {
+        byte[] buf = new byte[size];
+
+        System.arraycopy( data, ind, buf, 0, size );
+        packet.setPayload( buf );
+
+        return (ind + size);
+    }
+
+    /**
+     * decode a short from a byte array
+     */
+    private static final short decodeShort( byte[] bytes, int ind )
+    {
+        return decodeShort( bytes[ind], bytes[ind + 1] );
+    }
+
+    private static final short decodeShort( byte hi, byte lo )
+    {
+        return (short) ((hi & 0xff) * 256 + (lo & 0xff));
+    }
+
+    /**
+     * decode an int
+     */
+    private static final int decodeInt( byte[] bytes, int ind )
+    {
+        return decodeInt( bytes[ind], bytes[ind + 1], bytes[ind + 2], bytes[ind + 3] );
+    }
+
+    private static final int decodeInt( byte b3, byte b2, byte b1, byte b0 )
+    {
+        return ((b3 & 0xff) * 16777216) + ((b2 & 0xff) * 65536) + ((b1 & 0xff) * 256)
+                + (b0 & 0xff);
+    }
+
+    private static final char[] digits = new char[] { '0', '1', '2', '3', '4', '5', '6',
+            '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+    private static final String formatByteArray( byte[] data )
+    {
+        StringBuffer buf = new StringBuffer();
+
+        for ( int i = 0; i < data.length; i++ ) {
+            if ( (i % 16) == 0 )
+                buf.append( '\n' );
+
+            buf.append( digits[(data[i] & 0xff) / 16] );
+            buf.append( digits[(data[i] & 0xff) % 16] );
+            if ( (i % 16) != 0 )
+                buf.append( ' ' );
+        }
+
+        return buf.toString();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -9,165 +9,184 @@
 import javax.management.ObjectName;
 
 import org.apache.mina.common.IoSession;
+import org.apache.mina.transport.socket.nio.DatagramAcceptor;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import rtspproxy.transport.socket.nio.DatagramAcceptor;
-
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public class PortrangeRtpServerSession {
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory
-			.getLogger(PortrangeRtpServerSession.class);
-		
-	// session attribute name
-	public static final String ATTR = PortrangeRtpServerSession.class.getName() + ".ATTR";
-	
-	// connection number
-	private int connectionNumber;
-	
-	// flag if session is passive
-	private boolean activeIfTrue;
-	
-	// time when object was passivated
-	private long lastPassiveCheckpoint; 
-	
-	// RTP acceptor
-	private DatagramAcceptor rtpAcceptor;
-	
-	// RTP socket address
-	private InetSocketAddress rtpSockAddr;
-	
-	// RCTP acceptor
-	private DatagramAcceptor rtcpAcceptor;
-	
-	// RTCP socket address
-	private InetSocketAddress rtcpSockAddr;
-	
-	// opened sessions
-	private LinkedList<IoSession> openSessions = new LinkedList<IoSession>();
-	
-	// MBean name
-	private ObjectName objectName;
-	
-	/**
-	 * create a sever session
-	 */
-	PortrangeRtpServerSession(int conNum) {
-		this.connectionNumber = conNum;
-	}
+public class PortrangeRtpServerSession
+{
 
-	public void setLocalBinding(DatagramAcceptor rtpAcceptor, InetSocketAddress rtpSockAddr, 
-			DatagramAcceptor rtcpAcceptor, InetSocketAddress rtcpSockAddr) {
-		this.rtpAcceptor = rtpAcceptor;
-		this.rtpSockAddr = rtpSockAddr;
-		this.rtcpAcceptor = rtcpAcceptor;
-		this.rtcpSockAddr = rtcpSockAddr;
-	}
-	
-	/**
-	 * get the RTP port number
-	 */
-	public int getRtpPort() {
-		return this.rtpSockAddr.getPort();
-	}
+    /**
+     * Logger for this class
+     */
+    private static Logger log = LoggerFactory.getLogger( PortrangeRtpServerSession.class );
 
-	/**
-	 * get the RTP port number
-	 */
-	public int getRtcpPort() {
-		return this.rtcpSockAddr.getPort();
-	}
+    // session attribute name
+    public static final String ATTR = PortrangeRtpServerSession.class.getName() + ".ATTR";
 
-	/**
-	 * get the connection number
-	 */
-	public int getConnectionNumber() {
-		return this.connectionNumber;
-	}
+    // connection number
+    private int connectionNumber;
 
-	void unbind() {
-		this.rtpAcceptor.unbind(this.rtpSockAddr);
-		this.rtcpAcceptor.unbind(this.rtcpSockAddr);
-	}
+    // flag if session is passive
+    private boolean activeIfTrue;
 
-	void closeOpenSessions() {
-			for (IoSession session : this.openSessions)
-			session.close();
-		this.openSessions.clear();
-	}
-	
-	public IoSession newRtpSession(InetSocketAddress remote) {
-		IoSession session = this.rtpAcceptor.newSession(remote, this.rtpSockAddr);
-		
-		logger.debug("opened new RTP session to " + remote);
-		this.openSessions.add(session);
-		
-		return session;
-	}
+    // time when object was passivated
+    private long lastPassiveCheckpoint;
 
-	public IoSession newRtcpSession(InetSocketAddress remote) {
-		IoSession session = this.rtcpAcceptor.newSession(remote, this.rtcpSockAddr);
+    // RTP acceptor
+    private DatagramAcceptor rtpAcceptor;
 
-		logger.debug("opened new RTCP session to " + remote);
-		this.openSessions.add(session);
-		
-		return session;
-	}
+    // RTP socket address
+    private InetSocketAddress rtpSockAddr;
 
-	void setActive(boolean state) {
-		this.activeIfTrue = state;
-		
-		if(!this.activeIfTrue)
-			this.lastPassiveCheckpoint = System.currentTimeMillis();
-	}
+    // RCTP acceptor
+    private DatagramAcceptor rtcpAcceptor;
 
-	/**
-	 * @return Returns the lastPassiveCheckpoint.
-	 */
-	public long getLastPassiveCheckpoint() {
-		return lastPassiveCheckpoint;
-	}
+    // RTCP socket address
+    private InetSocketAddress rtcpSockAddr;
 
-	public boolean isActive() {
-		return this.activeIfTrue;
-	}
+    // opened sessions
+    private LinkedList<IoSession> openSessions = new LinkedList<IoSession>();
 
-	/**
-	 * @return Returns the rtpSockAddr.
-	 */
-	public InetSocketAddress getRtpSocketAddress() {
-		return rtpSockAddr;
-	}
+    // MBean name
+    private ObjectName objectName;
 
-	/**
-	 * @return Returns the rtpSockAddr.
-	 */
-	public InetSocketAddress getRtcpSocketAddress() {
-		return rtcpSockAddr;
-	}
+    /**
+     * create a sever session
+     */
+    PortrangeRtpServerSession( int conNum )
+    {
+        this.connectionNumber = conNum;
+    }
 
-	/**
-	 * @return Returns the objectName.
-	 */
-	public ObjectName getObjectName() {
-		return objectName;
-	}
+    public void setLocalBinding( DatagramAcceptor rtpAcceptor,
+            InetSocketAddress rtpSockAddr, DatagramAcceptor rtcpAcceptor,
+            InetSocketAddress rtcpSockAddr )
+    {
+        this.rtpAcceptor = rtpAcceptor;
+        this.rtpSockAddr = rtpSockAddr;
+        this.rtcpAcceptor = rtcpAcceptor;
+        this.rtcpSockAddr = rtcpSockAddr;
+    }
 
-	/**
-	 * @param objectName The objectName to set.
-	 */
-	public void setObjectName(ObjectName objectName) {
-		this.objectName = objectName;
-	}
+    /**
+     * get the RTP port number
+     */
+    public int getRtpPort()
+    {
+        return this.rtpSockAddr.getPort();
+    }
 
-	public int getNumOpenSessions() {
-		return this.openSessions.size();
-	}
+    /**
+     * get the RTP port number
+     */
+    public int getRtcpPort()
+    {
+        return this.rtcpSockAddr.getPort();
+    }
 
+    /**
+     * get the connection number
+     */
+    public int getConnectionNumber()
+    {
+        return this.connectionNumber;
+    }
+
+    void unbind()
+    {
+        this.rtpAcceptor.unbind( this.rtpSockAddr );
+        this.rtcpAcceptor.unbind( this.rtcpSockAddr );
+    }
+
+    void closeOpenSessions()
+    {
+        for ( IoSession session : this.openSessions )
+            session.close();
+        this.openSessions.clear();
+    }
+
+    public IoSession newRtpSession( InetSocketAddress remote )
+    {
+        IoSession session = this.rtpAcceptor.newSession( remote, this.rtpSockAddr );
+
+        log.debug( "opened new RTP session to {}", remote );
+        this.openSessions.add( session );
+
+        return session;
+    }
+
+    public IoSession newRtcpSession( InetSocketAddress remote )
+    {
+        IoSession session = this.rtcpAcceptor.newSession( remote, this.rtcpSockAddr );
+
+        log.debug( "opened new RTCP session to {}", remote );
+        this.openSessions.add( session );
+
+        return session;
+    }
+
+    void setActive( boolean state )
+    {
+        this.activeIfTrue = state;
+
+        if ( !this.activeIfTrue )
+            this.lastPassiveCheckpoint = System.currentTimeMillis();
+    }
+
+    /**
+     * @return Returns the lastPassiveCheckpoint.
+     */
+    public long getLastPassiveCheckpoint()
+    {
+        return lastPassiveCheckpoint;
+    }
+
+    public boolean isActive()
+    {
+        return this.activeIfTrue;
+    }
+
+    /**
+     * @return Returns the rtpSockAddr.
+     */
+    public InetSocketAddress getRtpSocketAddress()
+    {
+        return rtpSockAddr;
+    }
+
+    /**
+     * @return Returns the rtpSockAddr.
+     */
+    public InetSocketAddress getRtcpSocketAddress()
+    {
+        return rtcpSockAddr;
+    }
+
+    /**
+     * @return Returns the objectName.
+     */
+    public ObjectName getObjectName()
+    {
+        return objectName;
+    }
+
+    /**
+     * @param objectName
+     *            The objectName to set.
+     */
+    public void setObjectName( ObjectName objectName )
+    {
+        this.objectName = objectName;
+    }
+
+    public int getNumOpenSessions()
+    {
+        return this.openSessions.size();
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -5,11 +5,9 @@
 
 import java.io.IOException;
 import java.net.InetAddress;
-import java.util.NoSuchElementException;
 import java.util.Observable;
 import java.util.Observer;
 
-import org.apache.commons.pool.PoolableObjectFactory;
 import org.apache.commons.pool.impl.GenericObjectPool;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -21,144 +19,165 @@
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public class PortrangeRtpServerSessionFactory extends Singleton implements Observer {
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory
-			.getLogger(PortrangeRtpServerSessionFactory.class);
-	
-	// connection pool
-	private GenericObjectPool pool;
-	
-	// local addr
-	private InetAddress localAddress;
-	
-	/**
-	 * constructor 
-	 */
-	public PortrangeRtpServerSessionFactory() {
-		
-	}
-	
-	/**
-	 * get the singleton instance
-	 */
-	public static PortrangeRtpServerSessionFactory getInstance() {
-		return (PortrangeRtpServerSessionFactory)Singleton.getInstance(PortrangeRtpServerSessionFactory.class);
-	}
-	
-	/**
-	 * get a RTP server session
-	 */
-	public PortrangeRtpServerSession getSession() throws IOException {
-		try {
-			return (PortrangeRtpServerSession)this.pool.borrowObject();
-		} catch(Exception e) {
-			logger.info("failed to obtain RTP server session", e);
-			
-			throw new IOException("cant obtain RTP server session");
-		}
-	}
-	
-	/**
-	 * release a server session
-	 */
-	public void releaseSession(PortrangeRtpServerSession session) {
-		try {
-			session.closeOpenSessions();
-			this.pool.returnObject(session);
-		} catch(Exception e) {
-			logger.info("failed to release session", e);
-		}
-	}
-	
-	/**
-	 * initialise the factory
-	 */
-	public void start() throws Exception {
-		if(Config.proxyServerRtpMultiplePorts.getValue()) {
-			int minPort = Config.proxyServerRtpMinPort.getValue();
-			int maxPort = Config.proxyServerRtpMaxPort.getValue();
-			int rtpSessionIdleTimeout = Config.proxyServerRtpIdleTimeout.getValue();
-			int poolSize = Config.proxyServerRtpThreadPoolSize.getValue();
-			int idleScanInterval = Config.proxyServerRtpIdleScanInterval.getValue() * 1000;
-			
-			if(minPort <= 0 || minPort >= 65536)
-				throw new IllegalArgumentException("RTP min port out of range: " + minPort);
-			if(maxPort <= 0 || maxPort >= 65536)
-				throw new IllegalArgumentException("RTP max port out of range: " + maxPort);
-			
-			minPort = minPort + (minPort % 2);
-			maxPort = maxPort - (maxPort % 2);
-			logger.debug("RTP min port=" + minPort + ", max port=" + maxPort);
-			
-			if(minPort >= maxPort)
-				throw new IllegalArgumentException("RTP min port too high, min=" + minPort + ", max=" + maxPort);
-			int maxConn = (maxPort -minPort) / 2;
-			
-			GenericObjectPool.Config config = new GenericObjectPool.Config();
-			
-			config.maxActive = maxConn;
-			config.maxIdle = maxConn / 2;
-			config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
-			config.testOnBorrow = false;
-			config.testOnReturn = false;
-			config.testWhileIdle = true;
-			config.minEvictableIdleTimeMillis = rtpSessionIdleTimeout*1000;
-			config.timeBetweenEvictionRunsMillis = idleScanInterval;
-			
-			this.pool = new GenericObjectPool(new RtpServerSessionFactory(this.localAddress, minPort, maxConn,
-					rtpSessionIdleTimeout, poolSize), config);
-			
-			Config.proxyServerRtpIdleScanInterval.addObserver(this);
-			Config.proxyServerRtpIdleTimeout.addObserver(this);
-			
-			JmxAgent.getInstance().registerPortRangeRtpServerSessionfactory(this);
-		}
-	}
-	
-	/**
-	 * shutdown the session factory
-	 */
-	public void stop() {
-		if(Config.proxyServerRtpMultiplePorts.getValue()) {
-			try {
-				this.pool.close();
-			} catch(Exception e) {
-				logger.info("exception while closing RTP port pool", e);
-			}
-			
-			JmxAgent.getInstance().unregisterPortRangeRtpServerSessionfactory();
-		}		
-	}
+public class PortrangeRtpServerSessionFactory extends Singleton implements Observer
+{
 
-	public void setLocalAddress(InetAddress address) {
-		this.localAddress = address;
-	}
+    /**
+     * Logger for this class
+     */
+    private final Logger log = LoggerFactory
+            .getLogger( PortrangeRtpServerSessionFactory.class );
 
-	public void update(Observable o, Object arg) {
-		if(o instanceof Parameter) {
-			Parameter p = (Parameter)o;
-			
-			if(p.equals(Config.proxyServerRtpIdleScanInterval))
-				this.pool.setTimeBetweenEvictionRunsMillis(Config.proxyServerRtpIdleScanInterval.getValue());
-			else if(p.equals(Config.proxyServerRtpIdleTimeout))
-				this.pool.setMinEvictableIdleTimeMillis(Config.proxyServerRtpIdleTimeout.getValue() * 1000);
-		}
-	}
+    // connection pool
+    private GenericObjectPool pool;
 
-	public int getMaxConnections() {
-		return this.pool.getMaxActive();
-	}
+    // local addr
+    private InetAddress localAddress;
 
-	public int getCurrentIdleConnections() {
-		return this.pool.getNumIdle();
-	}
+    /**
+     * constructor
+     */
+    public PortrangeRtpServerSessionFactory()
+    {
 
-	public int getCurrentActiveConnections() {
-		return this.pool.getNumActive();
-	}
+    }
+
+    /**
+     * get the singleton instance
+     */
+    public static PortrangeRtpServerSessionFactory getInstance()
+    {
+        return (PortrangeRtpServerSessionFactory) Singleton
+                .getInstance( PortrangeRtpServerSessionFactory.class );
+    }
+
+    /**
+     * get a RTP server session
+     */
+    public PortrangeRtpServerSession getSession() throws IOException
+    {
+        try {
+            return (PortrangeRtpServerSession) this.pool.borrowObject();
+        } catch ( Exception e ) {
+            log.info( "failed to obtain RTP server session", e );
+
+            throw new IOException( "cant obtain RTP server session" );
+        }
+    }
+
+    /**
+     * release a server session
+     */
+    public void releaseSession( PortrangeRtpServerSession session )
+    {
+        try {
+            session.closeOpenSessions();
+            this.pool.returnObject( session );
+        } catch ( Exception e ) {
+            log.info( "failed to release session", e );
+        }
+    }
+
+    /**
+     * initialise the factory
+     */
+    public void start() throws Exception
+    {
+        if ( Config.proxyServerRtpMultiplePorts.getValue() ) {
+            int minPort = Config.proxyServerRtpMinPort.getValue();
+            int maxPort = Config.proxyServerRtpMaxPort.getValue();
+            int rtpSessionIdleTimeout = Config.proxyServerRtpIdleTimeout.getValue();
+            int poolSize = Config.proxyServerRtpThreadPoolSize.getValue();
+            int idleScanInterval = Config.proxyServerRtpIdleScanInterval.getValue() * 1000;
+
+            if ( minPort <= 0 || minPort >= 65536 )
+                throw new IllegalArgumentException( "RTP min port out of range: "
+                        + minPort );
+            if ( maxPort <= 0 || maxPort >= 65536 )
+                throw new IllegalArgumentException( "RTP max port out of range: "
+                        + maxPort );
+
+            minPort = minPort + (minPort % 2);
+            maxPort = maxPort - (maxPort % 2);
+            log.debug( "RTP min port={}, max port={}", minPort, maxPort );
+
+            if ( minPort >= maxPort )
+                throw new IllegalArgumentException( "RTP min port too high, min="
+                        + minPort + ", max=" + maxPort );
+            int maxConn = (maxPort - minPort) / 2;
+
+            GenericObjectPool.Config config = new GenericObjectPool.Config();
+
+            config.maxActive = maxConn;
+            config.maxIdle = maxConn / 2;
+            config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
+            config.testOnBorrow = false;
+            config.testOnReturn = false;
+            config.testWhileIdle = true;
+            config.minEvictableIdleTimeMillis = rtpSessionIdleTimeout * 1000;
+            config.timeBetweenEvictionRunsMillis = idleScanInterval;
+
+            this.pool = new GenericObjectPool(
+                    new RtpServerSessionFactory( this.localAddress, minPort, maxConn,
+                            rtpSessionIdleTimeout, poolSize ), config );
+
+            Config.proxyServerRtpIdleScanInterval.addObserver( this );
+            Config.proxyServerRtpIdleTimeout.addObserver( this );
+
+            JmxAgent.getInstance().registerPortRangeRtpServerSessionfactory( this );
+        }
+    }
+
+    /**
+     * shutdown the session factory
+     */
+    public void stop()
+    {
+        if ( Config.proxyServerRtpMultiplePorts.getValue() ) {
+            try {
+                this.pool.close();
+            } catch ( Exception e ) {
+                log.info( "exception while closing RTP port pool", e );
+            }
+
+            JmxAgent.getInstance().unregisterPortRangeRtpServerSessionfactory();
+        }
+    }
+
+    public void setLocalAddress( InetAddress address )
+    {
+        this.localAddress = address;
+    }
+
+    public void update( Observable o, Object arg )
+    {
+        if ( o instanceof Parameter ) {
+            Parameter p = (Parameter) o;
+
+            if ( p.equals( Config.proxyServerRtpIdleScanInterval ) )
+                this.pool
+                        .setTimeBetweenEvictionRunsMillis( Config.proxyServerRtpIdleScanInterval
+                                .getValue() );
+            else if ( p.equals( Config.proxyServerRtpIdleTimeout ) )
+                this.pool.setMinEvictableIdleTimeMillis( Config.proxyServerRtpIdleTimeout
+                        .getValue() * 1000 );
+        }
+    }
+
+    public int getMaxConnections()
+    {
+        return this.pool.getMaxActive();
+    }
+
+    public int getCurrentIdleConnections()
+    {
+        return this.pool.getNumIdle();
+    }
+
+    public int getCurrentActiveConnections()
+    {
+        return this.pool.getNumActive();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -3,9 +3,6 @@
  */
 package rtspproxy.rtp.range;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -14,173 +11,189 @@
 import java.util.Observer;
 
 import org.apache.commons.pool.PoolableObjectFactory;
+import org.apache.mina.transport.socket.nio.DatagramAcceptor;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.config.Config;
 import rtspproxy.config.Parameter;
 import rtspproxy.jmx.JmxAgent;
 import rtspproxy.proxy.ServerRtcpPacketHandler;
 import rtspproxy.proxy.ServerRtpPacketHandler;
-import rtspproxy.transport.socket.nio.DatagramAcceptor;
-import sun.security.krb5.internal.s;
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  */
-class RtpServerSessionFactory implements PoolableObjectFactory, Observer {
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory
-			.getLogger(RtpServerSessionFactory.class);
+class RtpServerSessionFactory implements PoolableObjectFactory, Observer
+{
 
-	// local bind address
-	private InetAddress localAddress;
-	
-	// mark used connections
-	private BitSet usedConnections;
-	
-	// base port (RTP)
-	private int basePort;
-	
-	// max connections
-	private int maxConnections;
-	
-	// RTP acceptor
-	private DatagramAcceptor rtpAcceptor = new DatagramAcceptor();
-	
-	// RTCP acceptor
-	private DatagramAcceptor rtcpAcceptor = new DatagramAcceptor();
+    /**
+     * Logger for this class
+     */
+    private static Logger log = LoggerFactory.getLogger( RtpServerSessionFactory.class );
 
-	// Filter chain builder
-	private RtpRtcpFilterChainBuilder chainBuilder = new RtpRtcpFilterChainBuilder();
-	
-	private long idleTimeout;
+    // local bind address
+    private InetAddress localAddress;
 
-	/**
-	 * constructor
-	 * @param address 
-	 * @param maxConn 
-	 */
-	RtpServerSessionFactory(InetAddress address, int basePort, int maxConn, long idleTimeout, int threadPoolSize) {
-		this.localAddress = address;
-		this.usedConnections = new BitSet(maxConn);
-		this.maxConnections = maxConn;
-		this.basePort = basePort;
-		this.idleTimeout = idleTimeout;
+    // mark used connections
+    private BitSet usedConnections;
 
-		this.chainBuilder.setPoolSize(threadPoolSize);
-		this.rtpAcceptor.setFilterChainBuilder(this.chainBuilder);
-		this.rtcpAcceptor.setFilterChainBuilder(this.chainBuilder);
-		
-		Config.proxyServerRtpThreadPoolSize.addObserver(this);
-		Config.proxyServerRtpIdleTimeout.addObserver(this);
-	}
+    // base port (RTP)
+    private int basePort;
 
-	public Object makeObject() throws Exception {
-		PortrangeRtpServerSession serverSession = null;
-		int nextCon = 0;
+    // max connections
+    private int maxConnections;
 
-		do {
-			nextCon = this.usedConnections.nextClearBit(0);
-			logger.debug("found next free slot at " + nextCon);
-			
-			if(nextCon >= this.maxConnections) {
-				logger.debug("failed to allocate a free slot");
-				throw new IOException("no local ports available");
-			}
-			int rtpPort = this.basePort + 2*nextCon;
-			
-			this.usedConnections.set(nextCon);
-			serverSession = new PortrangeRtpServerSession(nextCon);
-			
-			// try to bind local ports
-			InetSocketAddress rtpSockAddr = new InetSocketAddress(this.localAddress, rtpPort);
-			InetSocketAddress rtcpSockAddr = new InetSocketAddress(this.localAddress, rtpPort+1);
-			
-			boolean rtpBound = false;
-			boolean rtcpBound = false;
-			
-			try {
-				this.rtpAcceptor.bind(rtpSockAddr, new ServerRtpPacketHandler());
-				rtpBound = true;
-			} catch(IOException ie) {
-				logger.info("failed to bind RTP socket " + rtpSockAddr, ie);
-			}
-			try {
-				this.rtcpAcceptor.bind(rtcpSockAddr, new ServerRtcpPacketHandler());
-				rtcpBound = true;
-			} catch(IOException ie) {
-				logger.info("failed to bind RTCP socket " + rtpSockAddr, ie);
-			}
-			if(rtpBound == false || rtcpBound == false) {
-				logger.debug("failed to allocate RTP/RTCP port port");
-				
-				serverSession = null;
-				if(rtpBound) {
-					this.rtpAcceptor.unbind(rtpSockAddr);
-				}
-				if(rtcpBound) {
-					this.rtcpAcceptor.unbind(rtcpSockAddr);
-				}
-			} else {
-				logger.debug("allocated local port pair");
-				
-				serverSession.setLocalBinding(this.rtpAcceptor, rtpSockAddr, this.rtcpAcceptor, rtcpSockAddr);
-			}
-			
-		} while(serverSession == null);
-		
-		JmxAgent.getInstance().registerPortrangeRtpServerSession(serverSession);
-		
-		return serverSession;
-	}
+    // RTP acceptor
+    private DatagramAcceptor rtpAcceptor = new DatagramAcceptor();
 
-	public void destroyObject(Object arg0) throws Exception {
-		PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession)arg0;
-		int conNumber = serverSession.getConnectionNumber();
-		
-		logger.debug("destroying connection " + conNumber);
-		serverSession.unbind();
-		JmxAgent.getInstance().unregisterPortrangeRtpServerSession(serverSession);
-		this.usedConnections.clear(conNumber);
-	}
+    // RTCP acceptor
+    private DatagramAcceptor rtcpAcceptor = new DatagramAcceptor();
 
-	public boolean validateObject(Object arg0) {
-		boolean valid = true;
-		PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession)arg0;
-		long checkPoint = System.currentTimeMillis();
-		
-		logger.debug("checking validity for connection " + serverSession.getConnectionNumber());
-		if(!serverSession.isActive() 
-				&& (checkPoint - serverSession.getLastPassiveCheckpoint()) > (1000*this.idleTimeout)) {
-			logger.debug("connection " + serverSession.getConnectionNumber() + " timed out");
-			valid = false;
-		}
-		
-		return valid;
-	}
+    // Filter chain builder
+    private RtpRtcpFilterChainBuilder chainBuilder = new RtpRtcpFilterChainBuilder();
 
-	public void activateObject(Object arg0) throws Exception {
-		PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession)arg0;
-		
-		serverSession.setActive(true);
-	}
+    private long idleTimeout;
 
-	public void passivateObject(Object arg0) throws Exception {
-		PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession)arg0;
-		
-		serverSession.closeOpenSessions();
-		serverSession.setActive(false);
-	}
+    /**
+     * constructor
+     * 
+     * @param address
+     * @param maxConn
+     */
+    RtpServerSessionFactory( InetAddress address, int basePort, int maxConn,
+            long idleTimeout, int threadPoolSize )
+    {
+        this.localAddress = address;
+        this.usedConnections = new BitSet( maxConn );
+        this.maxConnections = maxConn;
+        this.basePort = basePort;
+        this.idleTimeout = idleTimeout;
 
-	public void update(Observable o, Object arg) {
-		if(o instanceof Parameter) {
-			Parameter p = (Parameter)o;
-			
-			if(p.equals(Config.proxyServerRtpThreadPoolSize))
-				this.chainBuilder.setPoolSize(Config.proxyServerRtpThreadPoolSize.getValue());
-			else if(p.equals(Config.proxyServerRtpIdleTimeout))
-				this.idleTimeout = Config.proxyServerRtpIdleTimeout.getValue();
-		}
-	}
+        this.chainBuilder.setPoolSize( threadPoolSize );
+        this.rtpAcceptor.setFilterChainBuilder( this.chainBuilder );
+        this.rtcpAcceptor.setFilterChainBuilder( this.chainBuilder );
+
+        Config.proxyServerRtpThreadPoolSize.addObserver( this );
+        Config.proxyServerRtpIdleTimeout.addObserver( this );
+    }
+
+    public Object makeObject() throws Exception
+    {
+        PortrangeRtpServerSession serverSession = null;
+        int nextCon = 0;
+
+        do {
+            nextCon = this.usedConnections.nextClearBit( 0 );
+            log.debug( "found next free slot at {}", nextCon );
+
+            if ( nextCon >= this.maxConnections ) {
+                log.debug( "failed to allocate a free slot" );
+                throw new IOException( "no local ports available" );
+            }
+            int rtpPort = this.basePort + 2 * nextCon;
+
+            this.usedConnections.set( nextCon );
+            serverSession = new PortrangeRtpServerSession( nextCon );
+
+            // try to bind local ports
+            InetSocketAddress rtpSockAddr = new InetSocketAddress( this.localAddress,
+                    rtpPort );
+            InetSocketAddress rtcpSockAddr = new InetSocketAddress( this.localAddress,
+                    rtpPort + 1 );
+
+            boolean rtpBound = false;
+            boolean rtcpBound = false;
+
+            try {
+                this.rtpAcceptor.bind( rtpSockAddr, new ServerRtpPacketHandler() );
+                rtpBound = true;
+            } catch ( IOException ie ) {
+                log.info( "failed to bind RTP socket {}: {}", rtpSockAddr, ie );
+            }
+            try {
+                this.rtcpAcceptor.bind( rtcpSockAddr, new ServerRtcpPacketHandler() );
+                rtcpBound = true;
+            } catch ( IOException ie ) {
+                log.info( "failed to bind RTCP socket {}: {}", rtpSockAddr, ie );
+            }
+            if ( rtpBound == false || rtcpBound == false ) {
+                log.debug( "failed to allocate RTP/RTCP port port" );
+
+                serverSession = null;
+                if ( rtpBound ) {
+                    this.rtpAcceptor.unbind( rtpSockAddr );
+                }
+                if ( rtcpBound ) {
+                    this.rtcpAcceptor.unbind( rtcpSockAddr );
+                }
+            } else {
+                log.debug( "allocated local port pair" );
+
+                serverSession.setLocalBinding( this.rtpAcceptor, rtpSockAddr,
+                        this.rtcpAcceptor, rtcpSockAddr );
+            }
+
+        } while ( serverSession == null );
+
+        JmxAgent.getInstance().registerPortrangeRtpServerSession( serverSession );
+
+        return serverSession;
+    }
+
+    public void destroyObject( Object arg0 ) throws Exception
+    {
+        PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession) arg0;
+        int conNumber = serverSession.getConnectionNumber();
+
+        log.debug( "destroying connection {}", conNumber );
+        serverSession.unbind();
+        JmxAgent.getInstance().unregisterPortrangeRtpServerSession( serverSession );
+        this.usedConnections.clear( conNumber );
+    }
+
+    public boolean validateObject( Object arg0 )
+    {
+        boolean valid = true;
+        PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession) arg0;
+        long checkPoint = System.currentTimeMillis();
+
+        log.debug( "checking validity for connection "
+                + serverSession.getConnectionNumber() );
+        if ( !serverSession.isActive()
+                && (checkPoint - serverSession.getLastPassiveCheckpoint()) > (1000 * this.idleTimeout) ) {
+            log.debug( "connection {} timed out", serverSession.getConnectionNumber() );
+            valid = false;
+        }
+
+        return valid;
+    }
+
+    public void activateObject( Object arg0 ) throws Exception
+    {
+        PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession) arg0;
+
+        serverSession.setActive( true );
+    }
+
+    public void passivateObject( Object arg0 ) throws Exception
+    {
+        PortrangeRtpServerSession serverSession = (PortrangeRtpServerSession) arg0;
+
+        serverSession.closeOpenSessions();
+        serverSession.setActive( false );
+    }
+
+    public void update( Observable o, Object arg )
+    {
+        if ( o instanceof Parameter ) {
+            Parameter p = (Parameter) o;
+
+            if ( p.equals( Config.proxyServerRtpThreadPoolSize ) )
+                this.chainBuilder.setPoolSize( Config.proxyServerRtpThreadPoolSize
+                        .getValue() );
+            else if ( p.equals( Config.proxyServerRtpIdleTimeout ) )
+                this.idleTimeout = Config.proxyServerRtpIdleTimeout.getValue();
+        }
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspCode.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspCode.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspCode.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -102,12 +102,12 @@
 	{
 		if ( description != null )
 			return description;
-		else 
-			return name();
+		
+		return name();
 	}
 	
 	/**
-	 * Try to translare a numeric RTSP status code to
+	 * Try to translate a numeric RTSP status code to
 	 * the corresponding enum value.
 	 * 
 	 * @param strCode numeric code (as a string)

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspDecoder.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspDecoder.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspDecoder.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -14,7 +14,6 @@
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
-import java.io.LineNumberReader;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.nio.CharBuffer;
@@ -22,13 +21,13 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 import org.apache.mina.common.ByteBuffer;
 import org.apache.mina.common.IoSession;
 import org.apache.mina.filter.codec.ProtocolDecoder;
 import org.apache.mina.filter.codec.ProtocolDecoderException;
 import org.apache.mina.filter.codec.ProtocolDecoderOutput;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.config.Config;
 import rtspproxy.lib.Exceptions;
@@ -39,270 +38,273 @@
 public class RtspDecoder implements ProtocolDecoder
 {
 
-	private static final String readStateATTR = RtspDecoder.class.toString()
-			+ "readState";
-	private static final String rtspMessageATTR = RtspDecoder.class.toString()
-			+ "rtspMessage";
+    private static final String readStateATTR = RtspDecoder.class.toString()
+            + "readState";
 
-	/**
-	 * State enumerator that indicates the reached state in the RTSP message
-	 * decoding process.
-	 */
-	public enum ReadState {
-		/** Unrecoverable error occurred */
-		Failed,
-		/** Trying to resync */
-		Sync,
-		/** Waiting for a command */
-		Ready,
-		/** Reading interleaved packet */
-		Packet,
-		/** Reading command (request or command line) */
-		Command,
-		/** Reading headers */
-		Header,
-		/** Reading body (entity) */
-		Body,
-		/** Fully formed message */
-		Dispatch
-	}
+    private static final String rtspMessageATTR = RtspDecoder.class.toString()
+            + "rtspMessage";
 
-	private static Logger log = LoggerFactory.getLogger( RtspDecoder.class );
+    /**
+     * State enumerator that indicates the reached state in the RTSP message
+     * decoding process.
+     */
+    public enum ReadState {
+        /** Unrecoverable error occurred */
+        Failed,
+        /** Trying to resync */
+        Sync,
+        /** Waiting for a command */
+        Ready,
+        /** Reading interleaved packet */
+        Packet,
+        /** Reading command (request or command line) */
+        Command,
+        /** Reading headers */
+        Header,
+        /** Reading body (entity) */
+        Body,
+        /** Fully formed message */
+        Dispatch
+    }
 
-	private static final Pattern rtspRequestPattern = Pattern.compile( "([A-Z_]+) ([^ ]+) RTSP/1.0" );
-	private static final Pattern rtspResponsePattern = Pattern.compile( "RTSP/1.0 ([0-9]+) .+" );
-	private static final Pattern rtspHeaderPattern = Pattern.compile( "([a-zA-Z\\-]+[0-9]?):\\s?(.*)" );
-	private static final Pattern spaceRtspHeaderPattern = Pattern.compile( "([a-zA-Z\\-]+[0-9]?)\\s?:\\s?(.*)" );
+    private static Logger log = LoggerFactory.getLogger( RtspDecoder.class );
 
-	private static final Charset asciiCharset = Charset.forName( "US-ASCII" );
+    private static final Pattern rtspRequestPattern = Pattern
+            .compile( "([A-Z_]+) ([^ ]+) RTSP/1.0" );
 
-	/**
-	 * Do the parsing on the incoming stream. If the stream does not contain the
-	 * entire RTSP message wait for other data to arrive, before dispatching the
-	 * message.
-	 * 
-	 * @see org.apache.mina.protocol.ProtocolDecoder#decode(org.apache.mina.protocol.IoSession,
-	 *      org.apache.mina.common.ByteBuffer,
-	 *      org.apache.mina.protocol.ProtocolDecoderOutput)
-	 */
-	public void decode( IoSession session, ByteBuffer buffer, ProtocolDecoderOutput out )
-			throws ProtocolDecoderException
-	{
-		BufferedReader reader = null;
+    private static final Pattern rtspResponsePattern = Pattern
+            .compile( "RTSP/1.0 ([0-9]+) .+" );
 
-		reader = new BufferedReader(new InputStreamReader( buffer.asInputStream(),
-				asciiCharset ), 2048 );
+    private static final Pattern rtspHeaderPattern = Pattern
+            .compile( "([a-zA-Z\\-]+[0-9]?):\\s?(.*)" );
 
-		// Retrieve status from session
-		ReadState state = (ReadState) session.getAttribute( readStateATTR );
-		RtspMessage rtspMessage = (RtspMessage) session.getAttribute( rtspMessageATTR );
-		log.debug("entered RTSP decode, state=" + state + ", rtsp message in session=" + rtspMessageATTR);
-		
-		try {
+    private static final Pattern spaceRtspHeaderPattern = Pattern
+            .compile( "([a-zA-Z\\-]+[0-9]?)\\s?:\\s?(.*)" );
 
-			while ( true ) {
-				/*
-				if ( state != ReadState.Command && state != ReadState.Header )
-					// the "while" loop is only used to read commands and
-					// headers
-					break;
-					*/
+    private static final Charset asciiCharset = Charset.forName( "US-ASCII" );
 
-				reader.mark(2048);
-				String line = reader.readLine();
-				if ( line == null ) {
-					// there's no more data in the buffer
-					log.debug("seen end-of-message, leaving loop");
-					break;					
-				}
-				
-				if ( state == null ) {
-					log.debug("switching null-state to Command");
-					state = ReadState.Command;
-				}
+    /**
+     * Do the parsing on the incoming stream. If the stream does not contain the
+     * entire RTSP message wait for other data to arrive, before dispatching the
+     * message.
+     * 
+     * @see org.apache.mina.protocol.ProtocolDecoder#decode(org.apache.mina.protocol.IoSession,
+     *      org.apache.mina.common.ByteBuffer,
+     *      org.apache.mina.protocol.ProtocolDecoderOutput)
+     */
+    public void decode( IoSession session, ByteBuffer buffer, ProtocolDecoderOutput out )
+            throws ProtocolDecoderException
+    {
+        BufferedReader reader = null;
 
-				if ( line.length() == 0 ) {
-					// This is the empty line that marks the end
-					// of the headers section
-					if(rtspMessage != null) {
-						log.debug("seen emtpy line, switching to Body");
-						state = ReadState.Body;
-						reader.mark(64);
-					} else {
-						log.debug("seen emtpy line, switching to Sync");
-						state = ReadState.Sync;						
-					}
-					// break;
-				}
+        reader = new BufferedReader( new InputStreamReader( buffer.asInputStream(),
+                asciiCharset ), 2048 );
 
-				switch (state) {
-				case Sync:
-					log.debug("found empty line between command, switching to Command");
-					state = ReadState.Command;
-					break;
-				case Command:
-					log.debug("Command line: " + line);
-					if (line.startsWith("RTSP")) {
-						// this is a RTSP response
-						Matcher m = rtspResponsePattern.matcher(line);
-						if (!m.matches())
-							throw new ProtocolDecoderException(
-									"Malformed response line: " + line);
+        // Retrieve status from session
+        ReadState state = (ReadState) session.getAttribute( readStateATTR );
+        RtspMessage rtspMessage = (RtspMessage) session.getAttribute( rtspMessageATTR );
+        
+        log.debug( "entered RTSP decode, state={}, rtsp message in session={}", state,
+                rtspMessageATTR );
 
-						RtspCode code = RtspCode.fromString(m.group(1));
-						rtspMessage = new RtspResponse();
-						((RtspResponse) (rtspMessage)).setCode(code);
-						RtspRequest.Verb verb = (RtspRequest.Verb) session
-								.getAttribute(RtspMessage.lastRequestVerbATTR);
-						((RtspResponse) (rtspMessage)).setRequestVerb(verb);
+        try {
 
-					} else {
-						// this is a RTSP request
-						Matcher m = rtspRequestPattern.matcher(line);
-						if (!m.matches())
-							throw new ProtocolDecoderException(
-									"Malformed request line: " + line);
+            while ( true ) {
+                /*
+                 * if ( state != ReadState.Command && state != ReadState.Header ) //
+                 * the "while" loop is only used to read commands and // headers
+                 * break;
+                 */
 
-						String verb = m.group(1);
-						String strUrl = m.group(2);
-						URL url = null;
-						if (!strUrl.equalsIgnoreCase("*")) {
-							try {
-								url = new URL(strUrl);
-							} catch (MalformedURLException e) {
-								log.info("malformed URL: " + url, e);
-								url = null;
-								session.setAttribute(readStateATTR,
-										ReadState.Failed);
-								throw new ProtocolDecoderException(
-										"Invalid URL");
-							}
-						}
-						rtspMessage = new RtspRequest();
-						((RtspRequest) rtspMessage).setVerb(verb);
+                reader.mark( 2048 );
+                String line = reader.readLine();
+                if ( line == null ) {
+                    // there's no more data in the buffer
+                    log.debug( "seen end-of-message, leaving loop" );
+                    break;
+                }
 
-						if (((RtspRequest) rtspMessage).getVerb() == RtspRequest.Verb.None) {
-							session.setAttribute(readStateATTR,
-									ReadState.Failed);
-							throw new ProtocolDecoderException(
-									"Invalid method: " + verb);
-						}
+                if ( state == null ) {
+                    log.debug( "switching null-state to Command" );
+                    state = ReadState.Command;
+                }
 
-						((RtspRequest) rtspMessage).setUrl(url);
-					}
-					state = ReadState.Header;
-					log.debug("switching from Command to Header, message="
-							+ rtspMessage);
-					break;
+                if ( line.length() == 0 ) {
+                    // This is the empty line that marks the end
+                    // of the headers section
+                    if ( rtspMessage != null ) {
+                        log.debug( "seen emtpy line, switching to Body" );
+                        state = ReadState.Body;
+                        reader.mark( 64 );
+                    } else {
+                        log.debug( "seen emtpy line, switching to Sync" );
+                        state = ReadState.Sync;
+                    }
+                    // break;
+                }
 
-				case Header:
-					// this is an header
-					log.debug("Header line: " + line);
-					Matcher m = rtspHeaderPattern.matcher(line);
+                switch ( state )
+                {
+                case Sync:
+                    log.debug( "found empty line between command, switching to Command" );
+                    state = ReadState.Command;
+                    break;
+                case Command:
+                    log.debug( "Command line: {}", line );
+                    if ( line.startsWith( "RTSP" ) ) {
+                        // this is a RTSP response
+                        Matcher m = rtspResponsePattern.matcher( line );
+                        if ( !m.matches() )
+                            throw new ProtocolDecoderException(
+                                    "Malformed response line: " + line );
 
-					if (!m.matches()) {
-						if(Config.proxyRtspAllowBrokenHeaders.getValue()) {
-							Matcher m2 = spaceRtspHeaderPattern.matcher(line);
-							
-							if(!m2.matches()) {
-								throw new ProtocolDecoderException(
-										"RTSP header not valid, line=" + line);								
-							} else
-								rtspMessage.setHeader(m2.group(1), m2.group(2));
-						} else {
-							throw new ProtocolDecoderException(
-							"RTSP header not valid, line=" + line);
-						}
-					} else
-						rtspMessage.setHeader(m.group(1), m.group(2));
-					
-					break;
-				case Body:
-					int bufferLen = Integer.parseInt(rtspMessage.getHeader(
-							"Content-Length", "0"));
+                        RtspCode code = RtspCode.fromString( m.group( 1 ) );
+                        rtspMessage = new RtspResponse();
+                        ((RtspResponse) (rtspMessage)).setCode( code );
+                        RtspRequest.Verb verb = (RtspRequest.Verb) session
+                                .getAttribute( RtspMessage.lastRequestVerbATTR );
+                        ((RtspResponse) (rtspMessage)).setRequestVerb( verb );
 
-					if (bufferLen == 0) {
-						log.debug("no message body found, switching to Dispatch");
-						// there's no buffer to be read
-						state = ReadState.Dispatch;
+                    } else {
+                        // this is a RTSP request
+                        Matcher m = rtspRequestPattern.matcher( line );
+                        if ( !m.matches() )
+                            throw new ProtocolDecoderException(
+                                    "Malformed request line: " + line );
 
-					} else {
-						// we have a content buffer to read
-						int bytesToRead = bufferLen
-								- rtspMessage.getBufferSize();
+                        String verb = m.group( 1 );
+                        String strUrl = m.group( 2 );
+                        URL url = null;
+                        if ( !strUrl.equalsIgnoreCase( "*" ) ) {
+                            try {
+                                url = new URL( strUrl );
+                            } catch ( MalformedURLException e ) {
+                                log.info( "malformed URL {}", url );
+                                url = null;
+                                session.setAttribute( readStateATTR, ReadState.Failed );
+                                throw new ProtocolDecoderException( "Invalid URL" );
+                            }
+                        }
+                        rtspMessage = new RtspRequest();
+                        ((RtspRequest) rtspMessage).setVerb( verb );
 
-						// if ( bytesToRead < reader. decodeBuf.length() ) {
-						// log.warn( "We are reading more bytes than
-						// Content-Length." );
-						// }
+                        if ( ((RtspRequest) rtspMessage).getVerb() == RtspRequest.Verb.None ) {
+                            session.setAttribute( readStateATTR, ReadState.Failed );
+                            throw new ProtocolDecoderException( "Invalid method: " + verb );
+                        }
 
-						// read the content buffer
-						CharBuffer bufferContent = CharBuffer
-								.allocate(bytesToRead);
-						reader.reset();
-						reader.read(bufferContent);
-						bufferContent.flip();
-						rtspMessage.appendToBuffer(bufferContent);
-						
-						// this is an ugly hack to avoid content underruns produced by bogus servers
-						if( rtspMessage.getBufferSize() == (bufferLen - 2))
-							rtspMessage.appendToBuffer("\r\n");
-						if( rtspMessage.getBufferSize() == (bufferLen - 1))
-							rtspMessage.appendToBuffer("\n");
-						
-						// terminate message here
-						if (rtspMessage.getBufferSize() >= bufferLen) {
-							// The RTSP message parsing is completed
-							state = ReadState.Dispatch;
-						}
-					}
-					break;
-				}
-				if ( state == ReadState.Dispatch ) {
-					log.debug("sending decoded RTSP message");
-					// The message is already formed
-					// send it
-					session.removeAttribute( readStateATTR );
-					session.removeAttribute( rtspMessageATTR );
-					out.write( rtspMessage );
-					
-					state = null;
-					rtspMessage = null;
-				}
+                        ((RtspRequest) rtspMessage).setUrl( url );
+                    }
+                    state = ReadState.Header;
+                    log.debug( "switching from Command to Header, message={}",
+                            rtspMessage );
+                    break;
 
-			}
-		} catch ( IOException e ) {
-			/*
-			 * error on input stream should not happen since the input stream is
-			 * coming from a bytebuffer.
-			 */
-			Exceptions.logStackTrace( e );
-			return;
-		} catch( Throwable t) {
-			Exceptions.logStackTrace( t );
-			return;
-		} finally {
-			try {
-				reader.close();
-			} catch ( Exception e ) {
-			}
-		}
+                case Header:
+                    // this is an header
+                    log.debug( "Header line: {}", line );
+                    Matcher m = rtspHeaderPattern.matcher( line );
 
-		// log.debug( "INCOMPLETE MESSAGE \n" + rtspMessage );
+                    if ( !m.matches() ) {
+                        if ( Config.proxyRtspAllowBrokenHeaders.getValue() ) {
+                            Matcher m2 = spaceRtspHeaderPattern.matcher( line );
 
-		// Save attributes in session
-		log.debug("leaving decode loop, state=" + state + ", message in session=" + rtspMessage);
-		session.setAttribute( readStateATTR, state );
-		session.setAttribute( rtspMessageATTR, rtspMessage );
-	}
+                            if ( !m2.matches() ) {
+                                throw new ProtocolDecoderException(
+                                        "RTSP header not valid, line=" + line );
+                            }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.mina.filter.codec.ProtocolDecoder#dispose(org.apache.mina.common.IoSession)
-	 */
-	public void dispose( IoSession session ) throws Exception
-	{
-		// Do nothing
-	}
+                            rtspMessage.setHeader( m2.group( 1 ), m2.group( 2 ) );
+
+                        } else {
+                            throw new ProtocolDecoderException(
+                                    "RTSP header not valid, line=" + line );
+                        }
+                    } else
+                        rtspMessage.setHeader( m.group( 1 ), m.group( 2 ) );
+
+                    break;
+                case Body:
+                    int bufferLen = Integer.parseInt( rtspMessage.getHeader(
+                            "Content-Length", "0" ) );
+
+                    if ( bufferLen == 0 ) {
+                        log.debug( "no message body found, switching to Dispatch" );
+                        // there's no buffer to be read
+                        state = ReadState.Dispatch;
+
+                    } else {
+                        // we have a content buffer to read
+                        int bytesToRead = bufferLen - rtspMessage.getBufferSize();
+
+                        // read the content buffer
+                        CharBuffer bufferContent = CharBuffer.allocate( bytesToRead );
+                        reader.reset();
+                        reader.read( bufferContent );
+                        bufferContent.flip();
+                        rtspMessage.appendToBuffer( bufferContent );
+
+                        // this is an ugly hack to avoid content underruns
+                        // produced by bogus servers
+                        if ( rtspMessage.getBufferSize() == (bufferLen - 2) )
+                            rtspMessage.appendToBuffer( "\r\n" );
+                        if ( rtspMessage.getBufferSize() == (bufferLen - 1) )
+                            rtspMessage.appendToBuffer( "\n" );
+
+                        // terminate message here
+                        if ( rtspMessage.getBufferSize() >= bufferLen ) {
+                            // The RTSP message parsing is completed
+                            state = ReadState.Dispatch;
+                        }
+                    }
+                    break;
+                }
+                if ( state == ReadState.Dispatch ) {
+                    log.debug( "sending decoded RTSP message" );
+                    // The message is already formed
+                    // send it
+                    session.removeAttribute( readStateATTR );
+                    session.removeAttribute( rtspMessageATTR );
+                    out.write( rtspMessage );
+
+                    state = null;
+                    rtspMessage = null;
+                }
+
+            }
+        } catch ( IOException e ) {
+            /*
+             * error on input stream should not happen since the input stream is
+             * coming from a bytebuffer.
+             */
+            Exceptions.logStackTrace( e );
+            return;
+        } catch ( Throwable t ) {
+            Exceptions.logStackTrace( t );
+            return;
+        } finally {
+            try {
+                reader.close();
+            } catch ( Exception e ) {
+            }
+        }
+
+        // log.debug( "INCOMPLETE MESSAGE \n{}", rtspMessage );
+
+        // Save attributes in session
+        log.debug( "leaving decode loop, state={}, message in session={}", state,
+                rtspMessage );
+        session.setAttribute( readStateATTR, state );
+        session.setAttribute( rtspMessageATTR, rtspMessage );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.filter.codec.ProtocolDecoder#dispose(org.apache.mina.common.IoSession)
+     */
+    public void dispose( IoSession session ) throws Exception
+    {
+        // Do nothing
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspMessage.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspMessage.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspMessage.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -34,257 +34,260 @@
 public abstract class RtspMessage
 {
 
-	public static final String lastRequestVerbATTR = RtspMessage.class.toString()
-			+ "lastRequestVerb";
+    public static final String lastRequestVerbATTR = RtspMessage.class.toString()
+            + "lastRequestVerb";
 
-	/**
-	 * RTSP Message Type
-	 */
-	public enum Type {
-		/** Generic message (internal use) */
-		TypeNone,
-		/** Request message */
-		TypeRequest,
-		/** Response message */
-		TypeResponse
-	};
+    /**
+     * RTSP Message Type
+     */
+    public enum Type {
+        /** Generic message (internal use) */
+        TypeNone,
+        /** Request message */
+        TypeRequest,
+        /** Response message */
+        TypeResponse
+    };
 
-	private int sequenceNumber;
+    private int sequenceNumber;
 
-	private Map<String, String> headers;
+    private Map<String, String> headers;
 
-	private StringBuffer buffer;
+    private StringBuffer buffer;
 
-	/**
-	 * Constructor.
-	 */
-	public RtspMessage()
-	{
-		sequenceNumber = 0;
-		headers = new LinkedHashMap<String, String>();
-		buffer = new StringBuffer();
-	}
+    /**
+     * Constructor.
+     */
+    public RtspMessage()
+    {
+        sequenceNumber = 0;
+        headers = new LinkedHashMap<String, String>();
+        buffer = new StringBuffer();
+    }
 
-	/**
-	 * @return the RTSP type of the message
-	 */
-	public Type getType()
-	{
-		return Type.TypeNone;
-	}
+    /**
+     * @return the RTSP type of the message
+     */
+    public Type getType()
+    {
+        return Type.TypeNone;
+    }
 
-	/**
-	 * Adds a new header to the RTSP message.
-	 * 
-	 * @param key
-	 *            The name of the header
-	 * @param value
-	 *            Its value
-	 */
-	public void setHeader( String key, String value )
-	{
-		// Handle some bad formatted headers
-		if ( key.compareToIgnoreCase( "content-length" ) == 0 ) {
-			headers.put( "Content-Length", value );
-		} else {
-			headers.put( key, value );
-		}
-	}
+    /**
+     * Adds a new header to the RTSP message.
+     * 
+     * @param key
+     *            The name of the header
+     * @param value
+     *            Its value
+     */
+    public void setHeader( String key, String value )
+    {
+        // Handle some bad formatted headers
+        if ( key.compareToIgnoreCase( "content-length" ) == 0 ) {
+            headers.put( "Content-Length", value );
+        } else {
+            headers.put( key, value );
+        }
+    }
 
-	/**
-	 * @param key
-	 *            Header name
-	 * @return the value of the header
-	 */
-	public String getHeader( String key )
-	{
-		return headers.get( key );
-	}
+    /**
+     * @param key
+     *            Header name
+     * @return the value of the header
+     */
+    public String getHeader( String key )
+    {
+        return headers.get( key );
+    }
 
-	/**
-	 * @param key
-	 *            Header name
-	 * @param defaultValue
-	 *            the default value
-	 * @return the value of the header of <i>defaultValue</i> if header is not
-	 *         found
-	 */
-	public String getHeader( String key, String defaultValue )
-	{
-		String value = getHeader( key );
-		if ( value == null )
-			return defaultValue;
-		else
-			return value;
-	}
+    /**
+     * @param key
+     *            Header name
+     * @param defaultValue
+     *            the default value
+     * @return the value of the header of <i>defaultValue</i> if header is not
+     *         found
+     */
+    public String getHeader( String key, String defaultValue )
+    {
+        String value = getHeader( key );
+        if ( value == null )
+            return defaultValue;
 
-	/**
-	 * Remove an header from the message headers collection
-	 * 
-	 * @param key
-	 *            the name of the header
-	 */
-	public void removeHeader( String key )
-	{
-		headers.remove( key );
-	}
+        return value;
+    }
 
-	/**
-	 * Formats all the headers into a string ready to be sent in a RTSP message.
-	 * 
-	 * <pre>
-	 *     Header1: Value1
-	 *     Header2: value 2
-	 *     ... 
-	 * </pre>
-	 * 
-	 * @return a string containing the serialzed headers
-	 */
-	public String getHeadersString()
-	{
-		StringBuilder buf = new StringBuilder();
-		for ( String key : headers.keySet() ) {
-			buf.append( key ).append( ": " ).append( headers.get( key ) ).append( CRLF );
-		}
-		return buf.toString();
-	}
+    /**
+     * Remove an header from the message headers collection
+     * 
+     * @param key
+     *            the name of the header
+     */
+    public void removeHeader( String key )
+    {
+        headers.remove( key );
+    }
 
-	/**
-	 * get a map of all headers set in the request
-	 * @return an unmodifiable map of all header fields in this request. 
-	 */
-	public Map<String, String> getHeaders() {
-		if(this.headers != null)
-			return Collections.unmodifiableMap(this.headers);
-		else
-			return Collections.unmodifiableMap(new HashMap<String, String>());
-	}
-	
-	/**
-	 * @return the number of headers owned by the message
-	 */
-	public int getHeadersCount()
-	{
-		return headers.size();
-	}
+    /**
+     * Formats all the headers into a string ready to be sent in a RTSP message.
+     * 
+     * <pre>
+     *      Header1: Value1
+     *      Header2: value 2
+     *      ... 
+     * </pre>
+     * 
+     * @return a string containing the serialzed headers
+     */
+    public String getHeadersString()
+    {
+        StringBuilder buf = new StringBuilder();
+        for ( String key : headers.keySet() ) {
+            buf.append( key ).append( ": " ).append( headers.get( key ) ).append( CRLF );
+        }
+        return buf.toString();
+    }
 
-	/**
-	 * Sets common headers like <code>Server</code> and <code>Via</code>.
-	 */
-	public void setCommonHeaders()
-	{
-		String proxy = Config.getProxySignature();
-		if ( getHeader( "Server" ) == null )
-			setHeader( "Server", proxy );
-		
-		if(Config.proxyClientAddress.getStringValue() != null) {
-			String via = getHeader("Via");
-			StringBuffer newVia = new StringBuffer();
-			
-			if(via != null && via.length() > 0) {
-				newVia.append(via);
-				newVia.append(", ");
-			}
-			newVia.append("RTSP/1.0 ");
-			
-			String clientAddr  = Config.proxyClientAddress.getStringValue();
-			String serverAddr = Config.proxyServerAddress.getStringValue();
-			
-			newVia.append(clientAddr);
-			if(serverAddr != null && !serverAddr.equals(clientAddr)) {
-				newVia.append(", RTSP/1.0 ");
-				newVia.append(serverAddr);
-			}
-			
-			setHeader("Via", newVia.toString());
-		}
-	}
+    /**
+     * get a map of all headers set in the request
+     * 
+     * @return an unmodifiable map of all header fields in this request.
+     */
+    public Map<String, String> getHeaders()
+    {
+        if ( this.headers != null )
+            return Collections.unmodifiableMap( this.headers );
 
-	/**
-	 * @param buffer
-	 *            StringBuffer containing the contents
-	 */
-	public void setBuffer( StringBuffer buffer )
-	{
-		this.buffer = buffer;
-	}
+        return Collections.unmodifiableMap( new HashMap<String, String>() );
+    }
 
-	/**
-	 * @param other
-	 *            buffer with content to be appended
-	 */
-	public void appendToBuffer( StringBuffer other )
-	{
-		this.buffer.append( other );
-	}
+    /**
+     * @return the number of headers owned by the message
+     */
+    public int getHeadersCount()
+    {
+        return headers.size();
+    }
 
-	/**
-	 * @param other
-	 *            buffer with content to be appended
-	 */
-	public void appendToBuffer( String other )
-	{
-		this.buffer.append( other );
-	}
+    /**
+     * Sets common headers like <code>Server</code> and <code>Via</code>.
+     */
+    public void setCommonHeaders()
+    {
+        String proxy = Config.getProxySignature();
+        if ( getHeader( "Server" ) == null )
+            setHeader( "Server", proxy );
 
-	/**
-	 * @param other
-	 *            buffer with content to be appended
-	 */
-	public void appendToBuffer( CharBuffer other )
-	{
-		this.buffer.append( other );
-	}
+        if ( Config.proxyClientAddress.getStringValue() != null ) {
+            String via = getHeader( "Via" );
+            StringBuffer newVia = new StringBuffer();
 
-	/**
-	 * @return the content buffer
-	 */
-	public StringBuffer getBuffer()
-	{
-		return buffer;
-	}
+            if ( via != null && via.length() > 0 ) {
+                newVia.append( via );
+                newVia.append( ", " );
+            }
+            newVia.append( "RTSP/1.0 " );
 
-	/**
-	 * @return the size of the content buffer
-	 */
-	public int getBufferSize()
-	{
-		return buffer.length();
-	}
+            String clientAddr = Config.proxyClientAddress.getStringValue();
+            String serverAddr = Config.proxyServerAddress.getStringValue();
 
-	// CRLF
-	public static final String CRLF = "\r\n";
+            newVia.append( clientAddr );
+            if ( serverAddr != null && !serverAddr.equals( clientAddr ) ) {
+                newVia.append( ", RTSP/1.0 " );
+                newVia.append( serverAddr );
+            }
 
-	/**
-	 * get the sequence number. If the sequence has not been set, the value from the 
-	 * <b>CSeq</b> header is scaned (if the header is set)
-	 * @return Returns the sequenceNumber. Returns 0 if the sequence number has not been set and the
-	 * <b>CSeq</b> header is not available.
-	 */
-	public int getSequenceNumber()
-	{
-		if(this.sequenceNumber == 0) {
-			try {
-				if(this.headers.containsKey("CSeq"))
-					this.sequenceNumber = Integer.parseInt(this.headers.get("CSeq"));
-			} catch(Exception e) {
-				
-			}
-		}
-			
-		return sequenceNumber;
-	}
+            setHeader( "Via", newVia.toString() );
+        }
+    }
 
-	/**
-	 * Set the sequence number. As a by-product it also sets the CSeq header field to this
-	 * value.
-	 * 
-	 * @param sequenceNumber
-	 *            The sequenceNumber to set.
-	 */
-	public void setSequenceNumber( int sequenceNumber )
-	{
-		this.sequenceNumber = sequenceNumber;
-		this.headers.put("CSeq", String.valueOf(this.sequenceNumber));
-	}
+    /**
+     * @param buffer
+     *            StringBuffer containing the contents
+     */
+    public void setBuffer( StringBuffer buffer )
+    {
+        this.buffer = buffer;
+    }
+
+    /**
+     * @param other
+     *            buffer with content to be appended
+     */
+    public void appendToBuffer( StringBuffer other )
+    {
+        this.buffer.append( other );
+    }
+
+    /**
+     * @param other
+     *            buffer with content to be appended
+     */
+    public void appendToBuffer( String other )
+    {
+        this.buffer.append( other );
+    }
+
+    /**
+     * @param other
+     *            buffer with content to be appended
+     */
+    public void appendToBuffer( CharBuffer other )
+    {
+        this.buffer.append( other );
+    }
+
+    /**
+     * @return the content buffer
+     */
+    public StringBuffer getBuffer()
+    {
+        return buffer;
+    }
+
+    /**
+     * @return the size of the content buffer
+     */
+    public int getBufferSize()
+    {
+        return buffer.length();
+    }
+
+    // CRLF
+    public static final String CRLF = "\r\n";
+
+    /**
+     * get the sequence number. If the sequence has not been set, the value from
+     * the <b>CSeq</b> header is scaned (if the header is set)
+     * 
+     * @return Returns the sequenceNumber. Returns 0 if the sequence number has
+     *         not been set and the <b>CSeq</b> header is not available.
+     */
+    public int getSequenceNumber()
+    {
+        if ( this.sequenceNumber == 0 ) {
+            try {
+                if ( this.headers.containsKey( "CSeq" ) )
+                    this.sequenceNumber = Integer.parseInt( this.headers.get( "CSeq" ) );
+            } catch ( Exception e ) {
+                  // Do nothing
+            }
+        }
+
+        return sequenceNumber;
+    }
+
+    /**
+     * Set the sequence number. As a by-product it also sets the CSeq header
+     * field to this value.
+     * 
+     * @param sequenceNumber
+     *            The sequenceNumber to set.
+     */
+    public void setSequenceNumber( int sequenceNumber )
+    {
+        this.sequenceNumber = sequenceNumber;
+        this.headers.put( "CSeq", String.valueOf( this.sequenceNumber ) );
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspRequest.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspRequest.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspRequest.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -44,7 +44,8 @@
 		verb = Verb.None;
 	}
 
-	public Type getType()
+	@Override
+    public Type getType()
 	{
 		return Type.TypeRequest;
 	}
@@ -101,11 +102,12 @@
 	 * [buffer]
 	 * </pre>
 	 */
-	public String toString()
+	@Override
+    public String toString()
 	{
-		StringBuilder sb = new StringBuilder();
-		sb.append( getVerbString() + " " );
-		sb.append( url != null ? url : "*" );
+		final StringBuilder sb = new StringBuilder();
+		sb.append( getVerbString() ).append( ' ' );
+		sb.append( url != null ? url : '*' );
 		sb.append( " RTSP/1.0\r\n" );
 		sb.append( getHeadersString() );
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspResponse.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspResponse.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspResponse.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -39,7 +39,8 @@
 		code = RtspCode.OK;
 	}
 
-	public Type getType()
+	@Override
+    public Type getType()
 	{
 		return Type.TypeResponse;
 	}
@@ -74,10 +75,11 @@
 	 *    [buf] 
 	 * </pre>
 	 */
-	public String toString()
+	@Override
+    public String toString()
 	{
-		StringBuilder sb = new StringBuilder();
-		sb.append( "RTSP/1.0 " ).append( code.value() ).append( " " );
+		final StringBuilder sb = new StringBuilder();
+		sb.append( "RTSP/1.0 " ).append( code.value() ).append( ' ' );
 		sb.append( code.description() ).append( CRLF );
 		sb.append( getHeadersString() );
 
@@ -87,7 +89,7 @@
 		if ( getBufferSize() > 0 ) {
 			sb.append( getBuffer() );
 
-			log.debug( "Buffer Size: " + getBufferSize() );
+			log.debug( "Buffer Size: {}", getBufferSize() );
 		}
 
 		return sb.toString();

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspSession.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspSession.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspSession.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -61,7 +61,7 @@
 		}
 		RtspSession session = new RtspSession( sessionId );
 		sessions.put( sessionId, session );
-		log.debug( "New session created - id=" + sessionId );
+		log.debug( "New session created - id={}", sessionId );
 		return session;
 	}
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransport.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransport.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransport.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -27,661 +27,662 @@
  * Parse the RTSP Transport header field. Reference Grammar:
  * 
  * <pre>
- *                       Transport           =    &quot;Transport&quot; &quot;:&quot;
- *                                                1\#transport-spec
- *                       transport-spec      =    transport-protocol/profile[/lower-transport]
- *                                                *parameter
- *                       transport-protocol  =    &quot;RTP&quot;
- *                       profile             =    &quot;AVP&quot;
- *                       lower-transport     =    &quot;TCP&quot; | &quot;UDP&quot;
- *                       parameter           =    ( &quot;unicast&quot; | &quot;multicast&quot; )
- *                                           |    &quot;;&quot; &quot;destination&quot; [ &quot;=&quot; address ]
- *                                           |    &quot;;&quot; &quot;interleaved&quot; &quot;=&quot; channel [ &quot;-&quot; channel ]
- *                                           |    &quot;;&quot; &quot;append&quot;
- *                                           |    &quot;;&quot; &quot;ttl&quot; &quot;=&quot; ttl
- *                                           |    &quot;;&quot; &quot;layers&quot; &quot;=&quot; 1*DIGIT
- *                                           |    &quot;;&quot; &quot;port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
- *                                           |    &quot;;&quot; &quot;client_port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
- *                                           |    &quot;;&quot; &quot;server_port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
- *                                           |    &quot;;&quot; &quot;ssrc&quot; &quot;=&quot; ssrc
- *                                           |    &quot;;&quot; &quot;mode&quot; = &lt;&quot;&gt; 1\#mode &lt;&quot;&gt;
- *                       ttl                 =    1*3(DIGIT)
- *                       port                =    1*5(DIGIT)
- *                       ssrc                =    8*8(HEX)
- *                       channel             =    1*3(DIGIT)
- *                       address             =    host
- *                       mode                =    &lt;&quot;&gt; *Method &lt;&quot;&gt; | Method
- *                    
- *                    
- *                       Example:
- *                         Transport: RTP/AVP;multicast;ttl=127;mode=&quot;PLAY&quot;,
- *                                    RTP/AVP;unicast;client_port=3456-3457;mode=&quot;PLAY&quot;
+ *                        Transport           =    &quot;Transport&quot; &quot;:&quot;
+ *                                                 1\#transport-spec
+ *                        transport-spec      =    transport-protocol/profile[/lower-transport]
+ *                                                 *parameter
+ *                        transport-protocol  =    &quot;RTP&quot;
+ *                        profile             =    &quot;AVP&quot;
+ *                        lower-transport     =    &quot;TCP&quot; | &quot;UDP&quot;
+ *                        parameter           =    ( &quot;unicast&quot; | &quot;multicast&quot; )
+ *                                            |    &quot;;&quot; &quot;destination&quot; [ &quot;=&quot; address ]
+ *                                            |    &quot;;&quot; &quot;interleaved&quot; &quot;=&quot; channel [ &quot;-&quot; channel ]
+ *                                            |    &quot;;&quot; &quot;append&quot;
+ *                                            |    &quot;;&quot; &quot;ttl&quot; &quot;=&quot; ttl
+ *                                            |    &quot;;&quot; &quot;layers&quot; &quot;=&quot; 1*DIGIT
+ *                                            |    &quot;;&quot; &quot;port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
+ *                                            |    &quot;;&quot; &quot;client_port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
+ *                                            |    &quot;;&quot; &quot;server_port&quot; &quot;=&quot; port [ &quot;-&quot; port ]
+ *                                            |    &quot;;&quot; &quot;ssrc&quot; &quot;=&quot; ssrc
+ *                                            |    &quot;;&quot; &quot;mode&quot; = &lt;&quot;&gt; 1\#mode &lt;&quot;&gt;
+ *                        ttl                 =    1*3(DIGIT)
+ *                        port                =    1*5(DIGIT)
+ *                        ssrc                =    8*8(HEX)
+ *                        channel             =    1*3(DIGIT)
+ *                        address             =    host
+ *                        mode                =    &lt;&quot;&gt; *Method &lt;&quot;&gt; | Method
+ *                     
+ *                     
+ *                        Example:
+ *                          Transport: RTP/AVP;multicast;ttl=127;mode=&quot;PLAY&quot;,
+ *                                     RTP/AVP;unicast;client_port=3456-3457;mode=&quot;PLAY&quot;
  * </pre>
  */
 public class RtspTransport
 {
 
-	private static Logger logger = LoggerFactory.getLogger(RtspTransport.class);
-	
-	/** Transport Protocol */
-	public enum TransportProtocol {
-		None,
-		/** Real Time Protocol */
-		RTP,
-		/** RDT: RealNetworks transport protocol */
-		RDT, RAW;
+    private static Logger log = LoggerFactory.getLogger( RtspTransport.class );
 
-		public static TransportProtocol fromString( String transportName )
-		{
-			if ( "RTP".equalsIgnoreCase( transportName ) )
-				return RTP;
-			else
-				if ( "RDT".equalsIgnoreCase( transportName )
-						|| "x-real-rdt".equalsIgnoreCase( transportName ) )
-					return RDT;
-				else
-					return None;
-		}
-	}
+    /** Transport Protocol */
+    public enum TransportProtocol {
+        None,
+        /** Real Time Protocol */
+        RTP,
+        /** RDT: RealNetworks transport protocol */
+        RDT, RAW;
 
-	/** Profile of the streamed data */
-	public enum Profile {
-		None,
-		/** Audio-Video Profile */
-		AVP;
+        public static TransportProtocol fromString( String transportName )
+        {
+            if ( "RTP".equalsIgnoreCase( transportName ) )
+                return RTP;
+            else if ( "RDT".equalsIgnoreCase( transportName )
+                    || "x-real-rdt".equalsIgnoreCase( transportName ) )
+                return RDT;
+            else
+                return None;
+        }
+    }
 
-		public static Profile fromString( String profile )
-		{
-			if ( "AVP".equalsIgnoreCase( profile ) )
-				return AVP;
-			else
-				return None;
-		}
-	}
+    /** Profile of the streamed data */
+    public enum Profile {
+        None,
+        /** Audio-Video Profile */
+        AVP;
 
-	/** Underlying transport protocol */
-	public enum LowerTransport {
-		None, TCP, UDP;
+        public static Profile fromString( String profile )
+        {
+            if ( "AVP".equalsIgnoreCase( profile ) )
+                return AVP;
 
-		public static LowerTransport fromString( String transportName )
-		{
-			if ( "TCP".equalsIgnoreCase( transportName ) )
-				return TCP;
-			else
-				if ( "UDP".equalsIgnoreCase( transportName ) )
-					return UDP;
-				else
-					return None;
-		}
-	}
+            return None;
+        }
+    }
 
-	/** Delivery method */
-	public enum DeliveryType {
-		None, unicast, multicast
-	}
+    /** Underlying transport protocol */
+    public enum LowerTransport {
+        None, TCP, UDP;
 
-	/** mode */
-	public enum Mode {
-		None, PLAY, RECORD;
-		
-		public static Mode fromString ( String modeName ) {
-			if( "PLAY".equalsIgnoreCase( modeName ))
-				return PLAY;
-			else if( "RECORD".equalsIgnoreCase( modeName ))
-				return RECORD;
-			else {
-				logger.debug("unknown mode string passed (ignored): " + modeName);
-				return None;
-			}
-		}
-	}
-	
-	TransportProtocol transportProtocol = null;
-	Profile profile = null;
-	LowerTransport lowerTransport = null;
-	DeliveryType deliveryType = null;
+        public static LowerTransport fromString( String transportName )
+        {
+            if ( "TCP".equalsIgnoreCase( transportName ) )
+                return TCP;
+            else if ( "UDP".equalsIgnoreCase( transportName ) )
+                return UDP;
+            else
+                return None;
+        }
+    }
 
-	String destination;
-	String interleaved;
-	int layers;
-	boolean append;
-	int ttl;
-	int[] port = new int[2];
-	int[] client_port = new int[2];
-	int[] server_port = new int[2];
-	String ssrc;
-	Mode mode = Mode.None;
-	String source;
+    /** Delivery method */
+    public enum DeliveryType {
+        None, unicast, multicast
+    }
 
-	/**
-	 * Constructor. Creates a RtspTransport object from a transport header
-	 * string.
-	 */
-	public RtspTransport( String transport )
-	{
-		transportProtocol = TransportProtocol.None;
-		profile = Profile.None;
-		lowerTransport = LowerTransport.None;
-		deliveryType = DeliveryType.None;
-		destination = null;
-		interleaved = null;
-		layers = 0;
-		append = false;
-		ttl = 0;
-		port[0] = 0;
-		port[1] = 0;
-		client_port[0] = 0;
-		client_port[1] = 0;
-		server_port[0] = 0;
-		server_port[1] = 0;
-		ssrc = null;
-		mode = Mode.None;
-		source = null;
+    /** mode */
+    public enum Mode {
+        None, PLAY, RECORD;
 
-		parseTransport( transport );
-	}
+        public static Mode fromString( String modeName )
+        {
+            if ( "PLAY".equalsIgnoreCase( modeName ) )
+                return PLAY;
+            else if ( "RECORD".equalsIgnoreCase( modeName ) )
+                return RECORD;
+            else {
+                log.debug( "unknown mode string passed (ignored): {}", modeName );
+                return None;
+            }
+        }
+    }
 
-	private void parseTransport( String transport )
-	{
-		for ( String tok : transport.split( ";" ) ) {
+    TransportProtocol transportProtocol = null;
 
-			// First check for the transport protocol
-			if ( tok.startsWith( "RTP" ) || tok.startsWith( "RDT" )
-					|| tok.startsWith( "x-real-rdt" ) ) {
-				String[] tpl = tok.split( "/" );
-				transportProtocol = TransportProtocol.fromString( tpl[0] );
-				if ( tpl.length > 1 )
-					try {
-						profile = Profile.valueOf( tpl[1] );
-					} catch ( Exception e ) {
-						profile = Profile.None;
-					}
+    Profile profile = null;
 
-				if ( profile == Profile.None ) {
-					// Maybe this is a lower transport definition
-					lowerTransport = LowerTransport.fromString( tpl[1] );
-				}
+    LowerTransport lowerTransport = null;
 
-				if ( tpl.length > 2 )
-					lowerTransport = LowerTransport.valueOf( tpl[2] );
-				continue;
-			}
+    DeliveryType deliveryType = null;
 
-			if ( tok.compareToIgnoreCase( "unicast" ) == 0 )
-				deliveryType = DeliveryType.unicast;
-			else
-				if ( tok.compareToIgnoreCase( "multicast" ) == 0 )
-					deliveryType = DeliveryType.multicast;
-				else
-					if ( tok.startsWith( "destination" ) )
-						setDestination( _getStrValue( tok ) );
-					else
-						if ( tok.startsWith( "interleaved" ) )
-							setInterleaved( _getStrValue( tok ) );
-						else
-							if ( tok.startsWith( "append" ) )
-								setAppend( true );
-							else
-								if ( tok.startsWith( "layers" ) )
-									setLayers( Integer.valueOf( _getStrValue( tok ) ) );
-								else
-									if ( tok.startsWith( "ttl" ) )
-										setTTL( Integer.valueOf( _getStrValue( tok ) ) );
-									else
-										if ( tok.startsWith( "port" ) )
-											setPort( _getPairValue( tok ) );
-										else
-											if ( tok.startsWith( "client_port" ) )
-												setClientPort( _getPairValue( tok ) );
-											else
-												if ( tok.startsWith( "server_port" ) )
-													setServerPort( _getPairValue( tok ) );
-												else
-													if ( tok.startsWith( "ssrc" ) )
-														setSSRC( _getStrValue( tok ) );
-													else
-														if ( tok.startsWith( "mode" ) )
-															setMode( Mode.fromString( _getStrValue( tok ) ) );
-														else
-															if ( tok.startsWith( "source" ) )
-																setSource( _getStrValue( tok ) );
-		}
+    String destination;
 
-		if ( transportProtocol == TransportProtocol.RTP
-				&& lowerTransport == LowerTransport.None )
-			// If it's not specified, let's assume UDP
-			setLowerTransport( LowerTransport.UDP );
+    String interleaved;
 
-		if ( transportProtocol == TransportProtocol.RTP
-				&& deliveryType == DeliveryType.None )
-			// If it's not specified, let's assume unicast
-			setDeliveryType( DeliveryType.unicast );
+    int layers;
 
-		if ( transportProtocol == TransportProtocol.RDT
-				&& deliveryType == DeliveryType.None )
-			// If it's not specified, let's assume unicast
-			setDeliveryType( DeliveryType.unicast );
+    boolean append;
 
-	}
+    int ttl;
 
-	public String toString()
-	{
-		StringBuilder sb = new StringBuilder();
-		if ( transportProtocol == TransportProtocol.RDT ) {
-			// RDT is a little bit "special"
-			sb.append( "x-real-rdt" );
+    int[] port = new int[2];
 
-			if ( lowerTransport != LowerTransport.None )
-				sb.append( "/" ).append( lowerTransport.toString().toLowerCase() );
-			
-			if ( deliveryType == DeliveryType.multicast )
-				sb.append( "/mcast" );
+    int[] client_port = new int[2];
 
-		} else {
-			sb.append( transportProtocol );
-			if ( profile != Profile.None ) {
-				sb.append( "/" ).append( profile );
-				if ( !Config.proxyLowerTransportSuppress.getValue() 
-						&& lowerTransport != LowerTransport.None )
-					sb.append( "/" ).append( lowerTransport );
-			}
-			if ( deliveryType != DeliveryType.None )
-				sb.append( ";" ).append( deliveryType );
-		}
-		if ( destination != null )
-			sb.append( ";destination=" ).append( destination );
-		if ( interleaved != null )
-			sb.append( ";interleaved=" ).append( interleaved );
-		if ( append )
-			sb.append( ";append" );
-		if ( layers > 0 )
-			sb.append( ";layers=" ).append( layers );
-		if ( ttl > 0 )
-			sb.append( ";ttl=" ).append( ttl );
-		if ( port[0] > 0 ) {
-			sb.append( ";port=" ).append( port[0] );
-			if ( port[1] > 0 )
-				sb.append( "-" ).append( port[1] );
-		}
-		if ( client_port[0] > 0 ) {
-			sb.append( ";client_port=" ).append( client_port[0] );
-			if ( client_port[1] > 0 )
-				sb.append( "-" ).append( client_port[1] );
-		}
-		if ( server_port[0] > 0 ) {
-			sb.append( ";server_port=" ).append( server_port[0] );
-			if ( server_port[1] > 0 )
-				sb.append( "-" ).append( server_port[1] );
-		}
-		
-		if(!Config.proxyRtspTransportSsrcDisable.getValue())
-			if ( ssrc != null )
-				sb.append( ";ssrc=" ).append( ssrc );
-		if(!Config.proxyRtspTransportSourceDisable.getValue())
-			if ( source != null )
-				sb.append( ";source=" ).append( source );
-		
-		if ( mode != Mode.None )
-			sb.append( ";mode=\"" ).append( mode ) . append("\"");
-		return sb.toString();
-	}
+    int[] server_port = new int[2];
 
-	/**
-	 * Test if the specified transport can be used by the proxy.
-	 * 
-	 * @return
-	 */
-	public boolean isSupportedByProxy()
-	{
-		/*
-		 * At now, the only transport supported by the server is
-		 * "RTP/AVP/UDP;unicast"
-		 */
-		if ( Config.proxyTransportRtpEnable.getValue()
-				&& transportProtocol == TransportProtocol.RTP && profile == Profile.AVP
-				&& lowerTransport == LowerTransport.UDP
-				&& deliveryType == DeliveryType.unicast )
-			return true;
-		else
-			if ( Config.proxyTransportRdtEnable.getValue()
-					&& transportProtocol == TransportProtocol.RDT
-					&& lowerTransport == LowerTransport.UDP
-					&& deliveryType == DeliveryType.unicast )
-				return true;
-			else
-				return false;
-	}
+    String ssrc;
 
-	/**
-	 * @return Returns the append.
-	 */
-	public boolean isAppend()
-	{
-		return append;
-	}
+    Mode mode = Mode.None;
 
-	/**
-	 * @param append
-	 *        The append to set.
-	 */
-	public void setAppend( boolean append )
-	{
-		this.append = append;
-	}
+    String source;
 
-	/**
-	 * @return Returns the client_port.
-	 */
-	public int[] getClientPort()
-	{
-		return client_port;
-	}
+    /**
+     * Constructor. Creates a RtspTransport object from a transport header
+     * string.
+     */
+    public RtspTransport( String transport )
+    {
+        transportProtocol = TransportProtocol.None;
+        profile = Profile.None;
+        lowerTransport = LowerTransport.None;
+        deliveryType = DeliveryType.None;
+        destination = null;
+        interleaved = null;
+        layers = 0;
+        append = false;
+        ttl = 0;
+        port[0] = 0;
+        port[1] = 0;
+        client_port[0] = 0;
+        client_port[1] = 0;
+        server_port[0] = 0;
+        server_port[1] = 0;
+        ssrc = null;
+        mode = Mode.None;
+        source = null;
 
-	/**
-	 * @param client_port
-	 *        The client_port to set.
-	 */
-	public void setClientPort( int[] client_port )
-	{
-		this.client_port = client_port;
-	}
+        parseTransport( transport );
+    }
 
-	/**
-	 * @param client_port
-	 *        The client_port to set.
-	 */
-	public void setClientPort( int client_port )
-	{
-		this.client_port = new int[] { client_port, 0 };
-	}
+    private void parseTransport( String transport )
+    {
+        for ( String tok : transport.split( ";" ) ) {
 
-	/**
-	 * @return Returns the deliveryType.
-	 */
-	public DeliveryType getDeliveryType()
-	{
-		return deliveryType;
-	}
+            // First check for the transport protocol
+            if ( tok.startsWith( "RTP" ) || tok.startsWith( "RDT" )
+                    || tok.startsWith( "x-real-rdt" ) ) {
+                String[] tpl = tok.split( "/" );
+                transportProtocol = TransportProtocol.fromString( tpl[0] );
+                if ( tpl.length > 1 )
+                    try {
+                        profile = Profile.valueOf( tpl[1] );
+                    } catch ( Exception e ) {
+                        profile = Profile.None;
+                    }
 
-	/**
-	 * @param deliveryType
-	 *        The deliveryType to set.
-	 */
-	public void setDeliveryType( DeliveryType deliveryType )
-	{
-		this.deliveryType = deliveryType;
-	}
+                if ( profile == Profile.None ) {
+                    // Maybe this is a lower transport definition
+                    lowerTransport = LowerTransport.fromString( tpl[1] );
+                }
 
-	/**
-	 * @return Returns the destination.
-	 */
-	public String getDestination()
-	{
-		return destination;
-	}
+                if ( tpl.length > 2 )
+                    lowerTransport = LowerTransport.valueOf( tpl[2] );
+                continue;
+            }
 
-	/**
-	 * @param destination
-	 *        The destination to set.
-	 */
-	public void setDestination( String destination )
-	{
-		this.destination = destination;
-	}
+            if ( tok.compareToIgnoreCase( "unicast" ) == 0 )
+                deliveryType = DeliveryType.unicast;
+            else if ( tok.compareToIgnoreCase( "multicast" ) == 0 )
+                deliveryType = DeliveryType.multicast;
+            else if ( tok.startsWith( "destination" ) )
+                setDestination( _getStrValue( tok ) );
+            else if ( tok.startsWith( "interleaved" ) )
+                setInterleaved( _getStrValue( tok ) );
+            else if ( tok.startsWith( "append" ) )
+                setAppend( true );
+            else if ( tok.startsWith( "layers" ) )
+                setLayers( Integer.valueOf( _getStrValue( tok ) ) );
+            else if ( tok.startsWith( "ttl" ) )
+                setTTL( Integer.valueOf( _getStrValue( tok ) ) );
+            else if ( tok.startsWith( "port" ) )
+                setPort( _getPairValue( tok ) );
+            else if ( tok.startsWith( "client_port" ) )
+                setClientPort( _getPairValue( tok ) );
+            else if ( tok.startsWith( "server_port" ) )
+                setServerPort( _getPairValue( tok ) );
+            else if ( tok.startsWith( "ssrc" ) )
+                setSSRC( _getStrValue( tok ) );
+            else if ( tok.startsWith( "mode" ) )
+                setMode( Mode.fromString( _getStrValue( tok ) ) );
+            else if ( tok.startsWith( "source" ) )
+                setSource( _getStrValue( tok ) );
+        }
 
-	/**
-	 * @return Returns the interleaved.
-	 */
-	public String getInterleaved()
-	{
-		return interleaved;
-	}
+        if ( transportProtocol == TransportProtocol.RTP
+                && lowerTransport == LowerTransport.None )
+            // If it's not specified, let's assume UDP
+            setLowerTransport( LowerTransport.UDP );
 
-	/**
-	 * @param interleaved
-	 *        The interleaved to set.
-	 */
-	public void setInterleaved( String interleaved )
-	{
-		this.interleaved = interleaved;
-	}
+        if ( transportProtocol == TransportProtocol.RTP
+                && deliveryType == DeliveryType.None )
+            // If it's not specified, let's assume unicast
+            setDeliveryType( DeliveryType.unicast );
 
-	/**
-	 * @return Returns the layers.
-	 */
-	public int getLayers()
-	{
-		return layers;
-	}
+        if ( transportProtocol == TransportProtocol.RDT
+                && deliveryType == DeliveryType.None )
+            // If it's not specified, let's assume unicast
+            setDeliveryType( DeliveryType.unicast );
 
-	/**
-	 * @param layers
-	 *        The layers to set.
-	 */
-	public void setLayers( int layers )
-	{
-		this.layers = layers;
-	}
+    }
 
-	/**
-	 * @return Returns the lowerTransport.
-	 */
-	public LowerTransport getLowerTransport()
-	{
-		return lowerTransport;
-	}
+    @Override
+    public String toString()
+    {
+        final StringBuilder sb = new StringBuilder();
+        if ( transportProtocol == TransportProtocol.RDT ) {
+            // RDT is a little bit "special"
+            sb.append( "x-real-rdt" );
 
-	/**
-	 * @param lowerTransport
-	 *        The lowerTransport to set.
-	 */
-	public void setLowerTransport( LowerTransport lowerTransport )
-	{
-		this.lowerTransport = lowerTransport;
-	}
+            if ( lowerTransport != LowerTransport.None )
+                sb.append( '/' ).append( lowerTransport.toString().toLowerCase() );
 
-	/**
-	 * @return Returns the mode.
-	 */
-	public Mode getMode()
-	{
-		return mode;
-	}
+            if ( deliveryType == DeliveryType.multicast )
+                sb.append( "/mcast" );
 
-	/**
-	 * Set the mode. The 
-	 * @param mode
-	 *        The mode to set.
-	 */
-	public void setMode( Mode mode )
-	{
-		this.mode = mode;
-	}
+        } else {
+            sb.append( transportProtocol );
+            if ( profile != Profile.None ) {
+                sb.append( '/' ).append( profile );
+                if ( !Config.proxyLowerTransportSuppress.getValue()
+                        && lowerTransport != LowerTransport.None )
+                    sb.append( '/' ).append( lowerTransport );
+            }
+            if ( deliveryType != DeliveryType.None )
+                sb.append( ';' ).append( deliveryType );
+        }
+        if ( destination != null )
+            sb.append( ";destination=" ).append( destination );
+        if ( interleaved != null )
+            sb.append( ";interleaved=" ).append( interleaved );
+        if ( append )
+            sb.append( ";append" );
+        if ( layers > 0 )
+            sb.append( ";layers=" ).append( layers );
+        if ( ttl > 0 )
+            sb.append( ";ttl=" ).append( ttl );
+        if ( port[0] > 0 ) {
+            sb.append( ";port=" ).append( port[0] );
+            if ( port[1] > 0 )
+                sb.append( '-' ).append( port[1] );
+        }
+        if ( client_port[0] > 0 ) {
+            sb.append( ";client_port=" ).append( client_port[0] );
+            if ( client_port[1] > 0 )
+                sb.append( '-' ).append( client_port[1] );
+        }
+        if ( server_port[0] > 0 ) {
+            sb.append( ";server_port=" ).append( server_port[0] );
+            if ( server_port[1] > 0 )
+                sb.append( '-' ).append( server_port[1] );
+        }
 
-	/**
-	 * @return Returns the port.
-	 */
-	public int[] getPort()
-	{
-		return port;
-	}
+        if ( !Config.proxyRtspTransportSsrcDisable.getValue() )
+            if ( ssrc != null )
+                sb.append( ";ssrc=" ).append( ssrc );
+        if ( !Config.proxyRtspTransportSourceDisable.getValue() )
+            if ( source != null )
+                sb.append( ";source=" ).append( source );
 
-	/**
-	 * @param port
-	 *        The port to set.
-	 */
-	public void setPort( int[] port )
-	{
-		this.port = port;
-	}
+        if ( mode != Mode.None )
+            sb.append( ";mode=\"" ).append( mode ).append( '"' );
+        return sb.toString();
+    }
 
-	/**
-	 * @return Returns the profile.
-	 */
-	public Profile getProfile()
-	{
-		return profile;
-	}
+    /**
+     * Test if the specified transport can be used by the proxy.
+     * 
+     * @return
+     */
+    public boolean isSupportedByProxy()
+    {
+        /*
+         * At now, the only transport supported by the server is
+         * "RTP/AVP/UDP;unicast"
+         */
+        if ( Config.proxyTransportRtpEnable.getValue()
+                && transportProtocol == TransportProtocol.RTP && profile == Profile.AVP
+                && lowerTransport == LowerTransport.UDP
+                && deliveryType == DeliveryType.unicast )
+            return true;
+        else if ( Config.proxyTransportRdtEnable.getValue()
+                && transportProtocol == TransportProtocol.RDT
+                && lowerTransport == LowerTransport.UDP
+                && deliveryType == DeliveryType.unicast )
+            return true;
+        else
+            return false;
+    }
 
-	/**
-	 * @param profile
-	 *        The profile to set.
-	 */
-	public void setProfile( Profile profile )
-	{
-		this.profile = profile;
-	}
+    /**
+     * @return Returns the append.
+     */
+    public boolean isAppend()
+    {
+        return append;
+    }
 
-	/**
-	 * @return Returns the server_port.
-	 */
-	public int[] getServerPort()
-	{
-		return server_port;
-	}
+    /**
+     * @param append
+     *            The append to set.
+     */
+    public void setAppend( boolean append )
+    {
+        this.append = append;
+    }
 
-	/**
-	 * @param server_port
-	 *        The server_port to set.
-	 */
-	public void setServerPort( int[] server_port )
-	{
-		this.server_port = server_port;
-	}
+    /**
+     * @return Returns the client_port.
+     */
+    public int[] getClientPort()
+    {
+        return client_port;
+    }
 
-	/**
-	 * @param server_port
-	 *        The server_port to set.
-	 */
-	public void setServerPort( int server_port )
-	{
-		this.server_port = new int[] { server_port, 0 };
-	}
+    /**
+     * @param client_port
+     *            The client_port to set.
+     */
+    public void setClientPort( int[] client_port )
+    {
+        this.client_port = client_port;
+    }
 
-	/**
-	 * @return Returns the ssrc.
-	 */
-	public String getSSRC()
-	{
-		return ssrc;
-	}
+    /**
+     * @param client_port
+     *            The client_port to set.
+     */
+    public void setClientPort( int client_port )
+    {
+        this.client_port = new int[] { client_port, 0 };
+    }
 
-	/**
-	 * @param ssrc
-	 *        The ssrc to set.
-	 */
-	public void setSSRC( String ssrc )
-	{
-		this.ssrc = ssrc;
-	}
+    /**
+     * @return Returns the deliveryType.
+     */
+    public DeliveryType getDeliveryType()
+    {
+        return deliveryType;
+    }
 
-	/**
-	 * @param ssrc
-	 *        The ssrc to set.
-	 */
-	public void setSSRC( long ssrc )
-	{
-		this.ssrc = Long.toHexString( ssrc & 0xFFFFFFFFL ).toUpperCase();
-	}
+    /**
+     * @param deliveryType
+     *            The deliveryType to set.
+     */
+    public void setDeliveryType( DeliveryType deliveryType )
+    {
+        this.deliveryType = deliveryType;
+    }
 
-	/**
-	 * @return Returns the transportProtocol.
-	 */
-	public TransportProtocol getTransportProtocol()
-	{
-		return transportProtocol;
-	}
+    /**
+     * @return Returns the destination.
+     */
+    public String getDestination()
+    {
+        return destination;
+    }
 
-	/**
-	 * @param transportProtocol
-	 *        The transportProtocol to set.
-	 */
-	public void setTransportProtocol( TransportProtocol transportProtocol )
-	{
-		this.transportProtocol = transportProtocol;
-	}
+    /**
+     * @param destination
+     *            The destination to set.
+     */
+    public void setDestination( String destination )
+    {
+        this.destination = destination;
+    }
 
-	/**
-	 * @return Returns the ttl.
-	 */
-	public int getTTL()
-	{
-		return ttl;
-	}
+    /**
+     * @return Returns the interleaved.
+     */
+    public String getInterleaved()
+    {
+        return interleaved;
+    }
 
-	/**
-	 * @param ttl
-	 *        The ttl to set.
-	 */
-	public void setTTL( int ttl )
-	{
-		this.ttl = ttl;
-	}
+    /**
+     * @param interleaved
+     *            The interleaved to set.
+     */
+    public void setInterleaved( String interleaved )
+    {
+        this.interleaved = interleaved;
+    }
 
-	public void setSource( String source )
-	{
-		this.source = source;
-	}
+    /**
+     * @return Returns the layers.
+     */
+    public int getLayers()
+    {
+        return layers;
+    }
 
-	public String getSource()
-	{
-		return source;
-	}
+    /**
+     * @param layers
+     *            The layers to set.
+     */
+    public void setLayers( int layers )
+    {
+        this.layers = layers;
+    }
 
-	/**
-	 * Get the value part in a string like:
-	 * 
-	 * <pre>
-	 * key = value
-	 * </pre>
-	 * 
-	 * @param str
-	 *        the content string
-	 * @return a String containing only the value
-	 */
-	private static String _getStrValue( String str )
-	{
-		String val = null;
-		
-		String[] list = str.split( "=" );
-		if ( list.length != 2 )
-			return null;
+    /**
+     * @return Returns the lowerTransport.
+     */
+    public LowerTransport getLowerTransport()
+    {
+        return lowerTransport;
+    }
 
-		val = list[1];
-		if(val.startsWith("\"") && val.endsWith("\""))
-			val = val.substring(1, val.length()-2);
-		
-		return val;
-	}
+    /**
+     * @param lowerTransport
+     *            The lowerTransport to set.
+     */
+    public void setLowerTransport( LowerTransport lowerTransport )
+    {
+        this.lowerTransport = lowerTransport;
+    }
 
-	/**
-	 * Get the value part in a string like:
-	 * 
-	 * <pre>
-	 * key = 6344 - 6345
-	 * </pre>
-	 * 
-	 * @param str
-	 *        the content string
-	 * @return a int[2] containing only the value
-	 */
-	private static int[] _getPairValue( String str )
-	{
-		int[] pair = { 0, 0 };
-		String[] list = str.split( "=" );
-		if ( list.length != 2 )
-			return pair;
+    /**
+     * @return Returns the mode.
+     */
+    public Mode getMode()
+    {
+        return mode;
+    }
 
-		try {
-			pair[0] = Integer.parseInt( list[1].split( "-" )[0] );
-			pair[1] = Integer.parseInt( list[1].split( "-" )[1] );
+    /**
+     * Set the mode. The
+     * 
+     * @param mode
+     *            The mode to set.
+     */
+    public void setMode( Mode mode )
+    {
+        this.mode = mode;
+    }
 
-			// log.debug("Client ports: " + 1);
-			// Integers.parse();
+    /**
+     * @return Returns the port.
+     */
+    public int[] getPort()
+    {
+        return port;
+    }
 
-		} catch ( Exception e ) {
-			return pair;
-		}
-		return pair;
-	}
+    /**
+     * @param port
+     *            The port to set.
+     */
+    public void setPort( int[] port )
+    {
+        this.port = port;
+    }
+
+    /**
+     * @return Returns the profile.
+     */
+    public Profile getProfile()
+    {
+        return profile;
+    }
+
+    /**
+     * @param profile
+     *            The profile to set.
+     */
+    public void setProfile( Profile profile )
+    {
+        this.profile = profile;
+    }
+
+    /**
+     * @return Returns the server_port.
+     */
+    public int[] getServerPort()
+    {
+        return server_port;
+    }
+
+    /**
+     * @param server_port
+     *            The server_port to set.
+     */
+    public void setServerPort( int[] server_port )
+    {
+        this.server_port = server_port;
+    }
+
+    /**
+     * @param server_port
+     *            The server_port to set.
+     */
+    public void setServerPort( int server_port )
+    {
+        this.server_port = new int[] { server_port, 0 };
+    }
+
+    /**
+     * @return Returns the ssrc.
+     */
+    public String getSSRC()
+    {
+        return ssrc;
+    }
+
+    /**
+     * @param ssrc
+     *            The ssrc to set.
+     */
+    public void setSSRC( String ssrc )
+    {
+        this.ssrc = ssrc;
+    }
+
+    /**
+     * @param ssrc
+     *            The ssrc to set.
+     */
+    public void setSSRC( long ssrc )
+    {
+        this.ssrc = Long.toHexString( ssrc & 0xFFFFFFFFL ).toUpperCase();
+    }
+
+    /**
+     * @return Returns the transportProtocol.
+     */
+    public TransportProtocol getTransportProtocol()
+    {
+        return transportProtocol;
+    }
+
+    /**
+     * @param transportProtocol
+     *            The transportProtocol to set.
+     */
+    public void setTransportProtocol( TransportProtocol transportProtocol )
+    {
+        this.transportProtocol = transportProtocol;
+    }
+
+    /**
+     * @return Returns the ttl.
+     */
+    public int getTTL()
+    {
+        return ttl;
+    }
+
+    /**
+     * @param ttl
+     *            The ttl to set.
+     */
+    public void setTTL( int ttl )
+    {
+        this.ttl = ttl;
+    }
+
+    public void setSource( String source )
+    {
+        this.source = source;
+    }
+
+    public String getSource()
+    {
+        return source;
+    }
+
+    /**
+     * Get the value part in a string like:
+     * 
+     * <pre>
+     * key = value
+     * </pre>
+     * 
+     * @param str
+     *            the content string
+     * @return a String containing only the value
+     */
+    private static String _getStrValue( String str )
+    {
+        String val = null;
+
+        String[] list = str.split( "=" );
+        if ( list.length != 2 )
+            return null;
+
+        val = list[1];
+        if ( val.startsWith( "\"" ) && val.endsWith( "\"" ) )
+            val = val.substring( 1, val.length() - 2 );
+
+        return val;
+    }
+
+    /**
+     * Get the value part in a string like:
+     * 
+     * <pre>
+     * key = 6344 - 6345
+     * </pre>
+     * 
+     * @param str
+     *            the content string
+     * @return a int[2] containing only the value
+     */
+    private static int[] _getPairValue( String str )
+    {
+        int[] pair = { 0, 0 };
+        String[] list = str.split( "=" );
+        if ( list.length != 2 )
+            return pair;
+
+        try {
+            pair[0] = Integer.parseInt( list[1].split( "-" )[0] );
+            pair[1] = Integer.parseInt( list[1].split( "-" )[1] );
+
+            // log.debug("Client ports: {}", 1);
+            // Integers.parse();
+
+        } catch ( Exception e ) {
+            return pair;
+        }
+        return pair;
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java	2006-04-14 15:41:06 UTC (rev 415)
@@ -62,14 +62,15 @@
 		return transportList.size();
 	}
 
-	public String toString()
+	@Override
+    public String toString()
 	{
-		StringBuilder buf = new StringBuilder();
+		final StringBuilder buf = new StringBuilder();
 		int i = 0;
-		for ( RtspTransport t : transportList ) {
+		for ( RtspTransport transport : transportList ) {
 			if ( i++ != 0 )
-				buf.append( "," );
-			buf.append( t.toString() );
+				buf.append( ',' );
+			buf.append( transport.toString() );
 		}
 		return buf.toString();
 	}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/package.html
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/package.html	2006-02-07 23:40:28 UTC (rev 414)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/package.html	2006-04-14 15:41:06 UTC (rev 415)
@@ -10,4 +10,4 @@
 <!-- $URL$ -->
 RTSP implementation classes.
 </body>
-</html>
\ No newline at end of file
+</html>



From merlimat at berlios.de  Tue Apr 25 23:50:46 2006
From: merlimat at berlios.de (merlimat at berlios.de)
Date: Tue, 25 Apr 2006 23:50:46 +0200
Subject: [Rtspproxy-devel] r416 - in trunk: . RTSPProxy-App RTSPProxy-App/src/main/java/rtspproxy/filter/accounting RTSPProxy-App/src/main/java/rtspproxy/filter/authentication RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite RTSPProxy-App/src/resources/conf RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress RTSPProxy-Core RTSPProxy-Core/src RTSPProxy-Core/src/main/java/gov/nist/core RTSPProxy-Core/src/main/java/gov/nist/javax/sdp RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser RTSPProxy-Core/src/main/java/javax/sdp RTSPProxy-Core/src/main/java/rtspproxy RTSPProxy-Core/src/main/java/rtspproxy/config RTSPProxy-Core/src/main/java/rtspproxy/filter RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme RTSPProxy-Core/src/main/java/rtspproxy/filte!
 r/control RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking RTSPProxy-Core/src/main/java/rtspproxy/jmx RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans RTSPProxy-Core/src/main/java/rtspproxy/lib RTSPProxy-Core/src/main/java/rtspproxy/lib/number RTSPProxy-Core/src/main/java/rtspproxy/proxy RTSPProxy-Core/src/main/java/rtspproxy/proxy/track RTSPProxy-Core/src/main/java/rtspproxy/rdt RTSPProxy-Core/src/main/java/rtspproxy/rtp/range RTSPProxy-Core/src/main/java/rtspproxy/rtsp RTSPProxy-Core/src/test/java/rtspproxy/lib/number RTSPProxy-Core/src/test/java/rtspproxy/rdt RTSPProxy-Core/src/test/java/rtspproxy/rtsp RTSPProxy-Core/src/test/resources/rtspproxy/rdt RTSPProxy-OSGi src/changes src/site
Message-ID: <200604252150.k3PLokxI002763@sheep.berlios.de>

Author: merlimat
Date: 2006-04-25 23:47:58 +0200 (Tue, 25 Apr 2006)
New Revision: 416

Added:
   trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/IpAddressPattern.java
   trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/RewriteMapping.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Mx4jLoggerWrapper.java
Removed:
   trunk/RTSPProxy-Core/src/changes/
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfig.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProviderAdapter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java
Modified:
   trunk/RTSPProxy-App/pom.xml
   trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java
   trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/authentication/SimpleAuthenticationProvider.java
   trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/SimpleIpAddressProvider.java
   trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/SimpleUrlRewritingProvider.java
   trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml
   trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml
   trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java
   trunk/RTSPProxy-Core/pom.xml
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Debug.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/GenericObject.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/GenericObjectList.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Host.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/HostNameParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/HostPort.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/InternalErrorHandler.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/LexerCore.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/LogWriter.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Match.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/NameValue.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/NameValueList.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/PackageNames.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/ParserCore.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Separators.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/StringTokenizer.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Token.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/SdpEncoderImpl.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/SessionDescriptionImpl.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/TimeDescriptionImpl.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/AttributeField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/BandwidthField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ConnectionAddress.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ConnectionField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/Email.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/EmailAddress.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/EmailField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/Indentation.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/InformationField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/KeyField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/MediaField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/OriginField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/PhoneField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ProtoVersionField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/RepeatField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPFieldList.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPFieldNames.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPFormat.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPKeywords.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPObject.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPObjectList.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SessionNameField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/TimeField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/TypedTime.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/URIField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ZoneAdjustment.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ZoneField.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/AttributeFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/BandwidthFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/ConnectionFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/EmailFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/InformationFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/KeyFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/Lexer.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/MediaFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/OriginFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/ParserFactory.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/PhoneFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/ProtoVersionFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/RepeatFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/SDPAnnounceParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/SDPParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/SessionNameFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/TimeFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/URIFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/ZoneFieldParser.java
   trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProvider.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspClientFilters.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspServerFilters.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingProviderAdapter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProvider.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProviderAdapter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress/IpAddressFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress/IpAddressProvider.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingProvider.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingResult.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable2.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/Filter.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/FilterMBean.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/PortrangeRtpServerFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/PortrangeRtpServerFactoryMBean.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/PortrangeRtpSession.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/PortrangeRtpSessionMBean.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/ProxySessionFacade.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/ProxySessionFacadeMBean.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedByte.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyConstants.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtAckPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtControlPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtDataPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtLatencyReportPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtProtocolCodecFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtProtocolDecoder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtProtocolEncoder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtRttRequestPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtRttResponsePacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtStreamEndPacket.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpRtcpFilterChainBuilder.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java
   trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/lib/number/UnsignedByteTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/lib/number/UnsignedIntTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/lib/number/UnsignedLongTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/lib/number/UnsignedShortTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/BufferUtils.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtAckPacketTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtDataPacketTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtLatencyRepostPacketTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtRttRequestPacketTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtRttResponsePacketTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtStreamEndPacketTest.java
   trunk/RTSPProxy-Core/src/test/java/rtspproxy/rtsp/RtspTransportTest.java
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtAckPacket.txt
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtDataPacketDataPacket.txt
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtDataPacketStream0.txt
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtDataPacketStream1.txt
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtLatencyReportWithDataPacket.txt
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtRttRequestPacket.txt
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtRttResponsePacket.txt
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtStreamEndPacketStream0.txt
   trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtStreamEndPacketStream1.txt
   trunk/RTSPProxy-OSGi/pom.xml
   trunk/pom.xml
   trunk/src/changes/changes.xml
   trunk/src/site/site.xml
Log:
Another 'all-in-one' change-set. (Hope it'll be the last one). The filters 
are now working with the new configuration system, again XML but using 
Commons-Configuration instead of plain dom4j. Many updates to project 
descriptors too.



Modified: trunk/RTSPProxy-App/pom.xml
===================================================================
--- trunk/RTSPProxy-App/pom.xml	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/pom.xml	2006-04-25 21:47:58 UTC (rev 416)
@@ -11,64 +11,30 @@
 		<groupId>net.merlimat</groupId>
 		<artifactId>rtspproxy</artifactId>
 		<version>3.0-ALPHA5-SNAPSHOT</version>
-		<!--	<relativePath>../pom.xml</relativePath> -->
+		<relativePath>../pom.xml</relativePath>
 	</parent>
 
 	<modelVersion>4.0.0</modelVersion>
 
 	<name>RTSP Proxy standalone application</name>
-	<groupId>net.merlimat</groupId>
-	<artifactId>RTSPProxy-App</artifactId>
-	<version>3.0-ALPHA5-SNAPSHOT</version>
-	<url>http://rtspproxy.berlios.de</url>
-	<inceptionYear>2003</inceptionYear>
+	<artifactId>RTSPProxy-App</artifactId>?
 
-
 	<dependencies>
 		<dependency>
 			<groupId>net.merlimat</groupId>
 			<artifactId>RTSPProxy-Core</artifactId>
 			<version>3.0-ALPHA5-SNAPSHOT</version>
-		</dependency>
-		
-		<dependency>
-			<groupId>junit</groupId>
-			<artifactId>junit</artifactId>
-			<version>3.8.1</version>
-			<scope>test</scope>
-		</dependency>
-		
+		</dependency>		
 	</dependencies>
 
 
 	<build>
 		<defaultGoal>assembly:directory</defaultGoal>
 
-		<resources>
-			<resource>
-				<directory>src/main/resources</directory>
-				<filtering>true</filtering>
-			</resource>
-		</resources>
-
 		<plugins>
 			<plugin>
 				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-compiler-plugin</artifactId>
-				<configuration>
-					<source>1.5</source>
-					<target>1.5</target>
-					<showWarnings>true</showWarnings>
-				</configuration>
-			</plugin>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
 				<artifactId>maven-assembly-plugin</artifactId>
-				<configuration>
-					<descriptor>
-						src/resources/release/default.xml
-					</descriptor>
-				</configuration>
 			</plugin>
 		</plugins>
 	</build>

Modified: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/accounting/SimpleAccountingProvider.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -3,13 +3,15 @@
 import java.net.InetSocketAddress;
 import java.text.SimpleDateFormat;
 import java.util.Date;
-import java.util.List;
+import java.util.Observable;
+import java.util.Observer;
 
-import org.apache.log4j.Logger;
+import org.apache.commons.configuration.Configuration;
 import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import rtspproxy.config.AAAConfigurable;
+import rtspproxy.config.StringParameter;
 import rtspproxy.filter.authentication.AuthenticationFilter;
 import rtspproxy.rtsp.RtspMessage;
 import rtspproxy.rtsp.RtspRequest;
@@ -18,26 +20,58 @@
  * @author Matteo Merli
  */
 public class SimpleAccountingProvider extends AccountingProviderAdapter implements
-        AccountingProvider, AAAConfigurable
+        Observer
 {
 
-    private static SimpleDateFormat format = new SimpleDateFormat(
+    private static final SimpleDateFormat format = new SimpleDateFormat(
             "yyyy-MM-dd HH:mm:ss Z" );
 
+    private static Logger log = LoggerFactory.getLogger( SimpleAccountingProvider.class );
+
     // This is not static since it's a separate log
-    private Logger accessLog;
+    private Logger accessLog = null;
 
+    private final StringParameter loggerCatergory;
+
     public SimpleAccountingProvider()
     {
-        accessLog = Logger.getLogger( "accessLog" );
+        loggerCatergory = new StringParameter( "filters.accounting.category", // name
+                "accessLog", // default value
+                true, // mutable
+                "Log4j category name for the accounting log." );
+        
+        loggerCatergory.addObserver( this );
     }
 
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#start()
+     */
+    public void start() throws Exception
+    {
+        accessLog = LoggerFactory.getLogger( loggerCatergory.getValue() );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#stop()
+     */
+    public void stop()
+    {
+        accessLog = null;
+    }
+
     @Override
     public void messageReceived( IoSession session, RtspMessage message )
     {
+        if ( accessLog == null )
+            return;
+
         StringBuilder logMessage = new StringBuilder();
         if ( message instanceof RtspRequest ) {
-            logMessage.append( ((RtspRequest) message).getVerb() ).append( " " );
+            logMessage.append( ((RtspRequest) message).getVerb() ).append( ' ' );
             logMessage.append( ((RtspRequest) message).getUrl() );
         }
         accessLog.info( buildLogMessage( session, message, logMessage ) );
@@ -46,6 +80,9 @@
     @Override
     public void messageSent( IoSession session, RtspMessage message )
     {
+        if ( accessLog == null )
+            return;
+
         StringBuilder logMessage = new StringBuilder();
         accessLog.info( buildLogMessage( session, message, logMessage ) );
     }
@@ -54,7 +91,7 @@
             StringBuilder logMessage )
     {
         StringBuilder sb = new StringBuilder( 150 );
-        String userName = (String) session.getAttribute( AuthenticationFilter.ATTR );
+        String userName = (String) session.getAttribute( AuthenticationFilter.getAttrName() );
         String userAgent = message.getHeader( "User-Agent" );
         Date now = new Date();
         String dateString = format.format( now );
@@ -72,17 +109,31 @@
         return sb.toString();
     }
 
-    public void configure( List<Element> configElements ) throws Exception
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#configure(org.apache.commons.configuration.Configuration)
+     */
+    public void configure( Configuration configuration ) throws Exception
     {
-        for ( Element el : configElements ) {
-            if ( el.getName().equals( "category" ) ) {
-                String category = el.getTextTrim();
+        loggerCatergory.readConfiguration( configuration );
+    }
 
-                if ( category == null || category.length() == 0 )
-                    throw new IllegalArgumentException( "invalid log category given" );
-
-                accessLog = Logger.getLogger( category );
-            }
+    /*
+     * (non-Javadoc)
+     * 
+     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
+     */
+    public void update( Observable o, Object arg )
+    {
+        if ( o != loggerCatergory )
+            return;
+        
+        try {
+            stop();
+            start();
+        } catch ( Exception e ) {
+            log.error( "Error restarting SimpleAccountingProvider" );
         }
     }
 }

Modified: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/authentication/SimpleAuthenticationProvider.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/authentication/SimpleAuthenticationProvider.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/authentication/SimpleAuthenticationProvider.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -18,70 +18,97 @@
 
 package rtspproxy.filter.authentication;
 
-import java.util.List;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.util.Observable;
+import java.util.Observer;
 import java.util.Properties;
 
-import org.apache.log4j.Logger;
-import org.dom4j.Element;
+import org.apache.commons.configuration.Configuration;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import rtspproxy.config.AAAConfigurable;
-import rtspproxy.filter.GenericProviderAdapter;
+import rtspproxy.config.StringParameter;
 import rtspproxy.filter.authentication.scheme.Credentials;
 
 /**
  * @author Matteo Merli
  */
-public class SimpleAuthenticationProvider extends GenericProviderAdapter
-		implements AuthenticationProvider, AAAConfigurable {
+public class SimpleAuthenticationProvider implements AuthenticationProvider, Observer
+{
 
-	private static Logger log = Logger
-			.getLogger(SimpleAuthenticationProvider.class);
+    private static Logger log = LoggerFactory
+            .getLogger( SimpleAuthenticationProvider.class );
 
-	private Properties usersDb = new Properties();
+    private final StringParameter usersDbParameter;
 
-	public String getPassword(String username) {
-		return usersDb.getProperty(username);
-	}
+    private final Properties usersDb = new Properties();
 
-	public boolean isAuthenticated(Credentials credentials) {
-		String storedPassword = usersDb.getProperty(credentials.getUserName());
-		if (storedPassword == null)
-			// User is not present
-			return false;
+    public SimpleAuthenticationProvider()
+    {
+        usersDbParameter = new StringParameter( "filters.authentication.usersFile", // name
+                "conf/user.properties", // default value
+                true, // mutable
+                "" );
 
-		if (storedPassword.compareTo(credentials.getPassword()) == 0)
-			// Password is ok
-			return true;
-		else
-			// Password is wrong
-			return false;
-	}
+        usersDbParameter.addObserver( this );
+    }
 
-	public void configure(List<Element> configElements) throws Exception {
-		for (Element el : configElements) {
-			if (el.getName().equals("user")) {
-				Element nameEl = el.element("name");
-				Element passwordEl = el.element("password");
+    public void start() throws Exception
+    {
+        // Read user database
+        try {
+            String fileName = usersDbParameter.getValue();
+            InputStream is = new FileInputStream( fileName );
+            usersDb.load( is );
 
-				if (nameEl == null)
-					throw new IllegalArgumentException(
-							"no name element available in user configuration");
-				if (passwordEl == null)
-					throw new IllegalArgumentException(
-							"no password element available in user configuration");
+        } catch ( Exception e ) {
+            log.error( "Error reading users DB: " + e );
+        }
+    }
 
-				String name = nameEl.getTextTrim();
-				String password = passwordEl.getTextTrim();
+    public void stop()
+    {
+        usersDb.clear();
+    }
 
-				if (name == null || name.length() == 0)
-					throw new IllegalArgumentException("invalid username given");
-				if (password == null || password.length() == 0)
-					throw new IllegalArgumentException("invalid password given");
+    public String getPassword( String username )
+    {
+        return usersDb.getProperty( username );
+    }
 
-				log.debug("adding user " + name + " with password " + password);
-				this.usersDb.put(name, password);
-			}
-		}
-	}
+    public boolean isAuthenticated( Credentials credentials )
+    {
+        String storedPassword = usersDb.getProperty( credentials.getUserName() );
+        if ( storedPassword == null )
+            // User is not present
+            return false;
 
+        if ( storedPassword.compareTo( credentials.getPassword() ) == 0 )
+            // Password is ok
+            return true;
+
+        // Password is wrong
+        return false;
+    }
+
+    public void configure( Configuration configuration )
+    {
+        usersDbParameter.readConfiguration( configuration );
+    }
+
+    public void update( Observable o, Object arg )
+    {
+        if ( o != usersDbParameter ) {
+            log.debug( "Received notification of wrong object: {}", o );
+            return;
+        }
+
+        try {
+            stop();
+            start();
+        } catch ( Exception e ) {
+            log.error( "Error restarting Authentication provider" );
+        }
+    }
 }

Added: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/IpAddressPattern.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/IpAddressPattern.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/IpAddressPattern.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -0,0 +1,120 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2006 - Matteo Merli - matteo.merli at gmail.com            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
+ * 
+ * $URL$
+ * 
+ */
+package rtspproxy.filter.ipaddress;
+
+import java.util.regex.Pattern;
+
+import org.apache.commons.configuration.Configuration;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import rtspproxy.config.ListElementParameter;
+
+/**
+ * @author Matteo Merli
+ * 
+ */
+public class IpAddressPattern implements ListElementParameter
+{
+
+    private static Logger log = LoggerFactory.getLogger( IpAddressPattern.class );
+
+    public enum Type {
+        Allow, Deny
+    }
+
+    private Type type;
+
+    private Pattern pattern;
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.config.ListElementParameter#readConfiguration(org.apache.commons.configuration.Configuration,
+     *      java.lang.String)
+     */
+    public boolean readConfiguration( Configuration configuration, String prefix )
+    {
+        String tmpType = configuration.getString( prefix + "[@type]" );
+        if ( tmpType == null )
+            return false;
+
+        if ( tmpType.equalsIgnoreCase( "allow" ) )
+            type = Type.Allow;
+        else if ( tmpType.equalsIgnoreCase( "deny" ) )
+            type = Type.Deny;
+        else
+            throw new IllegalArgumentException( "Invalid rule type: " + tmpType + ")" );
+
+        String tmpPattern = configuration.getString( prefix + "[@pattern]" );
+        if ( tmpPattern == null )
+            throw new IllegalArgumentException( "Missing pattern." );
+
+        log.debug( "Rule: {} {}", type, tmpPattern );
+
+        // Transform the patterns escaping "." and "*" characters
+        tmpPattern = tmpPattern.replaceAll( "\\.", "\\\\." );
+        tmpPattern = tmpPattern.replaceAll( "\\*", ".*" );
+        pattern = Pattern.compile( tmpPattern );
+        return true;
+    }
+
+    /**
+     * @return the pattern
+     */
+    public Pattern getPattern()
+    {
+        return pattern;
+    }
+
+    /**
+     * @param pattern
+     *            the pattern to set
+     */
+    public void setPattern( Pattern pattern )
+    {
+        this.pattern = pattern;
+    }
+
+    /**
+     * @return the type
+     */
+    public Type getType()
+    {
+        return type;
+    }
+
+    /**
+     * @param type
+     *            the type to set
+     */
+    public void setType( Type type )
+    {
+        this.type = type;
+    }
+
+    @Override
+    public String toString()
+    {
+        final StringBuilder sb = new StringBuilder();
+        sb.append( "IpAddressPattern( " ).append( type );
+        sb.append( ' ' ).append( pattern ).append( "  )" );
+        return sb.toString();
+    }
+
+}


Property changes on: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/IpAddressPattern.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/SimpleIpAddressProvider.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/SimpleIpAddressProvider.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/ipaddress/SimpleIpAddressProvider.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -18,162 +18,124 @@
 
 package rtspproxy.filter.ipaddress;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.io.Reader;
 import java.net.InetAddress;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.regex.Pattern;
 
-import org.apache.log4j.Logger;
-import org.dom4j.Element;
+import org.apache.commons.configuration.Configuration;
 
-import rtspproxy.config.AAAConfigurable;
-import rtspproxy.filter.GenericProviderAdapter;
+import rtspproxy.config.ListParameter;
+import rtspproxy.filter.ipaddress.IpAddressPattern.Type;
+import rtspproxy.lib.Side;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 /**
- * Implementation of the IpAddressFilter that is based on a list of XML config elements
- * which contain instruction on "allowed" and "denied" addresses and hosts.
+ * Implementation of the IpAddressFilter that is based on a list of XML config
+ * elements which contain instruction on "allowed" and "denied" addresses and
+ * hosts.
  * 
  * @author Matteo Merli
  */
-public class SimpleIpAddressProvider extends GenericProviderAdapter implements
-		IpAddressProvider, AAAConfigurable {
+public class SimpleIpAddressProvider implements IpAddressProvider
+{
 
-	private static Logger log = Logger.getLogger( SimpleIpAddressProvider.class );
+    private static Logger log = LoggerFactory.getLogger( SimpleIpAddressProvider.class );
 
-	private enum RuleType {
-		Allow, Deny
-	};
+    private List<IpAddressPattern> rules = new LinkedList<IpAddressPattern>();
 
-	private static class Rule
-	{
+    private Side side = Side.Client;
 
-		public RuleType type;
+    private final ListParameter<IpAddressPattern> clientRules = new ListParameter<IpAddressPattern>(
+            "filters.ipaddress.client-rules.rule", // name
+            false, // mutable
+            IpAddressPattern.class, // parameter class
+            "Client-side IP address filter rules." );
 
-		public Pattern pattern;
-	}
+    private final ListParameter<IpAddressPattern> serverRules = new ListParameter<IpAddressPattern>(
+            "filters.ipaddress.server-rules.rule", // name
+            false, // mutable
+            IpAddressPattern.class, // parameter class
+            "Server-side IP address filter rules." );
 
-	private List<Rule> rules = new LinkedList<Rule>();
+    public void setSide( Side side )
+    {
+        this.side = side;
+    }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see rtspproxy.auth.IpAddressProvider#shutdown()
-	 */
-	@Override
-	public void shutdown()
-	{
-		rules.clear();
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#start()
+     */
+    public void start() throws Exception
+    {
+        switch ( side )
+        {
+        case Client:
+            rules.addAll( clientRules.getElementsList() );
+            break;
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see rtspproxy.auth.IpAddressProvider#isBlocked(java.net.InetAddress)
-	 */
-	public boolean isBlocked( InetAddress address )
-	{
-		boolean blocked = true; // by default the address is blocked
-		String[] hostip = address.toString().split( "/" );
-		String host = hostip[0];
-		String ip = hostip[1];
+        case Server:
+            rules.addAll( serverRules.getElementsList() );
+            break;
+            
+        default:
+            break;
+        }
+    }
 
-		for ( Rule rule : rules ) {
-			if ( blocked && rule.type == RuleType.Deny )
-				// Don't need to check, up to now this IP is already
-				// blocked
-				continue;
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#stop()
+     */
+    public void stop()
+    {
+        rules.clear();
+    }
 
-			if ( rule.pattern.matcher( ip ).matches()
-					|| rule.pattern.matcher( host ).matches() )
-				// the address matches the pattern
-				// check if it's allow or deny
-				blocked = (rule.type == RuleType.Allow) ? false : true;
-		}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.auth.IpAddressProvider#isBlocked(java.net.InetAddress)
+     */
+    public boolean isBlocked( InetAddress address )
+    {
+        boolean blocked = true; // by default the address is blocked
+        String[] hostip = address.toString().split( "/" );
+        String host = hostip[0];
+        String ip = hostip[1];
 
-		return blocked;
-	}
+        for ( IpAddressPattern rule : rules ) {
+            if ( blocked && rule.getType() == Type.Deny )
+                // Don't need to check, up to now this IP is already
+                // blocked
+                continue;
 
-	/**
-	 * Reads the rules from a file
-	 * 
-	 * @param reader
-	 *            Reader of a file containing the access rules
-	 * @throws IOException
-	 */
-	protected void loadRules( Reader reader ) throws IOException
-	{
-		BufferedReader in = new BufferedReader( reader );
+            if ( rule.getPattern().matcher( ip ).matches()
+                    || rule.getPattern().matcher( host ).matches() )
+                // the address matches the pattern
+                // check if it's allow or deny
+                blocked = (rule.getType() == Type.Allow) ? false : true;
+       }
 
-		String line;
-		int lineNumber = 0;
-		try {
-			while ( (line = in.readLine()) != null ) {
-				line = line.replaceAll( "\t", " " ); // replace tabs
-				line = line.trim();
-				++lineNumber;
+        return blocked;
+    }
 
-				if ( line.length() == 0 )
-					continue; // Ignore empty lines
-				if ( line.startsWith( "#" ) )
-					continue; // Ignore comments
-				RuleType ruleType = null;
-				if ( line.startsWith( "Allow" ) )
-					ruleType = RuleType.Allow;
-				else if ( line.startsWith( "Deny" ) )
-					ruleType = RuleType.Deny;
-				else
-					throw new IOException( "Invalid filter pattern (line " + lineNumber
-							+ ")" );
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#configure(org.apache.commons.configuration.Configuration)
+     */
+    public void configure( Configuration configuration ) throws Exception
+    {
+        clientRules.readConfiguration( configuration );
+        serverRules.readConfiguration( configuration );
 
-				// read the pattern
-				String[] patternSplit = line.split( " ", 2 );
-				if ( patternSplit.length != 2 )
-					throw new IOException( "Invalid filter pattern (line " + lineNumber
-							+ ")" );
-				String pattern = patternSplit[1];
-				log.debug( "Rule: " + ruleType + " " + pattern );
+	log.debug( "clientRules: {}", clientRules.getElementsList() );
+	log.debug( "serverRules: {}", serverRules.getElementsList() );
+    }
 
-				// Transform the patterns escaping "." and "*" characters
-				pattern = pattern.replaceAll( "\\.", "\\\\." );
-				pattern = pattern.replaceAll( "\\*", ".*" );
-
-				Rule rule = new Rule();
-				rule.type = ruleType;
-				rule.pattern = Pattern.compile( pattern );
-				rules.add( rule );
-			}
-		} catch ( IOException e ) {
-			log.error( "Error reading IpAddressFilter rules: " + e );
-			throw e;
-		}
-	}
-
-	public void configure(List<Element> configElements) throws Exception {
-		for(Element el : configElements) {
-			RuleType ruleType = null;
-			
-			if ( el.getName().equals( "allow" ) )
-				ruleType = RuleType.Allow;
-			else if ( el.getName().equals( "deny" ) )
-				ruleType = RuleType.Deny;
-			else
-				throw new IllegalArgumentException( "Invalid filter pattern (element " + el	+ ")" );
-			
-			String pattern = el.getTextTrim();
-			log.debug( "Rule: " + ruleType + " " + pattern );
-
-			// Transform the patterns escaping "." and "*" characters
-			pattern = pattern.replaceAll( "\\.", "\\\\." );
-			pattern = pattern.replaceAll( "\\*", ".*" );
-
-			Rule rule = new Rule();
-			rule.type = ruleType;
-			rule.pattern = Pattern.compile( pattern );
-			rules.add( rule );
-			
-		}
-	}
 }

Added: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/RewriteMapping.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/RewriteMapping.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/RewriteMapping.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -0,0 +1,90 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   Copyright (C) 2006 - Matteo Merli - matteo.merli at gmail.com            *
+ *                                                                         *
+ ***************************************************************************/
+
+/*
+ * $Id$
+ * 
+ * $URL$
+ * 
+ */
+package rtspproxy.filter.rewrite;
+
+import org.apache.commons.configuration.Configuration;
+
+import rtspproxy.config.ListElementParameter;
+
+/**
+ * @author Matteo Merli
+ */
+public class RewriteMapping implements ListElementParameter
+{
+
+    private String from = null;
+
+    private String to = null;
+
+    public boolean readConfiguration( Configuration configuration, String prefix )
+    {
+        String tmpFrom = configuration.getString( prefix + ".from" );
+        if ( tmpFrom == null )
+            // Value not found
+            return false;
+
+        from = tmpFrom;
+        to = configuration.getString( prefix + ".to" );
+
+        return true;
+    }
+
+    /**
+     * @return the from
+     */
+    public String getFrom()
+    {
+        return from;
+    }
+
+    /**
+     * @param from
+     *            the from to set
+     */
+    public void setFrom( String from )
+    {
+        this.from = from;
+    }
+
+    /**
+     * @return the to
+     */
+    public String getTo()
+    {
+        return to;
+    }
+
+    /**
+     * @param to
+     *            the to to set
+     */
+    public void setTo( String to )
+    {
+        this.to = to;
+    }
+
+    @Override
+    public String toString()
+    {
+        final StringBuilder sb = new StringBuilder();
+        sb.append( "Mapping(from='" ).append( from );
+        sb.append( "' to='" ).append( to ).append( "')" );
+        return sb.toString();
+    }
+
+}


Property changes on: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/RewriteMapping.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/SimpleUrlRewritingProvider.java
===================================================================
--- trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/SimpleUrlRewritingProvider.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/SimpleUrlRewritingProvider.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -3,156 +3,167 @@
  */
 package rtspproxy.filter.rewrite;
 
-import org.apache.log4j.Logger;
-
 import java.net.MalformedURLException;
 import java.net.SocketAddress;
 import java.net.URL;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
-import org.dom4j.Element;
+import org.apache.commons.configuration.Configuration;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
-import rtspproxy.config.AAAConfigurable;
-import rtspproxy.filter.GenericProviderAdapter;
+import rtspproxy.config.ListParameter;
 import rtspproxy.rtsp.RtspRequest;
-import rtspproxy.rtsp.RtspRequest.Verb;
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public class SimpleUrlRewritingProvider extends GenericProviderAdapter
-		implements UrlRewritingProvider, AAAConfigurable {
-	
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = Logger
-			.getLogger(SimpleUrlRewritingProvider.class);
+public class SimpleUrlRewritingProvider implements UrlRewritingProvider
+{
 
-	// map with url from-->to prefix mapping (used in rewriting request URL)
-	private HashMap<String, String> forwardMappings = new HashMap<String, String>();
-	
-	// map with url from-->to prefix mapping (used in rewriting request URL)
-	private HashMap<URL, URL> optionsForwardMappings = new HashMap<URL, URL>();
-	
-	// map with url to-->from prefix mapping (used in rewriting response URL)
-	private HashMap<String, String> reverseMappings = new HashMap<String, String>();
-	
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.rewrite.UrlRewritingProvider#rewriteRequestUrl(java.net.URL)
-	 */
-	public UrlRewritingResult rewriteRequestUrl(URL request, RtspRequest.Verb verb, SocketAddress client,
-			Map<String, String> requestHeaders, Map<String, Object> exposedSessionAttributes) {
-		UrlRewritingResult result = null;
-		URL rewritten = null;
-		String req = request.toString();
-		
-		logger.debug("checking request URL: " + req + ", verb=" + verb);
-		
-		if(verb == RtspRequest.Verb.OPTIONS) {
-			logger.debug("handling OPTIONS request");
-			
-			if((rewritten = this.optionsForwardMappings.get(request)) != null) {
-				logger.debug("found special OPTIONS rewrite URL: " + rewritten);
-				
-				return new UrlRewritingResult(rewritten);
-			}
-		}
-		for(String prefix : this.forwardMappings.keySet()) {
-			if(req.startsWith(prefix)) {
-				logger.debug("found prefix match on " + prefix);
-				try {
-					rewritten = new URL(this.forwardMappings.get(prefix) 
-							+ req.substring(prefix.length()));
-				} catch(MalformedURLException mue) {
-					logger.error("request prefix rewriting caused invalid URL", mue);
-				}
-			}
-		}
-		logger.debug("rewritten URL: " + rewritten);
-		
-		if(rewritten != null)
-			result = new UrlRewritingResult(rewritten);
-		
-		return result;
-	}
+    private static final Logger log = LoggerFactory
+            .getLogger( SimpleUrlRewritingProvider.class );
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.rewrite.UrlRewritingProvider#rewriteResponseHeaderUrl(java.net.URL)
-	 */
-	public URL rewriteResponseHeaderUrl(URL response) {
-		URL rewritten = null;
-		String resp = response.toString();
-		
-		logger.debug("checking response URL: " + resp);
-		for(String prefix : this.reverseMappings.keySet()) {
-			if(resp.startsWith(prefix)) {
-				logger.debug("found prefix match on " + prefix);
-				try {
-					rewritten = new URL(this.reverseMappings.get(prefix) 
-							+ resp.substring(prefix.length()));
-				} catch(MalformedURLException mue) {
-					logger.error("response prefix rewriting caused invalid URL", mue);
-				}
-			}
-		}
-		logger.debug("rewritten URL: " + rewritten);
-		
-		return rewritten;
-	}
+    /** map with url from-->to prefix mapping (used in rewriting request URL) */
+    private Map<String, String> forwardMappings = new HashMap<String, String>();
 
-	public void configure(List<Element> configElements) throws Exception {
-		for(Element el : configElements) {
-			if(el.getName().equals("mapping")) {
-				Element fromEl = el.element("from");
-				Element toEl = el.element("to");
-				
-				if(fromEl == null || toEl == null)
-					throw new IllegalArgumentException("no from or to element in mapping configuration");
-				
-				String from = fromEl.getTextTrim();
-				String to = toEl.getTextTrim();
-				
-				if(from == null || from.length() == 0 || to == null || to.length() == 0)
-					throw new IllegalArgumentException("invalid from or to element in mapping configuration");
-				
-				if(from.endsWith("/"))
-					from = from.substring(0, from.length()-1);
-				if(to.endsWith("/"))
-					to = to.substring(0, to.length()-1);
+    // /** map with url from-->to prefix mapping (used in rewriting request URL)
+    // */
+    // private Map<URL, URL> optionsForwardMappings = new HashMap<URL, URL>();
 
-				this.forwardMappings.put(from, to);
-				this.reverseMappings.put(to, from);
-			} else if(el.getName().equals("map-options")) {
-				Element fromEl = el.element("from");
-				Element toEl = el.element("to");
-				
-				if(fromEl == null || toEl == null)
-					throw new IllegalArgumentException("no from or to element in mapping configuration");
-				
-				String from = fromEl.getTextTrim();
-				String to = toEl.getTextTrim();
-				
-				if(from == null || from.length() == 0 || to == null || to.length() == 0)
-					throw new IllegalArgumentException("invalid from or to element in mapping configuration");
-				
-				URL fromUrl = new URL(from);
-				URL toUrl = new URL(to);
-				
-				this.optionsForwardMappings.put(new URL(fromUrl.getProtocol(), fromUrl.getHost(), 
-						fromUrl.getPort(), "/"),
-						new URL(toUrl.getProtocol(), toUrl.getHost(), 
-								toUrl.getPort(), "/"));
-			}
-		}
-	}
+    /** map with url to-->from prefix mapping (used in rewriting response URL) */
+    private Map<String, String> reverseMappings = new HashMap<String, String>();
 
-	public String[] getWantedSessionAttributes() {
-		// no attributes wanted
-		return null;
-	}
+    private final ListParameter<RewriteMapping> rewriteRules;
 
+    public SimpleUrlRewritingProvider()
+    {
+        rewriteRules = new ListParameter<RewriteMapping>(
+                "filters.rewrite.rules.mapping", // name
+                false, // mutable
+                RewriteMapping.class, // parameter class
+                "Rewriting rules" );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.rewrite.UrlRewritingProvider#rewriteRequestUrl(java.net.URL)
+     */
+    public UrlRewritingResult rewriteRequestUrl( URL request, RtspRequest.Verb verb,
+            SocketAddress client, Map<String, String> requestHeaders,
+            Map<String, Object> exposedSessionAttributes )
+    {
+        UrlRewritingResult result = null;
+        URL rewritten = null;
+        String req = request.toString();
+
+        log.debug( "checking request URL: {}, verb={}", req, verb );
+
+        // TODO: OPTIONS mapping
+        /*
+         * if ( verb == RtspRequest.Verb.OPTIONS ) { log.debug( "handling
+         * OPTIONS request" );
+         * 
+         * if ( (rewritten = this.optionsForwardMappings.get( request )) != null ) {
+         * log.debug( "found special OPTIONS rewrite URL: {}", rewritten );
+         * 
+         * return new UrlRewritingResult( rewritten ); } }
+         */
+        for ( String prefix : forwardMappings.keySet() ) {
+            if ( req.startsWith( prefix ) ) {
+                log.debug( "found prefix match on {}", prefix );
+                try {
+                    rewritten = new URL( forwardMappings.get( prefix )
+                            + req.substring( prefix.length() ) );
+
+                } catch ( MalformedURLException mue ) {
+                    log.error( "request prefix rewriting caused invalid URL", mue );
+                }
+            }
+        }
+        log.debug( "rewritten URL: {}", rewritten );
+
+        if ( rewritten != null )
+            result = new UrlRewritingResult( rewritten );
+
+        return result;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#start()
+     */
+    public void start() throws Exception
+    {
+        for ( RewriteMapping rewriteMap : rewriteRules.getElementsList() ) {
+            forwardMappings.put( rewriteMap.getFrom(), rewriteMap.getTo() );
+            reverseMappings.put( rewriteMap.getTo(), rewriteMap.getFrom() );
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#stop()
+     */
+    public void stop()
+    {
+        forwardMappings.clear();
+        reverseMappings.clear();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.rewrite.UrlRewritingProvider#rewriteResponseHeaderUrl(java.net.URL)
+     */
+    public URL rewriteResponseHeaderUrl( URL response )
+    {
+        URL rewritten = null;
+        String resp = response.toString();
+
+        log.debug( "checking response URL: {}", resp );
+
+        for ( String prefix : reverseMappings.keySet() ) {
+            if ( resp.startsWith( prefix ) ) {
+                log.debug( "found prefix match on {}", prefix );
+                String url = reverseMappings.get( prefix )
+                        + resp.substring( prefix.length() );
+                try {
+                    rewritten = new URL( url );
+                } catch ( MalformedURLException mue ) {
+                    log.error( "response prefix rewriting caused invalid URL: {}", url );
+                }
+            }
+        }
+
+        log.info( "rewritten URL: {}", rewritten );
+        return rewritten;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#configure(org.apache.commons.configuration.Configuration)
+     */
+    public void configure( Configuration configuration ) throws Exception
+    {
+        rewriteRules.readConfiguration( configuration );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.rewrite.UrlRewritingProvider#getWantedSessionAttributes()
+     */
+    public String[] getWantedSessionAttributes()
+    {
+        // no attributes wanted
+        return null;
+    }
+
 }


Property changes on: trunk/RTSPProxy-App/src/main/java/rtspproxy/filter/rewrite/SimpleUrlRewritingProvider.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml
===================================================================
--- trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,3 +1,4 @@
+
 <!-- $Id$ -->
 
 <rtspproxy>
@@ -2,2 +3,5 @@
 
+	<!-- Enable or disable debug output. 
+	     A more fine-grained configuration can be done in the log4j 
+	     properties file. -->
 	<debug>true</debug>
@@ -14,10 +18,24 @@
 
 		<!-- Server-side configuration -->
 		<server>
+	
+			<!-- If specified, bound the proxy on a specifed network
+                             interface. -->
+                        <!-- <address>127.0.0.1</address> -->
+
+                        <!-- Same as for the address, but specifying the
+                             network interface name. On Linux they are called 'eth0', 'eth1'...
+                             On  MacOS X they are 'en0', 'en1', .. -->
+                        <!-- <interface>eth0</interface> -->
+		
+			<!-- RTP port used with servers -->
 			<!-- <rtpPort>6970</rtpPort> -->
+
+			<!-- RTCP port used with servers -->
 			<!-- <rtcpPort>6971</rtcpPort> -->
+
+			<!-- RDT port used with servers -->
 			<!-- <rdtPort>6972</rdtPort> -->
-			<!-- <address>10.0.0.24</address> -->
 
 			<!-- 
 				<rtpUsePortrange>false</rtpUsePortrange>
@@ -32,15 +50,25 @@
 			-->
 		</server>
 
+		<!-- Client-side configuration -->
+		<client>
+			<!-- If specified, bound the proxy on a specifed network 
+			     interface. -->
+			<address>127.0.0.1</address>
 
-		<client>
-			<!-- 
-				<rtpPort>6970</rtpPort>
-				<rtcpPort>6971</rtcpPort>
-				<rdtPort>6972</rdtPort>
-				<address>127.0.0.1</address>
-			-->
-			<interface>lo0</interface>
+			<!-- Same as for the address, but specifying the 
+			     network interface name. On Linux they are called 'eth0', 'eth1'...
+			     On  MacOS X they are 'en0', 'en1', .. -->
+                        <!-- <interface>eth0</interface> -->
+
+			<!-- Rtp port used with clients -->
+			<!-- <rtpPort>6970</rtpPort> -->
+
+			<!-- Rtcp port used with clients -->
+			<!-- <rtcpPort>6971</rtcpPort> -->
+
+			<!-- Rdt port used with clients -->
+			<!-- <rdtPort>6972</rdtPort> -->
 		</client>
 
 		<!-- Proxy feature selection -->
@@ -77,6 +105,8 @@
 		<!-- JMX web console -->
 		<web>
 			<enable>true</enable>
+			
+			<!-- HTTP port -->
 			<port>8080</port>
 		</web>
 
@@ -87,16 +117,16 @@
 		</connectorService>
 	</jmx>
 
-	<!-- Filters are the mean layered functionalities such as Authentication or 
+	<!-- Filters are mean layered functionalities such as Authentication or 
 		Tracking are implemented.
 	-->
 	<filters>
 
 		<!-- Authentication filter -->
 		<authentication>
+			<!-- Enable or disable the authentication filter -->
+			<enable>true</enable>
 
-			<enable>false</enable>
-
 			<implClass>
 				rtspproxy.filter.authentication.SimpleAuthenticationProvider
 			</implClass>
@@ -106,38 +136,34 @@
 			-->
 			<scheme>Digest</scheme>
 
+			<!-- The SimpleAuthenticationProvider uses a Property file 
+			     to keep a user db. In this file, keys are the usernames 
+			     and values are the passwords. -->
 			<usersFile>conf/users.properties</usersFile>
 		</authentication>
 
 		<!-- Filter clients using theyr IP address -->
-		<ipaddress
-			implClass="rtspproxy.filter.ipaddress.SimpleIpAddressProvider"
-			side="client">
-
+		<ipaddress>
+			
 			<!-- Enable or disable the ipaddress filter -->
-			<enabled>false</enabled>
+                        <enable>true</enable>
 
-			<rules>
-				<rule type="deny" pattern="*" />
-				<allow>127.0.0.1</allow>
-				<allow>10.0.0.*</allow>
-				<allow>*.some.domain</allow>
-			</rules>
-		</ipaddress>
+			<implClass>
+				rtspproxy.filter.ipaddress.SimpleIpAddressProvider
+			</implClass>
 
-		<ipaddress
-			implClass="rtspproxy.filter.ipaddress.SimpleIpAddressProvider"
-			side="server">
+			<!-- Access rules for clients -->
+			<client-rules>	
+				<rule type="deny"  pattern="*" />
+				<rule type="allow" pattern="127.0.0.1" />
+				<rule type="allow" pattern="10.0.0.*" />
+				<rule type="allow" pattern="*.some.domain" />
+			</client-rules>
 
-			<!-- Enable or disable the ipaddress filter -->
-			<enable>false</enable>
-
-			<rules>
-				<deny>*</deny>
-				<allow>127.0.0.1</allow>
-				<allow>10.0.0.*</allow>
-				<allow>*.some.domain</allow>
-			</rules>
+			<!-- Restrict access to certains RTSP servers  -->
+			<server-rules>
+				<rule type="deny" pattern="*.bad.domain.com" />
+			</server-rules>
 		</ipaddress>
 
 
@@ -146,6 +172,7 @@
 			<!-- Enable or disable the ipaddress filter -->
 			<enable>false</enable>
 
+			<!-- -->
 			<implClass>
 				rtspproxy.filter.accounting.SimpleAccountingProvider
 			</implClass>
@@ -154,7 +181,7 @@
 		</accounting>
 
 
-		<rewriting>
+		<rewrite>
 
 			<!-- enable or disable the rewriting filter -->
 			<enable>false</enable>
@@ -164,15 +191,35 @@
 				rtspproxy.filter.rewrite.SimpleUrlRewritingProvider
 			</implClass>
 
-			<!-- Rewriting rules -->
+			<!-- SimpleUrlRewritingProvider uses the following rules 
+		 	     to rewrite the URLs.	
+                          -->
 			<rules>
-				<mapping from="rtsp://10.0.0.1:554/"
-					       to="rtsp://10.0.0.2:1554/foo/" />
+				<mapping>
+					<from>rtsp://10.0.0.1:554/</from>
+					<to>rtsp://10.0.0.2:1554/foo/</to>
+				</mapping>
+				<mapping>
+					<from>rtsp://127.0.0.1/</from>
+					<to>rtsp://10.0.0.26:1554/foo/</to>
+				</mapping>
+			</rules>
+		</rewrite>
 
-				<mapping from="rtsp://127.0.0.01/" 
-					 		   to="rtsp://10.0.0.26:1554/foo/" />
-			</rules>
-		</rewriting>
+		<control>
+			<enable>false</enable>
+			
+			<filters>
+				<filter side="Client" 
+					name="testFilter" 
+					implClass="path.to.Class" />
+
+				<filter side="Server" 
+					name="testFilterServer"
+					implClass="other.path.class" />
+			</filters>
+		</control>
+
 	</filters>
 
 </rtspproxy>


Property changes on: trunk/RTSPProxy-App/src/resources/conf/rtspproxy.conf.xml
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-App/src/resources/conf/rtspproxy.log4j.xml
___________________________________________________________________
Name: svn:keywords
   - HeadURL Id LastChangedBy LastChangedDate LastChangedRevision
   + Id URL Rev

Modified: trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java
===================================================================
--- trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-App/src/test/java/rtspproxy/filter/ipaddress/PlainTextIpAddressProviderTest.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -17,9 +17,6 @@
  */
 package rtspproxy.filter.ipaddress;
 
-import java.io.StringReader;
-import java.net.InetAddress;
-
 import junit.framework.TestCase;
 
 /**
@@ -27,16 +24,13 @@
  */
 public class PlainTextIpAddressProviderTest extends TestCase
 {
+	// TODO: Rewrite this test using the xml based configuration
 
 	private static final String CRLF = "\r\n";
 
-	public static void main( String[] args )
-	{
-		junit.textui.TestRunner.run( PlainTextIpAddressProviderTest.class );
-	}
-
 	public void test1() throws Exception
 	{
+	/*
 		// prepare
 		SimpleIpAddressProvider provider = new SimpleIpAddressProvider();
 		StringBuilder rules = new StringBuilder();
@@ -50,10 +44,12 @@
 
 		// close
 		provider.shutdown();
+	*/
 	}
 	
 	public void test2() throws Exception
 	{
+	/*
 		// prepare
 		SimpleIpAddressProvider provider = new SimpleIpAddressProvider();
 		StringBuilder rules = new StringBuilder();
@@ -67,6 +63,7 @@
 
 		// close
 		provider.shutdown();
+	*/
 	}
 
 }

Modified: trunk/RTSPProxy-Core/pom.xml
===================================================================
--- trunk/RTSPProxy-Core/pom.xml	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/pom.xml	2006-04-25 21:47:58 UTC (rev 416)
@@ -11,92 +11,14 @@
 		<groupId>net.merlimat</groupId>
 		<artifactId>rtspproxy</artifactId>
 		<version>3.0-ALPHA5-SNAPSHOT</version>
+		<relativePath>../pom.xml</relativePath>
 	</parent>
 
 	<modelVersion>4.0.0</modelVersion>
 
 	<name>RTSP Proxy core</name>
-	<groupId>net.merlimat</groupId>
-	<artifactId>RTSPProxy-Core</artifactId>
-	<version>3.0-ALPHA5-SNAPSHOT</version>
-	<url>http://rtspproxy.berlios.de</url>
-	<inceptionYear>2003</inceptionYear>
+	<artifactId>RTSPProxy-Core</artifactId>	
 
-	<dependencies>
-
-		<dependency>
-			<groupId>org.apache.directory.mina</groupId>
-			<artifactId>mina-core</artifactId>
-			<version>0.9.3</version>
-		</dependency>
-
-		<dependency>
-			<groupId>mx4j</groupId>
-			<artifactId>mx4j-tools</artifactId>
-			<version>2.1.1</version>
-		</dependency>
-
-		<dependency>
-			<groupId>org.slf4j</groupId>
-			<artifactId>slf4j-log4j12</artifactId>
-			<version>1.0-rc3</version>
-		</dependency>
-
-		<dependency>
-			<groupId>log4j</groupId>
-			<artifactId>log4j</artifactId>
-			<version>1.2.9</version>
-		</dependency>
- 
-		<dependency>
-			<groupId>commons-pool</groupId>
-			<artifactId>commons-pool</artifactId>
-			<version>1.2</version>
-		</dependency>
-
-		<dependency>
-			<groupId>commons-configuration</groupId>
-			<artifactId>commons-configuration</artifactId>
-			<version>1.2</version>
-		</dependency>
-		
-		<!-- Included here to disambiguate the version number -->
-		<dependency>
-			<groupId>commons-collections</groupId>
-			<artifactId>commons-collections</artifactId>
-			<version>3.1</version>
-		</dependency>
-
-		<dependency>
-			<groupId>junit</groupId>
-			<artifactId>junit</artifactId>
-			<version>3.8.1</version>
-			<scope>test</scope>
-		</dependency>
-	</dependencies>
-
-	<repositories>
-
-		<repository>
-			<id>Apache repository</id>
-			<url>http://svn.apache.org/repository/</url>
-		</repository>
-
-		<!-- For snapshots (no release jars or non-apache jars)           -->
-		<repository>
-			<id>apache.snapshots</id>
-			<name>Apache Snapshot Repository</name>
-			<url>http://cvs.apache.org/maven-snapshot-repository</url>
-		</repository>
-
-		<!--
-			<repository>
-			<id>ibilio maven2</id>
-			<url>http://www.ibiblio.org/maven2/</url>
-			</repository>
-		-->
-	</repositories>
-
 	<build>
 		<defaultGoal>assembly:directory</defaultGoal>
 
@@ -106,18 +28,6 @@
 				<filtering>true</filtering>
 			</resource>
 		</resources>
-
-		<plugins>
-			<plugin>
-				<groupId>org.apache.maven.plugins</groupId>
-				<artifactId>maven-compiler-plugin</artifactId>
-				<configuration>
-					<source>1.5</source>
-					<target>1.5</target>
-					<showWarnings>true</showWarnings>
-				</configuration>
-			</plugin>
-		</plugins>
 	</build>
 
 </project>


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Debug.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/GenericObject.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/GenericObjectList.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Host.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/HostNameParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/HostPort.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/InternalErrorHandler.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/LexerCore.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/LogWriter.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Match.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/NameValue.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/NameValueList.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/PackageNames.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/ParserCore.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Separators.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/StringTokenizer.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/core/Token.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/MediaDescriptionImpl.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/SdpEncoderImpl.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/SessionDescriptionImpl.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/TimeDescriptionImpl.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/AttributeField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/BandwidthField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ConnectionAddress.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ConnectionField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/Email.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/EmailAddress.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/EmailField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/Indentation.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/InformationField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/KeyField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/MediaField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/OriginField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/PhoneField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ProtoVersionField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/RepeatField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPFieldList.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPFieldNames.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPFormat.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPKeywords.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPObject.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SDPObjectList.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/SessionNameField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/TimeField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/TypedTime.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/URIField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ZoneAdjustment.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/fields/ZoneField.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/AttributeFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/BandwidthFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/ConnectionFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/EmailFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/InformationFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/KeyFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/Lexer.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/MediaFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/OriginFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/ParserFactory.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/PhoneFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/ProtoVersionFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/RepeatFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/SDPAnnounceParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/SDPParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/SessionNameFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/TimeFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/URIFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/gov/nist/javax/sdp/parser/ZoneFieldParser.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/javax/sdp/SdpFactory.java
___________________________________________________________________
Name: svn:executable
   - *

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyService.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -142,6 +142,8 @@
             return;
         }
 
+        Reactor.getRegistry().unbind( this, false );
+
         log.info( getName() + " Stopped" );
         isRunning = false;
     }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/ProxyServiceRegistry.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -53,278 +53,291 @@
 public final class ProxyServiceRegistry extends Singleton implements Observer
 {
 
-	private static Logger log = LoggerFactory.getLogger( ProxyServiceRegistry.class );
+    private static Logger log = LoggerFactory.getLogger( ProxyServiceRegistry.class );
 
-	public static final String threadPoolFilterNAME = "threadPoolFilter";
+    public static final String threadPoolFilterNAME = "threadPoolFilter";
 
-	/** Thread pool instance that will be added to all acceptors. */
-	private final ThreadPoolFilter threadPoolFilter = new ThreadPoolFilter("sharedThreadPoolFilter");
+    /** Thread pool instance that will be added to all acceptors. */
+    private final ThreadPoolFilter threadPoolFilter = new ThreadPoolFilter(
+            "sharedThreadPoolFilter" );
 
-	/** All the services, mapped by name. */
-	private final ConcurrentMap<String, ProxyService> services = new ConcurrentHashMap<String, ProxyService>();
+    /** All the services, mapped by name. */
+    private final ConcurrentMap<String, ProxyService> services = new ConcurrentHashMap<String, ProxyService>();
 
-	/** Map a ProxyService to all its bound addresses. */
-	private final ConcurrentMap<ProxyService, Set<SocketAddress>> addresses = new ConcurrentHashMap<ProxyService, Set<SocketAddress>>();
+    /** Map a ProxyService to all its bound addresses. */
+    private final ConcurrentMap<ProxyService, Set<SocketAddress>> addresses = new ConcurrentHashMap<ProxyService, Set<SocketAddress>>();
 
-	/** Map a ProxyService to its own IoAcceptor. */
-	private final ConcurrentMap<ProxyService, IoAcceptor> acceptors = new ConcurrentHashMap<ProxyService, IoAcceptor>();
+    /** Map a ProxyService to its own IoAcceptor. */
+    private final ConcurrentMap<ProxyService, IoAcceptor> acceptors = new ConcurrentHashMap<ProxyService, IoAcceptor>();
 
-	/**
-	 * Construct a new ProxyServiceRegistry. This class is a Singleton, so there
-	 * can be only one instance.
-	 */
-	public ProxyServiceRegistry()
-	{
-		int poolMaxSize = Config.threadPoolSize.getValue();
-		threadPoolFilter.setMaximumPoolSize( poolMaxSize );
+    /**
+     * Construct a new ProxyServiceRegistry. This class is a Singleton, so there
+     * can be only one instance.
+     */
+    public ProxyServiceRegistry()
+    {
+        int poolMaxSize = Config.threadPoolSize.getValue();
+        threadPoolFilter.setMaximumPoolSize( poolMaxSize );
 
-		// Subscribe to thread pool size changes notification
-		Config.threadPoolSize.addObserver( this );
-	}
+        // Subscribe to thread pool size changes notification
+        Config.threadPoolSize.addObserver( this );
+    }
 
-	/**
-	 * Bind a Service to a local address and specify the IoHandler that will
-	 * manage ingoing and outgoing messages.
-	 * 
-	 * @param service
-	 *            the ProxyService
-	 * @param ioHandler
-	 *            the IoHandler that will handle the messages
-	 * @param address
-	 *            the local address to bind on
-	 * @throws IOException
-	 */
-	public void bind( ProxyService service, IoHandler ioHandler, InetSocketAddress address )
-			throws IOException
-	{
-		bind( service, ioHandler, address, null );
-	}
+    /**
+     * Bind a Service to a local address and specify the IoHandler that will
+     * manage ingoing and outgoing messages.
+     * 
+     * @param service
+     *            the ProxyService
+     * @param ioHandler
+     *            the IoHandler that will handle the messages
+     * @param address
+     *            the local address to bind on
+     * @throws IOException
+     */
+    public void bind( ProxyService service, IoHandler ioHandler, InetSocketAddress address )
+            throws IOException
+    {
+        bind( service, ioHandler, address, null );
+    }
 
-	/**
-	 * Bind a Service to a local address and specify the IoHandler that will
-	 * manage ingoing and outgoing messages.
-	 * <p>
-	 * In addition it should be specified an IoFilterChainBuilder. This builder
-	 * will be associated with the IoAcceptor itself (which is unique per
-	 * ProxyService) and not for every IoSession created.
-	 * 
-	 * @param service
-	 *            the ProxyService
-	 * @param ioHandler
-	 *            the IoHandler that will handle the messages
-	 * @param address
-	 *            the local address to bind on
-	 * @param filterChainBuilder
-	 *            the IoFilterChainBuilder instance
-	 * @throws IOException
-	 */
-	public void bind( ProxyService service, IoHandler ioHandler,
-			InetSocketAddress address, IoFilterChainBuilder filterChainBuilder )
-			throws IOException
-	{
-		IoAcceptor acceptor = newAcceptor( service );
-		
-		IoFilterChainBuilder builder = new IoFilterChainBuilderWrapper( service,
-				filterChainBuilder );
-		acceptor.setFilterChainBuilder( builder );
-		acceptor.bind( address, ioHandler );
+    /**
+     * Bind a Service to a local address and specify the IoHandler that will
+     * manage ingoing and outgoing messages.
+     * <p>
+     * In addition it should be specified an IoFilterChainBuilder. This builder
+     * will be associated with the IoAcceptor itself (which is unique per
+     * ProxyService) and not for every IoSession created.
+     * 
+     * @param service
+     *            the ProxyService
+     * @param ioHandler
+     *            the IoHandler that will handle the messages
+     * @param address
+     *            the local address to bind on
+     * @param filterChainBuilder
+     *            the IoFilterChainBuilder instance
+     * @throws IOException
+     */
+    public void bind( ProxyService service, IoHandler ioHandler,
+            InetSocketAddress address, IoFilterChainBuilder filterChainBuilder )
+            throws IOException
+    {
+        IoAcceptor acceptor = newAcceptor( service );
 
-		services.put( service.getName(), service );
+        IoFilterChainBuilder builder = new IoFilterChainBuilderWrapper( service,
+                filterChainBuilder );
+        acceptor.setFilterChainBuilder( builder );
+        acceptor.bind( address, ioHandler );
 
-		if ( addresses.get( service ) == null )
-			addresses.put( service, new HashSet<SocketAddress>() );
-		addresses.get( service ).add( address );
-	}
+        services.put( service.getName(), service );
 
-	/**
-	 * Unbind the service from all of its bound addresses.
-	 * 
-	 * @param service
-	 *            the ProxyService
-	 * @throws Exception
-	 */
-	public synchronized void unbind( ProxyService service ) throws Exception
-	{
-		IoAcceptor acceptor = acceptors.get( service );
-		for ( SocketAddress address : addresses.get( service ) ) {
-			try {
-				acceptor.unbind( address );
-			} catch ( Exception e ) {
-				// ignore
-			}
-		}
+        if ( addresses.get( service ) == null )
+            addresses.put( service, new HashSet<SocketAddress>() );
+        addresses.get( service ).add( address );
+    }
 
-		if ( service.isRunning() ) {
-			service.stop();
-		}
+    public void unbind( ProxyService service ) throws Exception
+    {
+        unbind( service, true );
+    }
 
-		services.remove( service.getName() );
-		acceptors.remove( service );
-		addresses.remove( service );
-	}
+    /**
+     * Unbind the service from all of its bound addresses.
+     * 
+     * @param service
+     *            the ProxyService
+     * @throws Exception
+     */
+    public synchronized void unbind( ProxyService service, boolean stopService )
+            throws Exception
+    {
+        IoAcceptor acceptor = acceptors.get( service );
+        for ( SocketAddress address : addresses.get( service ) ) {
+            try {
+                acceptor.unbind( address );
+            } catch ( Exception e ) {
+                // log.debug( "Error unbinding {}", service.getName() );
+                // Exceptions.logStackTrace( e );
+                // ignore
+            }
+        }
 
-	/**
-	 * Unbind all the services registered in the ProxyServiceRegistry, from all
-	 * of they bound addresses.
-	 * 
-	 * @throws Exception
-	 */
-	public synchronized void unbindAll() throws Exception
-	{
-		Set<ProxyService> serviceList = new HashSet<ProxyService>( services.values() );
-		for ( ProxyService service : serviceList ) {
-			unbind( service );
-		}
-	}
+        if ( stopService && service.isRunning() ) {
+            service.stop();
+        }
 
-	/**
-	 * @return a Set containing all the registered services.
-	 */
-	public Set<ProxyService> getAllServices()
-	{
-		return new HashSet<ProxyService>( services.values() );
-	}
+        services.remove( service.getName() );
+        acceptors.remove( service );
+        addresses.remove( service );
+    }
 
-	/**
-	 * Return the instance of a ProxyService.
-	 * 
-	 * @param name
-	 *            the name of the ProxyService
-	 * @return the instance of the ProxyService
-	 */
-	public ProxyService getService( String name )
-	{
-		return services.get( name );
-	}
+    /**
+     * Unbind all the services registered in the ProxyServiceRegistry, from all
+     * of they bound addresses.
+     * 
+     * @throws Exception
+     */
+    public synchronized void unbindAll() throws Exception
+    {
+        for ( ProxyService service : services.values() ) {
+            unbind( service );
+        }
+    }
 
-	/**
-	 * Returns a reference to the IoAcceptor used by the specified ProxyService.
-	 * 
-	 * @param serviceName
-	 *            the name of the ProxyService
-	 * @return the IoAcceptor associated with the service or null if the
-	 *         serviceName is invalid
-	 */
-	public IoAcceptor getAcceptor( String serviceName )
-	{
-		ProxyService service = services.get( serviceName );
-		if ( service == null )
-			return null;
-		else
-			return acceptors.get( service );
-	}
+    /**
+     * @return a Set containing all the registered services.
+     */
+    public Set<ProxyService> getAllServices()
+    {
+        return new HashSet<ProxyService>( services.values() );
+    }
 
-	/**
-	 * Returns a reference to the IoAcceptor used by the specified ProxyService.
-	 * 
-	 * @param service
-	 *            the ProxyService
-	 * @return the IoAcceptor associated with the service
-	 */
-	public IoAcceptor getAcceptor( ProxyService service )
-	{
-		return acceptors.get( service );
-	}
+    /**
+     * Return the instance of a ProxyService.
+     * 
+     * @param name
+     *            the name of the ProxyService
+     * @return the instance of the ProxyService
+     */
+    public ProxyService getService( String name )
+    {
+        return services.get( name );
+    }
 
-	/**
-	 * Gets a new IoAcceptor suitable for the specified ProxyService
-	 * 
-	 * @param service
-	 *            the ProxyService
-	 * @return a reference to the IoAcceptor
-	 */
-	private IoAcceptor newAcceptor( ProxyService service )
-	{
-		// First check if there's already an acceptor
-		IoAcceptor acceptor = acceptors.get( service );
-		if ( acceptor != null )
-			return acceptor;
+    /**
+     * Returns a reference to the IoAcceptor used by the specified ProxyService.
+     * 
+     * @param serviceName
+     *            the name of the ProxyService
+     * @return the IoAcceptor associated with the service or null if the
+     *         serviceName is invalid
+     */
+    public IoAcceptor getAcceptor( String serviceName )
+    {
+        ProxyService service = services.get( serviceName );
+        if ( service == null )
+            return null;
 
-		// Create a new one
-		TransportType transportType = service.getTransportType();
-		if ( transportType == TransportType.SOCKET )
-			acceptor = new SocketAcceptor(); // socketAcceptor;
-		else if ( transportType == TransportType.DATAGRAM )
-			acceptor = new DatagramAcceptor(); // datagramAcceptor;
-		else
-			acceptor = null;
+        return acceptors.get( service );
+    }
 
-		// Save the acceptor
-		acceptors.put( service, acceptor );
-		return acceptor;
-	}
+    /**
+     * Returns a reference to the IoAcceptor used by the specified ProxyService.
+     * 
+     * @param service
+     *            the ProxyService
+     * @return the IoAcceptor associated with the service
+     */
+    public IoAcceptor getAcceptor( ProxyService service )
+    {
+        return acceptors.get( service );
+    }
 
-	/**
-	 * Gets notification of changed parameters.
-	 * 
-	 * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
-	 */
-	public void update( Observable o, Object arg )
-	{
-		if ( !(o instanceof Parameter) )
-			throw new IllegalArgumentException( "Only observe parameters" );
+    /**
+     * Gets a new IoAcceptor suitable for the specified ProxyService
+     * 
+     * @param service
+     *            the ProxyService
+     * @return a reference to the IoAcceptor
+     */
+    private IoAcceptor newAcceptor( ProxyService service )
+    {
+        // First check if there's already an acceptor
+        IoAcceptor acceptor = acceptors.get( service );
+        if ( acceptor != null )
+            return acceptor;
 
-		if ( o == Config.threadPoolSize ) {
-			// Update the thread pool size
-			threadPoolFilter.setMaximumPoolSize( Config.threadPoolSize.getValue() );
-			log.info( "Changed ThreadPool size. New max size: "
-					+ threadPoolFilter.getMaximumPoolSize() );
-		}
-	}
+        // Create a new one
+        TransportType transportType = service.getTransportType();
+        if ( transportType == TransportType.SOCKET )
+            acceptor = new SocketAcceptor(); // socketAcceptor;
+        else if ( transportType == TransportType.DATAGRAM )
+            acceptor = new DatagramAcceptor(); // datagramAcceptor;
+        else
+            acceptor = null;
 
-	/**
-	 * @param service 
-	 * @param service 
-	 * @return the shared thread pool filter instance
-	 */
-	public IoFilter getThreadPoolFilterInstance(ProxyService service)
-	{
-		ThreadPoolFilter filter = service.getThreadPoolFilter();
+        // Save the acceptor
+        acceptors.put( service, acceptor );
+        return acceptor;
+    }
 
-		if(filter == null)
-			filter = threadPoolFilter;
-		return filter;
-	}
+    /**
+     * Gets notification of changed parameters.
+     * 
+     * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
+     */
+    public void update( Observable o, Object arg )
+    {
+        if ( !(o instanceof Parameter) )
+            throw new IllegalArgumentException( "Only observe parameters" );
 
-	/**
-	 * @return a reference to the (unique) ProxyServiceRegistry instance
-	 */
-	public static ProxyServiceRegistry getInstance()
-	{
-		return (ProxyServiceRegistry) Singleton.getInstance( ProxyServiceRegistry.class );
-	}
+        if ( o == Config.threadPoolSize ) {
+            // Update the thread pool size
+            threadPoolFilter.setMaximumPoolSize( Config.threadPoolSize.getValue() );
+            log.info( "Changed ThreadPool size. New max size: "
+                    + threadPoolFilter.getMaximumPoolSize() );
+        }
+    }
 
-	/**
-	 * Wrapper class for the IoFilterChainBuilder that always add the thread
-	 * pool filter as the filter in the chain.
-	 * <p>
-	 * The thread pool filter will be shared by all the services and acceptors.
-	 */
-	protected static class IoFilterChainBuilderWrapper implements IoFilterChainBuilder
-	{
+    /**
+     * @param service
+     * @param service
+     * @return the shared thread pool filter instance
+     */
+    public IoFilter getThreadPoolFilterInstance( ProxyService service )
+    {
+        ThreadPoolFilter filter = service.getThreadPoolFilter();
 
-		private final ProxyService service;
+        if ( filter == null )
+            filter = threadPoolFilter;
+        return filter;
+    }
 
-		private final IoFilterChainBuilder originalBuilder;
+    /**
+     * @return a reference to the (unique) ProxyServiceRegistry instance
+     */
+    public static ProxyServiceRegistry getInstance()
+    {
+        return (ProxyServiceRegistry) Singleton.getInstance( ProxyServiceRegistry.class );
+    }
 
-		public IoFilterChainBuilderWrapper( ProxyService service,
-				IoFilterChainBuilder originalBuilder )
-		{
-			this.service = service;
-			this.originalBuilder = originalBuilder;
-		}
+    /**
+     * Wrapper class for the IoFilterChainBuilder that always add the thread
+     * pool filter as the filter in the chain.
+     * <p>
+     * The thread pool filter will be shared by all the services and acceptors.
+     */
+    protected static class IoFilterChainBuilderWrapper implements IoFilterChainBuilder
+    {
 
-		public void buildFilterChain( IoFilterChain chain ) throws Exception
-		{
-			chain.getSession().setAttribute( ProxyService.SERVICE, service );
+        private final ProxyService service;
 
-			if(service.wantThreadPoolFilter()) {
-				IoFilter threadPoolFilter = ProxyServiceRegistry.getInstance()
-				.getThreadPoolFilterInstance(service);
-				chain.addFirst( threadPoolFilterNAME, threadPoolFilter );
-			}
-			originalBuilder.buildFilterChain( chain );
-		}
-	}
+        private final IoFilterChainBuilder originalBuilder;
 
+        public IoFilterChainBuilderWrapper( ProxyService service,
+                IoFilterChainBuilder originalBuilder )
+        {
+            this.service = service;
+            this.originalBuilder = originalBuilder;
+        }
+
+        /*
+         * (non-Javadoc)
+         * 
+         * @see org.apache.mina.common.IoFilterChainBuilder#buildFilterChain(org.apache.mina.common.IoFilterChain)
+         */
+        public void buildFilterChain( IoFilterChain chain ) throws Exception
+        {
+            chain.getSession().setAttribute( ProxyService.SERVICE, service );
+
+            if ( service.wantThreadPoolFilter() ) {
+                IoFilter threadPoolFilter = ProxyServiceRegistry.getInstance()
+                        .getThreadPoolFilterInstance( service );
+                chain.addFirst( threadPoolFilterNAME, threadPoolFilter );
+            }
+            originalBuilder.buildFilterChain( chain );
+        }
+    }
+
 }

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfig.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfig.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfig.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,67 +0,0 @@
-/**
- * 
- */
-package rtspproxy.config;
-
-import java.util.HashMap;
-import java.util.List;
-
-import org.dom4j.Element;
-
-import rtspproxy.lib.Side;
-
-/**
- * This class contains the configuration for an AAA filter.
- * 
- * @author Rainer Bieniek (Rainer.Bieniek at web.de)
- */
-public class AAAConfig {
-
-	// implementation class name
-	private String implClass;
-	
-	// list of configuration elements
-	private List<Element> configElements;
-	
-	// filter application
-	private Side side = Side.Any;
-	
-	// any additional attributes given
-	private HashMap<String, String> attrs = new HashMap<String, String>();
-	
-	/**
-	 * 
-	 */
-	AAAConfig(String implClass, Side side, List<Element> configElements) {
-		this.implClass = implClass;
-		this.configElements = configElements;
-		this.side = side;
-	}
-
-	public final List<Element> getConfigElements() {
-		return configElements;
-	}
-
-	public final String getImplClass() {
-		return implClass;
-	}
-
-	public final Side getSide() {
-		return this.side;
-	}
-	
-	final void setAttribute(String name, String value) {
-		this.attrs.put(name, value);
-	}
-	
-	public final String getAttribute(String name) {
-		return this.getAttribute(name, null);
-	}
-
-	public final String getAttribute(String name, String defValue) {
-		if(this.attrs.containsKey(name))
-			return this.attrs.get(name);
-		
-		return defValue;
-	}
-}

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/AAAConfigurable.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,27 +0,0 @@
-/**
- * 
- */
-package rtspproxy.config;
-
-import java.util.List;
-
-import org.dom4j.Element;
-
-/**
- * This interface is implemented by filters which can be configured via the XML
- * mechanism
- * 
- * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- */
-public interface AAAConfigurable
-{
-
-    /**
-     * configure the filter.
-     * 
-     * @param configElements
-     *            a list of dom4j elements containing the actual configuration
-     */
-    public void configure( List<Element> configElements ) throws Exception;
-    
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/Config.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -18,11 +18,8 @@
 
 package rtspproxy.config;
 
-import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Date;
-import java.util.List;
 import java.util.Map;
 import java.util.Observable;
 import java.util.Observer;
@@ -31,7 +28,6 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import org.apache.log4j.Appender;
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
 
@@ -78,18 +74,18 @@
 
     public static final IntegerParameter threadPoolSize = new IntegerParameter(
             "threadPoolSize", // name
-            new Integer( 0 ), // min value
-            new Integer( 2147483647 ), // max value
-            new Integer( 10 ), // default value
+            0, // min value
+            2147483647, // max value
+            10, // default value
             true, // mutable
             "Maximum size of the thread pool. The thread pool is shared "
                     + "between all services found in RtspProxy." );
 
     public static final IntegerParameter proxyRtspPort = new IntegerParameter(
             "proxy.rtspPort", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( Handler.DEFAULT_RTSP_PORT ), // default value
+            0, // min value
+            65536, // max value
+            Handler.DEFAULT_RTSP_PORT, // default value
             true, // mutable
             "This is the port which the proxy will listen for "
                     + "RTSP connection. The default is 554, like normal RTSP servers." );
@@ -120,17 +116,17 @@
 
     public static final IntegerParameter proxyServerRtpPort = new IntegerParameter(
             "proxy.server.rtpPort", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 8000 ), // default value
+            0, // min value
+            65536, // max value
+            8000, // default value
             true, // mutable
             "Port to listen for RTP packets arriving from servers." );
 
     public static final IntegerParameter proxyServerRtcpPort = new IntegerParameter(
             "proxy.server.rtcp.port", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 8001 ), // default value
+            0, // min value
+            65536, // max value
+            8001, // default value
             true, // mutable
             "Port to listen for RTCP packets arriving from servers." );
 
@@ -142,73 +138,73 @@
 
     public static final IntegerParameter proxyServerRtpMinPort = new IntegerParameter(
             "proxy.server.rtpPortrange.minPort", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 9000 ), // default value
+            0, // min value
+            65536, // max value
+            9000, // default value
             true, // mutable
             "Port to listen for RTP packets arriving from servers." );
 
     public static final IntegerParameter proxyServerRtpMaxPort = new IntegerParameter(
             "proxy.server.rtpPortrange.maxPort", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 9100 ), // default value
+            0, // min value
+            65536, // max value
+            9100, // default value
             true, // mutable
             "Port to listen for RTP packets arriving from servers." );
 
     public static final IntegerParameter proxyServerRtpIdleTimeout = new IntegerParameter(
             "proxy.server.rtpPortrange.idleTimeout", // name
-            new Integer( 0 ), // min value
-            new Integer( 86400 ), // max value
-            new Integer( 3600 ), // default value
+            0, // min value
+            86400, // max value
+            3600, // default value
             true, // mutable
             "Timeout an open RTP server port may linger around." );
 
     public static final IntegerParameter proxyServerRtpIdleScanInterval = new IntegerParameter(
             "proxy.server.rtpPortrange.idleScanInterval", // name
-            new Integer( 0 ), // min value
-            new Integer( 86400 ), // max value
-            new Integer( 1800 ), // default value
+            0, // min value
+            86400, // max value
+            1800, // default value
             true, // mutable
             "Scan interval on idle RTP server ports." );
 
     public static final IntegerParameter proxyServerRtpThreadPoolSize = new IntegerParameter(
             "proxy.server.rtpPortrange.threadPoolSize", // name
-            new Integer( 0 ), // min value
-            new Integer( 2147483647 ), // max value
-            new Integer( 10 ), // default value
+            0, // min value
+            2147483647, // max value
+            10, // default value
             true, // mutable
             "Scan interval on idle RTP server ports." );
 
     public static final IntegerParameter proxyClientRtpPort = new IntegerParameter(
             "proxy.client.rtpPort", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 8002 ), // default value
+            0, // min value
+            65536, // max value
+            8002, // default value
             true, // mutable
             "Port to listen for RTP packets arriving from clients." );
 
     public static final IntegerParameter proxyClientRtcpPort = new IntegerParameter(
             "proxy.client.rtcpPort", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 8003 ), // default value
+            0, // min value
+            65536, // max value
+            8003, // default value
             true, // mutable
             "Port to listen for RTCP packets arriving from clients." );
 
     public static final IntegerParameter proxyServerRdtPort = new IntegerParameter(
             "proxy.server.rdtPort", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 8020 ), // default value
+            0, // min value
+            65536, // max value
+            8020, // default value
             true, // mutable
             "Port to listen for RDT packets arriving from servers." );
 
     public static final IntegerParameter proxyClientRdtPort = new IntegerParameter(
             "proxy.client.rdtPort", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 8022 ), // default value
+            0, // min value
+            65536, // max value
+            8022, // default value
             true, // mutable
             "Port to listen for RDT packets arriving from clients." );
 
@@ -300,9 +296,9 @@
 
     public static final IntegerParameter jmxWebPort = new IntegerParameter(
             "jmx.web.port", // name
-            new Integer( 0 ), // min value
-            new Integer( 65536 ), // max value
-            new Integer( 8000 ), // default value
+            0, // min value
+            65536, // max value
+            8000, // default value
             false, // mutable
             "TCP port to be used for the Web Console." );
 
@@ -314,82 +310,90 @@
 
     // /////////////////////////////////////////////////////////
 
-    private static String rtspproxyHome;
+    // Authentication filter
 
-    private static String name;
+    public static final BooleanParameter filtersAuthenticationEnable = new BooleanParameter(
+            "filters.authentication.enable", // name
+            false, // default value
+            false, // mutable
+            "Controls the activation of the Authentication system" );
 
-    private static String version;
+    public static final StringParameter filtersAuthenticationImplClass = new StringParameter(
+            "filters.authentication.implClass", // name
+            "rtspproxy.filter.authentication.SimpleAuthenticationProvider", // default
+            // value
+            false, // mutable
+            "Implementation class for the authentication filter." );
 
-    private static String proxySignature;
+    public static final StringParameter filtersAuthenticationScheme = new StringParameter(
+            "filters.authentication.scheme", // name
+            "Basic", // default value
+            false, // mutable
+            "Authentication scheme to be used. Can be 'Basic' or 'Digest'." );
 
-    private static Date startDate;
+    // /////////////////////////////////////////////////////////
 
+    // IP address filter
+
+	public static final BooleanParameter filtersIpAddressEnable = new BooleanParameter(
+            "filters.ipaddress.enable", // name
+            false, // default value
+            false, // mutable
+            "Controls the activation of the IP address filter." );
+
+    public static final StringParameter filtersIpAddressImplClass = new StringParameter(
+            "filters.ipaddress.implClass", // name
+            "rtspproxy.filter.ipaddress.SimpleIpAddressProvider", // default
+                                                                    // value
+            false, // mutable
+            "Implementation class for the IP address filter." );
+
     // /////////////////////////////////////////////////////////
 
-    // filter configurations from XML
-    private static List<AAAConfig> authenticationFilters = new ArrayList<AAAConfig>();
+    // Accounting filter
 
-    // filter configurations from XML
-    private static List<AAAConfig> ipAddressFilters = new ArrayList<AAAConfig>();
+    public static final BooleanParameter filtersAccountingEnable = new BooleanParameter(
+            "filters.accounting.enable", // name
+            false, // default value
+            false, // mutable
+            "Controls the activation of the Accounting system" );
 
-    // filter configurations from XML
-    private static List<AAAConfig> accountingFilters = new ArrayList<AAAConfig>();
+    public static final StringParameter filtersAccountingImplClass = new StringParameter(
+            "filters.accounting.implClass", // name
+            "rtspproxy.filter.accounting.SimpleAccountingProvider", // default value
+            false, // mutable
+            "Implementation class for the accounting filter." );
 
-    // filter configurations from XML
-    private static List<AAAConfig> urlRewritingFilters = new ArrayList<AAAConfig>();
 
-    private static List<AAAConfig> controlFilters = new ArrayList<AAAConfig>();
+    // /////////////////////////////////////////////////////////
 
-    static void addAuthenticationFilter( AAAConfig config )
-    {
-        authenticationFilters.add( config );
-    }
+    // Rewrite filter
 
-    static void addIpAddressFilter( AAAConfig config )
-    {
-        ipAddressFilters.add( config );
-    }
+    public static final BooleanParameter filtersRewriteEnable = new BooleanParameter(
+            "filters.rewrite.enable", // name
+            false, // default value
+            true, // mutable
+            "Controls the activation of the Rewrite system" );
 
-    static void addAccountingFilter( AAAConfig config )
-    {
-        accountingFilters.add( config );
-    }
+    public static final StringParameter filtersRewriteImplClass = new StringParameter(
+            "filters.rewrite.implClass", // name
+            "rtspproxy.filter.authentication.SimpleAuthenticationProvider", // default
+            // value
+            true, // mutable
+            "Implementation class for the authentication filter." );
 
-    static void addUrlRewritingFilter( AAAConfig config )
-    {
-        urlRewritingFilters.add( config );
-    }
+    // /////////////////////////////////////////////////////////
 
-    public static void addControlFilter( AAAConfig aaa )
-    {
-        controlFilters.add( aaa );
-    }
+    private static String rtspproxyHome;
 
-    public static List<AAAConfig> getAuthenticationFilters()
-    {
-        return Collections.unmodifiableList( authenticationFilters );
-    }
+    private static String name;
 
-    public static List<AAAConfig> getIpAddressFilters()
-    {
-        return Collections.unmodifiableList( ipAddressFilters );
-    }
+    private static String version;
 
-    public static List<AAAConfig> getAccountingFilters()
-    {
-        return Collections.unmodifiableList( accountingFilters );
-    }
+    private static String proxySignature;
 
-    public static List<AAAConfig> getUrlRewritingFilters()
-    {
-        return Collections.unmodifiableList( urlRewritingFilters );
-    }
+    private static Date startDate;
 
-    public static List<AAAConfig> getControlFilters()
-    {
-        return Collections.unmodifiableList( controlFilters );
-    }
-
     // /////////////////////////////////////////////////////////
 
     public Config()

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListElementParameter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -5,7 +5,7 @@
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
- *   Copyright (C) 2005 - Matteo Merli - matteo.merli at gmail.com            *
+ *   Copyright (C) 2006 - Matteo Merli - matteo.merli at gmail.com            *
  *                                                                         *
  ***************************************************************************/
 
@@ -17,11 +17,17 @@
  */
 package rtspproxy.config;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * @author Matteo Merli
  * 
  */
 public interface ListElementParameter
 {
+
+    public boolean readConfiguration( Configuration configuration, String prefix );
     
+    public String toString();
+    
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -3,6 +3,7 @@
  */
 package rtspproxy.config;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.configuration.Configuration;
@@ -13,21 +14,26 @@
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  * 
  */
-public class ListParameter<T> extends Parameter
+public class ListParameter<T extends ListElementParameter> extends Parameter
 {
 
     private static Logger log = LoggerFactory.getLogger( ListParameter.class );
 
-    private List<T> list;
+    private Class<T> parameterClass;
 
+    private List<T> list = new ArrayList<T>();
+
     /**
      * @param name
      * @param mutable
      * @param description
      */
-    public ListParameter( String name, boolean mutable, String description )
+    public ListParameter( String name, boolean mutable, Class<T> parameterClass,
+            String description )
     {
         super( name, mutable, description );
+
+        this.parameterClass = parameterClass;
     }
 
     @Override
@@ -35,6 +41,11 @@
     {
         return list;
     }
+    
+    public List<T> getElementsList()
+    {
+        return list;
+    }
 
     @Override
     public String getStringValue()
@@ -51,24 +62,38 @@
     @Override
     public void readConfiguration( Configuration configuration )
     {
-        List elements = configuration.getList( name );
-        if ( elements == null ) {
-            log.debug( "Elements not found for key '{}'", name );
-            return;
-        }
+        boolean res;
+        T element = null;
+        String prefix;
 
-        for ( Object element : elements ) {
-            log.info( "ELEMENT: {}", element );
+        for ( int i = 0; /**/; i++ ) {
+            
+            try {
+                element = parameterClass.newInstance();
+            } catch ( Exception e ) {
+                log.error( "Cannot instantiate class: {}", parameterClass.getName() );
+                return;
+            }
+            
+            prefix = name + "(" + i + ")";
+            res = element.readConfiguration( configuration, prefix );
+
+            if ( res == false )
+                // end of list reached
+                break;
+            
+            list.add( element );
         }
     }
 
     @Override
+    @SuppressWarnings("unchecked")
     public void setObjectValue( Object object )
     {
         if ( !(object instanceof List) ) {
             throw new IllegalArgumentException( "Only accept a List parameter." );
         }
-        
-        list = (List<T>)object;
+
+        list = (List) object;
     }
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/ListParameter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -10,9 +10,9 @@
  ***************************************************************************/
 
 /*
- * $Id: Main.java 378 2006-01-06 20:36:11Z rbieniek $
+ * $Id$
  * 
- * $URL: https://svn.berlios.de/svnroot/repos/rtspproxy/trunk/RTSPProxy-App/src/main/java/rtspproxy/Main.java $
+ * $URL$
  * 
  */
 package rtspproxy.config;
@@ -25,6 +25,7 @@
 import java.io.Reader;
 import java.util.NoSuchElementException;
 
+import org.apache.commons.configuration.Configuration;
 import org.apache.commons.configuration.ConfigurationException;
 import org.apache.commons.configuration.XMLConfiguration;
 import org.dom4j.DocumentException;
@@ -35,14 +36,16 @@
  * This class implements a parser for XML configuration files.
  * 
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- * @todo validate the parsed configuration file by a schema.
  */
-public class XMLConfigReader
+public final class XMLConfigReader
 {
 
-    // logger
     private static final Logger log = LoggerFactory.getLogger( XMLConfigReader.class );
 
+   
+    private static final XMLConfiguration configuration = new XMLConfiguration(); 
+
+
     /**
      * read the configuration file.
      * 
@@ -53,9 +56,9 @@
      * @throws DocumentException
      *             parsing the config file failed.
      */
-    public final void readConfig( String fileName ) throws FileNotFoundException
+    public void readConfig( String fileName ) throws FileNotFoundException
     {
-        log.debug( "Reading configuration file={}", fileName );
+        log.debug( "Reading configuration file='{}'", fileName );
         File file = new File( fileName );
 
         if ( file.canRead() ) {
@@ -69,9 +72,8 @@
      * @param is
      *            the input stream to read the configuration from.
      */
-    public final void readConfig( Reader reader )
+    public void readConfig( Reader reader )
     {
-        XMLConfiguration configuration = new XMLConfiguration();
         try {
             configuration.load( reader );
         } catch ( ConfigurationException e ) {
@@ -93,4 +95,9 @@
 
         Config.updateDebugSettings();
     }
+    
+    public static Configuration getConfiguration()
+    {
+    	return configuration;    
+    }
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/config/XMLConfigReader.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -3,74 +3,58 @@
  */
 package rtspproxy.filter;
 
-import java.util.List;
-
 import javax.management.ObjectName;
 
+import org.apache.commons.configuration.Configuration;
 import org.apache.mina.common.IoFilterAdapter;
-import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.Reactor;
-import rtspproxy.config.AAAConfigurable;
-import rtspproxy.lib.Side;
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  * 
  */
-public class FilterBase extends IoFilterAdapter
+public abstract class FilterBase<T extends GenericProvider> extends IoFilterAdapter
 {
 
-    private static Logger logger = LoggerFactory.getLogger( FilterBase.class );
+    private static Logger log = LoggerFactory.getLogger( FilterBase.class );
 
-    // filter name
-    private String filterName;
+    /** running flag */
+    private boolean isRunning = true;
 
-    // class name
-    private String className;
+    /** MBean name assigned by JMX interface */
+    private ObjectName mbeanName;
 
-    // filter type
-    private String typeName;
+    /** chain name of filter */
+    private String chainName;
 
-    // running flag
-    protected boolean running = true;
+    // Abstract methods
+    public abstract String getName();
 
-    // side
-    private Side side;
+    public String getProviderClassName() { return null; }
 
-    // MBean name assigned by JMX interface
-    private ObjectName mbeanName;
+    protected Class<T> getProviderInterface() { return null; }
 
-    // chain name of filter
-    private String chainName;
+    protected void setProvider( T provider ) {}
 
     /**
+     * Subclasses can overload the method to read theyr own configuration
+     * parameters.
      * 
+     * @param configuration A {Configuration} object to read from.
      */
-    public FilterBase( String filterName, String className, String typeName )
+    protected void doConfigure( Configuration configuration )
     {
-        this.filterName = filterName;
-        this.className = className;
-        this.typeName = typeName;
     }
 
     /**
-     * 
-     */
-    public FilterBase( String filterName, String typeName )
-    {
-        this.filterName = filterName;
-        this.typeName = typeName;
-    }
-
-    /**
      * query running flag
      */
     public final boolean isRunning()
     {
-        return this.running;
+        return isRunning;
     }
 
     /**
@@ -78,8 +62,8 @@
      */
     public final void suspend()
     {
-        this.running = false;
-        logger.info( getChainName() + " suspended" );
+        isRunning = false;
+        log.info( "{} suspended", getChainName() );
     }
 
     /**
@@ -87,8 +71,8 @@
      */
     public final void resume()
     {
-        this.running = true;
-        logger.info( getChainName() + " resumed" );
+        isRunning = true;
+        log.info( "{} resumed", getChainName() );
     }
 
     /**
@@ -100,22 +84,6 @@
     }
 
     /**
-     * get the side
-     */
-    public Side getSide()
-    {
-        return this.side;
-    }
-
-    /**
-     * set the side
-     */
-    public void setSide( Side side )
-    {
-        this.side = side;
-    }
-
-    /**
      * @return Returns the mbeanName.
      */
     public ObjectName getMbeanName()
@@ -138,100 +106,78 @@
     }
 
     /**
-     * @return Returns the className.
-     */
-    public String getClassName()
-    {
-        return className;
-    }
-
-    /**
-     * @return Returns the typeName.
-     */
-    public String getTypeName()
-    {
-        return typeName;
-    }
-
-    /**
      * get the chain name for the filter.
      */
     public String getChainName()
     {
-
         if ( this.chainName == null ) {
-            StringBuffer buf = new StringBuffer( this.filterName );
+            StringBuilder buf = new StringBuilder();
 
+            buf.append( getName() );
             buf.append( '/' );
-            buf.append( this.typeName );
-            if ( this.className != null ) {
+            buf.append( getProviderInterface() );
+            if ( getProviderClassName() != null ) {
                 buf.append( '/' );
-                buf.append( this.className );
+                buf.append( getProviderClassName() );
             }
-
             this.chainName = buf.toString();
         }
+
         return this.chainName;
     }
 
-    /**
-     * load a provider class, instantiate an object, configure and init it.
-     * 
-     * @param className
-     *            the name of the provider class to load
-     * @param requiredInterface
-     *            the provider interface the loaded class should implement. This
-     *            implementation assumes that the interface is a sub-interface
-     *            of GenericProvider
-     * @param configElements
-     *            the configuration elements used to configure the loaded
-     *            provider
-     */
-    protected GenericProvider loadConfigInitProvider( String className,
-            Class requiredInterface, List<Element> configElements )
+    @SuppressWarnings("unchecked")
+    public final void configure( Configuration configuration )
     {
-        GenericProvider provider = null;
-        String providerName = requiredInterface.getSimpleName();
+        // Configure the concrete class implementation
+        doConfigure( configuration );
+
         Class providerClass;
+	String className = getProviderClassName(); 
+	if ( className == null ) {
+		// The filter does not have a provider 
+		// system. Ignore it.
+		return;
+	}
+
         try {
             providerClass = Class.forName( className );
 
         } catch ( Throwable t ) {
-            logger.error( "Invalid " + providerName + "class: " + className, t );
+            log.error( "Class not found: {}", className );
             Reactor.stop();
-            return null;
+            return;
         }
 
-        // Check if the class implements the IpAddressProvider interfaces
+        // Check if the class implements the required interface
         boolean found = false;
+        Class<T> requiredInterface = getProviderInterface();
         for ( Class interFace : providerClass.getInterfaces() ) {
-            if ( requiredInterface.equals( interFace ) ) {
+            if ( interFace.equals( requiredInterface ) ) {
                 found = true;
                 break;
             }
         }
 
         if ( !found ) {
-            logger.error( "Class ({}) does not implement the {} interface.", providerClass,
-                    providerName );
+            log.error( "Class ({}) does not implement the {} interface.", providerClass,
+                    requiredInterface );
             Reactor.stop();
-            return null;
+            return;
         }
 
+	// Instanciate the provider and configure it.
         try {
-            provider = (GenericProvider) providerClass.newInstance();
+            T provider = (T) providerClass.newInstance();
+            setProvider( provider );
+            provider.configure( configuration );
+            provider.start();
 
-            if ( provider instanceof AAAConfigurable )
-                ((AAAConfigurable) provider).configure( configElements );
-
-            provider.init();
-
         } catch ( Exception e ) {
-            logger.error( "Error starting " + providerName + ": " + e );
+            log.error( "Error instanciaing class '{}'", providerClass );
             Reactor.stop();
-            return null;
+            return;
         }
-
-        return provider;
     }
+
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterBase.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -10,249 +10,167 @@
  ***************************************************************************/
 
 /*
- * $Id: RtspFilters.java 406 2006-01-27 00:28:56Z rbieniek $
+ * $Id$
  * 
- * $URL: https://svn.berlios.de/svnroot/repos/rtspproxy/trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java $
+ * $URL$
  * 
  */
 
 package rtspproxy.filter;
 
-import java.util.Collections;
-import java.util.LinkedList;
-import java.util.List;
-
+import org.apache.commons.configuration.Configuration;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.Reactor;
-import rtspproxy.config.AAAConfig;
 import rtspproxy.config.Config;
+import rtspproxy.config.XMLConfigReader;
 import rtspproxy.filter.accounting.AccountingFilter;
 import rtspproxy.filter.authentication.AuthenticationFilter;
-import rtspproxy.filter.control.ClientControlFilter;
-import rtspproxy.filter.control.ServerControlFilter;
 import rtspproxy.filter.ipaddress.IpAddressFilter;
-import rtspproxy.filter.rewrite.ClientUrlRewritingFilter;
-import rtspproxy.filter.rewrite.ServerUrlRewritingFilter;
 import rtspproxy.filter.rewrite.UrlRewritingFilter;
 import rtspproxy.jmx.JmxAgent;
-import rtspproxy.lib.Side;
 import rtspproxy.lib.Singleton;
+import rtspproxy.lib.Side;
 
 /**
- * Filter registry. This registry is populated from the configuration on reactor startup
+ * Filter registry. This registry is populated from the configuration on reactor
+ * startup
  * 
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
  */
-public class FilterRegistry extends Singleton {
+public class FilterRegistry extends Singleton
+{
 
-	private static Logger logger = LoggerFactory.getLogger(FilterRegistry.class);
+    private static Logger log = LoggerFactory.getLogger( FilterRegistry.class );
 
-	// client side address filters
-	private List<IpAddressFilter> clientAddressFilters = new LinkedList<IpAddressFilter>();
-	
-	// server side address filters
-	private List<IpAddressFilter> serverAddressFilters = new LinkedList<IpAddressFilter>();
+    private IpAddressFilter clientAddressFilter = null;
 
-	// client side authentication filters
-	private List<AuthenticationFilter> clientAuthenticationFilters = new LinkedList<AuthenticationFilter>();
-	
-	// client side accounting filter
-	private List<AccountingFilter> clientAccountingFilters = new LinkedList<AccountingFilter>();
-	
-	// server side accounting filter
-	private List<AccountingFilter> serverAccountingFilters = new LinkedList<AccountingFilter>();
-	
-	// client side rewriting filters
-	private List<UrlRewritingFilter> clientUrlRewritingFilters = new LinkedList<UrlRewritingFilter>();
-	
-	// server side rewriting filters
-	private List<UrlRewritingFilter> serverUrlRewritingFilters = new LinkedList<UrlRewritingFilter>();
-	
-	// client side control traffic filters
-	private List<ClientControlFilter> clientControlFilters = new LinkedList<ClientControlFilter>();
-	
-	// client side control traffic filters
-	private List<ServerControlFilter> serverControlFilters = new LinkedList<ServerControlFilter>();
-	
-	/**
-	 * 
-	 */
-	public FilterRegistry() {
-	}
+    private IpAddressFilter serverAddressFilter = null;
 
-	/**
-	 * get the active registry instance
-	 */
-	public static FilterRegistry getInstance() {
-		return (FilterRegistry)Singleton.getInstance(FilterRegistry.class);
-	}
-	
-	// flag to determine if already populated
-	private boolean populated = false;
-	
-	/**
-	 * populate from configuration
-	 */
-	public void populateRegistry() {
-		if(this.populated) {
-			logger.debug("filter registry already populated");
-			return;
-		}
-		
-		try {
-			for(AAAConfig filterConfig : Config.getIpAddressFilters()) {
-				IpAddressFilter ipAddressFilter = new IpAddressFilter(filterConfig.getImplClass(), 
-						filterConfig.getConfigElements());
-				
-				ipAddressFilter.setSide(filterConfig.getSide());
-				registerFilterMBean(ipAddressFilter);
+    private AuthenticationFilter authenticationFilter = null;
 
-				if(filterConfig.getSide() == Side.Client) {
-					this.clientAddressFilters.add(ipAddressFilter);
-				} else if(filterConfig.getSide() == Side.Server) {
-					this.serverAddressFilters.add(ipAddressFilter);
-				} else {
-					this.clientAddressFilters.add(ipAddressFilter);
-					this.serverAddressFilters.add(ipAddressFilter);
-				}
-			}
-			
-			for(AAAConfig filterConfig : Config.getAuthenticationFilters()) {
-				if(filterConfig.getSide() == Side.Client) {
-					AuthenticationFilter authFilter = new AuthenticationFilter(filterConfig.getImplClass(), 
-							filterConfig.getAttribute("scheme", "Basic"),
-							filterConfig.getConfigElements());
-					
-					authFilter.setSide(filterConfig.getSide());
-					registerFilterMBean(authFilter);
+    private AccountingFilter accountingFilter = null;
 
-					this.clientAuthenticationFilters.add(authFilter);
-				}
-			}
-			
-			for(AAAConfig filterConfig : Config.getAccountingFilters()) {
-				AccountingFilter accountingFilter = new AccountingFilter(filterConfig.getImplClass(), 
-						filterConfig.getConfigElements());
-				
-				accountingFilter.setSide(filterConfig.getSide());
-				registerFilterMBean(accountingFilter);
+    private UrlRewritingFilter clientRewritingFilter = null;
 
-				if(filterConfig.getSide() == Side.Client) {
-					this.clientAccountingFilters.add(accountingFilter);
-				} else if(filterConfig.getSide() == Side.Server) {
-					this.serverAccountingFilters.add(accountingFilter);
-				} else {
-					this.clientAccountingFilters.add(accountingFilter);
-					this.serverAccountingFilters.add(accountingFilter);
-				}
-			}
+    private UrlRewritingFilter serverRewritingFilter = null;
 
-			for(AAAConfig filterConfig : Config.getUrlRewritingFilters()) {
-				UrlRewritingFilter urlRewritingFilter;
-				
-				urlRewritingFilter = new ClientUrlRewritingFilter(filterConfig.getImplClass(), 
-						filterConfig.getConfigElements());			
-				urlRewritingFilter.setSide(Side.Client);
-				registerFilterMBean(urlRewritingFilter);
-				this.clientUrlRewritingFilters.add(urlRewritingFilter);
+    /**
+     * Get the active registry instance
+     */
+    public static FilterRegistry getInstance()
+    {
+        return (FilterRegistry) Singleton.getInstance( FilterRegistry.class );
+    }
 
-				urlRewritingFilter = new ServerUrlRewritingFilter(filterConfig.getImplClass(), 
-						filterConfig.getConfigElements());			
-				urlRewritingFilter.setSide(Side.Server);
-				registerFilterMBean(urlRewritingFilter);
-				this.serverUrlRewritingFilters.add(urlRewritingFilter);
-			}
+    // flag to determine if already populated
+    private boolean populated = false;
 
-			for(AAAConfig filterConfig : Config.getControlFilters()) {
-				if(filterConfig.getSide() == Side.Client) {
-					ClientControlFilter filter = new ClientControlFilter(filterConfig.getImplClass(),
-							filterConfig.getConfigElements());
-					
-					filter.setSide(Side.Client);
-					registerFilterMBean(filter);
-					this.clientControlFilters.add(filter);
-				} else {
-					ServerControlFilter filter = new ServerControlFilter(filterConfig.getImplClass(),
-							filterConfig.getConfigElements());
-					
-					filter.setSide(Side.Client);
-					registerFilterMBean(filter);
-					this.serverControlFilters.add(filter);
-				}
-			}
-			
-		} catch (Throwable t) {
-			logger.error("failed to populate filter registry", t);	
-			
-			Reactor.stop();
-			System.exit(-1);
-		}
-		
-		this.populated = true;
-	}
-	
-	private void registerFilterMBean(FilterBase filter) {
-		if(Config.jmxEnable.getValue())
-			JmxAgent.getInstance().registerFilter(filter);
-	}
+    /**
+     * populate from configuration
+     */
+    public void populateRegistry()
+    {
+        log.debug( "Populate filter registry." );
 
-	/**
-	 * @return Returns the clientAddressFilters.
-	 */
-	public List<IpAddressFilter> getClientAddressFilters() {
-		return Collections.unmodifiableList(clientAddressFilters);
-	}
+        if ( populated ) {
+            log.debug( "Filter registry already populated." );
+            return;
+        }
 
-	/**
-	 * @return Returns the serverAddressFilters.
-	 */
-	public List<IpAddressFilter> getServerAddressFilters() {
-		return Collections.unmodifiableList(serverAddressFilters);
-	}
+        Configuration config = XMLConfigReader.getConfiguration();
 
-	/**
-	 * @return Returns the clientAuthenticationFilters.
-	 */
-	public List<AuthenticationFilter> getClientAuthenticationFilters() {
-		return Collections.unmodifiableList(clientAuthenticationFilters);
-	}
+        if ( Config.filtersAuthenticationEnable.getValue() ) {
+            authenticationFilter = new AuthenticationFilter();
+            authenticationFilter.configure( config );
+            registerFilterMBean( authenticationFilter );
+        }
 
-	/**
-	 * @return Returns the clientAccountingFilters.
-	 */
-	public List<AccountingFilter> getClientAccountingFilters() {
-		return Collections.unmodifiableList(clientAccountingFilters);
-	}
+        if ( Config.filtersIpAddressEnable.getValue() ) {
+            clientAddressFilter = new IpAddressFilter( Side.Client );
+            clientAddressFilter.configure( config );
+            registerFilterMBean( clientAddressFilter );
 
-	/**
-	 * @return Returns the serverAccountingFilters.
-	 */
-	public List<AccountingFilter> getServerAccountingFilters() {
-		return Collections.unmodifiableList(serverAccountingFilters);
-	}
+            serverAddressFilter = new IpAddressFilter( Side.Server );
+            serverAddressFilter.configure( config );
+            registerFilterMBean( serverAddressFilter );         
+        }
 
-	public List<UrlRewritingFilter> getClientUrlRewritingFilters() {
-		return Collections.unmodifiableList(clientUrlRewritingFilters);
-	}
+        if ( Config.filtersRewriteEnable.getValue() ) {
+            clientRewritingFilter = new UrlRewritingFilter( Side.Client );
+            clientRewritingFilter.configure( config );
+            registerFilterMBean( clientRewritingFilter );
 
-	public List<UrlRewritingFilter> getServerUrlRewritingFilters() {
-		return Collections.unmodifiableList(serverUrlRewritingFilters);
-	}
+            serverRewritingFilter = new UrlRewritingFilter( Side.Server );
+            serverRewritingFilter.configure( config );
+            registerFilterMBean( serverRewritingFilter );
+        }
 
-	/**
-	 * @return Returns the clientControlFilters.
-	 */
-	public List<ClientControlFilter> getClientControlFilters() {
-		return Collections.unmodifiableList(clientControlFilters);
-	}
+        try {
+            // TODO: XXXXX
 
-	/**
-	 * @return Returns the serverControlFilters.
-	 */
-	public List<ServerControlFilter> getServerControlFilters() {
-		return Collections.unmodifiableList(serverControlFilters);
-	}
-	
+        } catch ( Throwable t ) {
+            log.error( "Failed to populate filter registry", t );
+
+            Reactor.stop();
+        }
+
+        this.populated = true;
+    }
+
+    private void registerFilterMBean( FilterBase filter )
+    {
+        if ( Config.jmxEnable.getValue() )
+            JmxAgent.getInstance().registerFilter( filter );
+    }
+
+    /**
+     * @return the accountingFilter
+     */
+    public AccountingFilter getAccountingFilter()
+    {
+        return accountingFilter;
+    }
+
+    /**
+     * @return the addressFilter
+     */
+    public IpAddressFilter getClientAddressFilter()
+    {
+        return clientAddressFilter;
+    }
+
+    /**
+     * @return the server address filter
+     */
+    public IpAddressFilter getServerAddressFilter()
+    {
+        return serverAddressFilter;
+    }
+
+    /**
+     * @return the authenticationFilter
+     */
+    public AuthenticationFilter getAuthenticationFilter()
+    {
+        return authenticationFilter;
+    }
+
+    /**
+     * @return the rewritingFilter
+     */
+    public UrlRewritingFilter getClientRewritingFilter()
+    {
+        return clientRewritingFilter;
+    }
+
+    /**
+     * @return the rewritingFilter
+     */
+    public UrlRewritingFilter getServerRewritingFilter()
+    {
+        return serverRewritingFilter;
+    }
+
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/FilterRegistry.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProvider.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProvider.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProvider.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -3,6 +3,8 @@
  */
 package rtspproxy.filter;
 
+import org.apache.commons.configuration.Configuration;
+
 /**
  * Generic interface used as a parent interface to specific filter provider definitions.
  * 
@@ -17,11 +19,13 @@
 	 * 
 	 * @throws Exception
 	 */
-	public void init() throws Exception;
+	public void start() throws Exception;
 
 	/**
 	 * Called once at service shutdown.
 	 */
-	public void shutdown();
+	public void stop();
+    
+    public void configure( Configuration configuration ) throws Exception;
 
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProvider.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProviderAdapter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProviderAdapter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/GenericProviderAdapter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,27 +0,0 @@
-/**
- * 
- */
-package rtspproxy.filter;
-
-/**
- * Default implementation of the GenericProivder interface. Provides empty default 
- * implementations.
- * 
- * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
- */
-public class GenericProviderAdapter implements GenericProvider {
-
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.GenericProvider#init()
-	 */
-	public void init() throws Exception {
-	}
-
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.GenericProvider#shutdown()
-	 */
-	public void shutdown() {
-	}
-
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspClientFilters.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspClientFilters.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspClientFilters.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -36,8 +36,8 @@
 		addRtspCodecFilter( chain );
 		addAuthenticationFilter( chain );
 		addRewriteFilter( chain, Side.Client );
-		addAccountingFilter( chain, Side.Client );
-		addControlFilter( chain, Side.Client );
+		addAccountingFilter( chain );
+		addControlFilter( chain );
 	}
 
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspFilters.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -18,8 +18,6 @@
 
 package rtspproxy.filter;
 
-import java.util.List;
-
 import org.apache.mina.common.IoFilter;
 import org.apache.mina.common.IoFilterChain;
 import org.apache.mina.common.IoFilterChainBuilder;
@@ -31,9 +29,6 @@
 import rtspproxy.ProxyServiceRegistry;
 import rtspproxy.filter.accounting.AccountingFilter;
 import rtspproxy.filter.authentication.AuthenticationFilter;
-import rtspproxy.filter.control.ClientControlFilter;
-import rtspproxy.filter.control.ControlFilter;
-import rtspproxy.filter.control.ServerControlFilter;
 import rtspproxy.filter.ipaddress.IpAddressFilter;
 import rtspproxy.filter.rewrite.UrlRewritingFilter;
 import rtspproxy.lib.Side;
@@ -69,7 +64,7 @@
 
     private static final IoFilter codecFilter = new ProtocolCodecFilter( codecFactory );
 
-    public static final String rtspCodecNAME = "rtspCodec";
+    private static final String rtspCodecNAME = "rtspCodec";
 
     /**
      * IP Address filter.
@@ -80,20 +75,17 @@
      */
     protected void addIpAddressFilter( IoFilterChain chain, Side side )
     {
-        // XXX: disabled
-        /*
-         * List<IpAddressFilter> filters;
-         * 
-         * if(side == Side.Client) filters =
-         * FilterRegistry.getInstance().getClientAddressFilters(); else filters =
-         * FilterRegistry.getInstance().getServerAddressFilters();
-         * 
-         * for(IpAddressFilter ipAddressFilter : filters) {
-         * 
-         * chain.addAfter( ProxyServiceRegistry.threadPoolFilterNAME,
-         * ipAddressFilter.getChainName(), ipAddressFilter );
-         *  }
-         */
+        IpAddressFilter filter;
+	if ( side == Side.Client )
+		filter = FilterRegistry.getInstance().getClientAddressFilter();
+	else
+		filter = FilterRegistry.getInstance().getServerAddressFilter();
+
+	if ( filter == null )
+		return;
+
+	chain.addAfter( ProxyServiceRegistry.threadPoolFilterNAME, filter.getChainName(),
+                filter );
     }
 
     /**
@@ -110,74 +102,54 @@
      */
     protected void addAuthenticationFilter( IoFilterChain chain )
     {
-        for ( AuthenticationFilter authenticationFilter : FilterRegistry.getInstance()
-                .getClientAuthenticationFilters() ) {
-            chain.addAfter( rtspCodecNAME, authenticationFilter.getChainName(),
-                    authenticationFilter );
-        }
-    }
+        AuthenticationFilter filter = FilterRegistry.getInstance()
+                .getAuthenticationFilter();
 
-    protected void addAccountingFilter( IoFilterChain chain, Side side )
-    {
-        // XXX: disabled
-        /*
-        List<AccountingFilter> filters;
+	if ( filter == null )
+		return;
 
-        if ( side == Side.Client ) {
-            filters = FilterRegistry.getInstance().getClientAccountingFilters();
+        chain.addAfter( rtspCodecNAME, filter.getChainName(), filter );
+    }
 
-            for ( AccountingFilter accountingFilter : filters ) {
-                chain.addAfter( rtspCodecNAME, accountingFilter.getChainName(),
-                        accountingFilter );
-            }
-        } else {
-            filters = FilterRegistry.getInstance().getServerAccountingFilters();
-
-            for ( AccountingFilter accountingFilter : filters ) {
-                chain.addAfter( rtspCodecNAME, accountingFilter.getChainName(),
-                        accountingFilter );
-            }
-        }
-        */
+    protected void addAccountingFilter( IoFilterChain chain )
+    {
+	AccountingFilter filter = FilterRegistry.getInstance().getAccountingFilter();
+    
+	if ( filter == null )
+		return;
+    
+	chain.addAfter( rtspCodecNAME, filter.getChainName(), filter ); 
     }
 
     protected void addRewriteFilter( IoFilterChain chain, Side side )
     {
-        // XXX: disabled
-        /*
-        List<UrlRewritingFilter> filters;
-
-        if ( side == Side.Client )
-            filters = FilterRegistry.getInstance().getClientUrlRewritingFilters();
-        else
-            filters = FilterRegistry.getInstance().getServerUrlRewritingFilters();
-
-        for ( UrlRewritingFilter urlRewritingFilter : filters ) {
-
-            chain.addAfter( rtspCodecNAME, urlRewritingFilter.getChainName(),
-                    urlRewritingFilter );
-        }
-        */
+	UrlRewritingFilter filter;
+	
+	if ( side == Side.Client )
+		filter = FilterRegistry.getInstance().getClientRewritingFilter();
+	else
+		filter = FilterRegistry.getInstance().getServerRewritingFilter();
+	
+	if ( filter == null )
+		return;
+          
+         chain.addAfter( rtspCodecNAME, filter.getChainName(), filter ); 
     }
 
-    protected void addControlFilter( IoFilterChain chain, Side side )
+    protected void addControlFilter( IoFilterChain chain )
     {
-        if ( side == Side.Client ) {
-            List<ClientControlFilter> filters = FilterRegistry.getInstance()
-                    .getClientControlFilters();
-
-            for ( ControlFilter controlFilter : filters ) {
-                chain.addAfter( rtspCodecNAME, controlFilter.getChainName(),
-                        controlFilter );
-            }
-        } else {
-            List<ServerControlFilter> filters = FilterRegistry.getInstance()
-                    .getServerControlFilters();
-
-            for ( ControlFilter controlFilter : filters ) {
-                chain.addAfter( rtspCodecNAME, controlFilter.getChainName(),
-                        controlFilter );
-            }
-        }
+        // XXX: disabled
+        /*
+         * if ( side == Side.Client ) { List<ClientControlFilter> filters =
+         * FilterRegistry.getInstance() .getClientControlFilters();
+         * 
+         * for ( ControlFilter controlFilter : filters ) { chain.addAfter(
+         * rtspCodecNAME, controlFilter.getChainName(), controlFilter ); } }
+         * else { List<ServerControlFilter> filters =
+         * FilterRegistry.getInstance() .getServerControlFilters();
+         * 
+         * for ( ControlFilter controlFilter : filters ) { chain.addAfter(
+         * rtspCodecNAME, controlFilter.getChainName(), controlFilter ); } }
+         */
     }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspServerFilters.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspServerFilters.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/RtspServerFilters.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -35,8 +35,8 @@
 		addIpAddressFilter( chain, Side.Server );
 		addRtspCodecFilter( chain );
 		addRewriteFilter( chain, Side.Server );
-		addAccountingFilter( chain, Side.Server );
-		addControlFilter ( chain, Side.Server );
+		addAccountingFilter( chain );
+		addControlFilter ( chain );
 	}
 
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,13 +1,11 @@
 package rtspproxy.filter.accounting;
 
-import java.util.List;
-
 import org.apache.mina.common.IdleStatus;
 import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import rtspproxy.config.Config;
 import rtspproxy.filter.FilterBase;
 import rtspproxy.rtsp.RtspMessage;
 
@@ -15,97 +13,165 @@
  * 
  * @author Matteo Merli
  */
-public class AccountingFilter extends FilterBase
+public class AccountingFilter extends FilterBase<AccountingProvider>
 {
 
-	private static Logger log = LoggerFactory.getLogger( AccountingFilter.class );
+    private static Logger log = LoggerFactory.getLogger( AccountingFilter.class );
 
-	public static final String FilterNAME = "accountingFilter";
+    public static final String FilterNAME = "accountingFilter";
 
-	private AccountingProvider provider = null;
+    private AccountingProvider provider = null;
 
-	public AccountingFilter(String className, List<Element> configElements)
-	{
-		super(FilterNAME, className, "accounting");
-		
-		this.provider = (AccountingProvider)loadConfigInitProvider(className, AccountingProvider.class,
-				configElements);
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getName()
+     */
+    @Override
+    public String getName()
+    {
+        return FilterNAME;
+    }
 
-	@Override
-	public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( provider != null && isRunning()) {
-			if ( message instanceof RtspMessage )
-				provider.messageReceived( session, (RtspMessage) message );
-			else
-				log.error( "Expecting a RtspMessage. Received a "
-						+ message.getClass().getName() );
-		}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#setProvider(rtspproxy.filter.GenericProvider)
+     */
+    @Override
+    public void setProvider( AccountingProvider provider )
+    {
+        this.provider = provider;
+    }
 
-		// Forward message
-		nextFilter.messageReceived( session, message );
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getProviderInterface()
+     */
+    @Override
+    public Class<AccountingProvider> getProviderInterface()
+    {
+        return AccountingProvider.class;
+    }
 
-	@Override
-	public void messageSent( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( provider != null  && isRunning()) {
-			if ( message instanceof RtspMessage )
-				provider.messageSent( session, (RtspMessage) message );
-			else
-				log.error( "Expecting a RtspMessage. Received a "
-						+ message.getClass().getName() );
-		}
-		
-		// Forward message
-		nextFilter.messageSent( session, message );
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getProviderClassName()
+     */
+    @Override
+    public String getProviderClassName()
+    {
+        return Config.filtersAccountingImplClass.getValue();
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.mina.common.IoFilterAdapter#sessionClosed(org.apache.mina.common.IoFilter.NextFilter, org.apache.mina.common.IoSession)
-	 */
-	@Override
-	public void sessionClosed(NextFilter nextFilter, IoSession session) throws Exception {
-		if ( provider != null  && isRunning())
-			provider.sessionClosed( session );
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#messageReceived(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession, java.lang.Object)
+     */
+    @Override
+    public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+        if ( provider != null && isRunning() ) {
+            if ( message instanceof RtspMessage )
+                provider.messageReceived( session, (RtspMessage) message );
+            else
+                log.error( "Expecting a RtspMessage. Received a "
+                        + message.getClass().getName() );
+        }
 
-		super.sessionClosed(nextFilter, session);
-	}
+        // Forward message
+        nextFilter.messageReceived( session, message );
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.mina.common.IoFilterAdapter#sessionCreated(org.apache.mina.common.IoFilter.NextFilter, org.apache.mina.common.IoSession)
-	 */
-	@Override
-	public void sessionCreated(NextFilter nextFilter, IoSession session) throws Exception {
-		if ( provider != null && isRunning() )
-			provider.sessionCreated( session );
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#messageSent(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession, java.lang.Object)
+     */
+    @Override
+    public void messageSent( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+        if ( provider != null && isRunning() ) {
+            if ( message instanceof RtspMessage )
+                provider.messageSent( session, (RtspMessage) message );
+            else
+                log.error( "Expecting a RtspMessage. Received a "
+                        + message.getClass().getName() );
+        }
 
-		super.sessionCreated(nextFilter, session);
-	}
+        // Forward message
+        nextFilter.messageSent( session, message );
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.mina.common.IoFilterAdapter#sessionIdle(org.apache.mina.common.IoFilter.NextFilter, org.apache.mina.common.IoSession, org.apache.mina.common.IdleStatus)
-	 */
-	@Override
-	public void sessionIdle(NextFilter nextFilter, IoSession session, IdleStatus status) throws Exception {
-		if ( provider != null && isRunning() )
-			provider.sessionIdle( session, status );
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#sessionClosed(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession)
+     */
+    @Override
+    public void sessionClosed( NextFilter nextFilter, IoSession session )
+            throws Exception
+    {
+        if ( provider != null && isRunning() )
+            provider.sessionClosed( session );
 
-		super.sessionIdle(nextFilter, session, status);
-	}
+        super.sessionClosed( nextFilter, session );
+    }
 
-	/* (non-Javadoc)
-	 * @see org.apache.mina.common.IoFilterAdapter#sessionOpened(org.apache.mina.common.IoFilter.NextFilter, org.apache.mina.common.IoSession)
-	 */
-	@Override
-	public void sessionOpened(NextFilter nextFilter, IoSession session) throws Exception {
-		if ( provider != null && isRunning() )
-			provider.sessionOpened( session );
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#sessionCreated(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession)
+     */
+    @Override
+    public void sessionCreated( NextFilter nextFilter, IoSession session )
+            throws Exception
+    {
+        if ( provider != null && isRunning() )
+            provider.sessionCreated( session );
 
-		super.sessionOpened(nextFilter, session);
-	}
+        super.sessionCreated( nextFilter, session );
+    }
 
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#sessionIdle(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession, org.apache.mina.common.IdleStatus)
+     */
+    @Override
+    public void sessionIdle( NextFilter nextFilter, IoSession session, IdleStatus status )
+            throws Exception
+    {
+        if ( provider != null && isRunning() )
+            provider.sessionIdle( session, status );
+
+        super.sessionIdle( nextFilter, session, status );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#sessionOpened(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession)
+     */
+    @Override
+    public void sessionOpened( NextFilter nextFilter, IoSession session )
+            throws Exception
+    {
+        if ( provider != null && isRunning() )
+            provider.sessionOpened( session );
+
+        super.sessionOpened( nextFilter, session );
+    }
+
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingProviderAdapter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingProviderAdapter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingProviderAdapter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -6,58 +6,80 @@
 import org.apache.mina.common.IdleStatus;
 import org.apache.mina.common.IoSession;
 
-import rtspproxy.filter.GenericProviderAdapter;
 import rtspproxy.rtsp.RtspMessage;
 
 /**
- * Default implementation of the AccountingProvider interface.
- * Provides no-op method implementations.
+ * Default implementation of the AccountingProvider interface. Provides no-op
+ * method implementations.
  * 
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public class AccountingProviderAdapter extends GenericProviderAdapter implements AccountingProvider {
+public abstract class AccountingProviderAdapter implements AccountingProvider
+{
 
-	/**
-	 * 
-	 */
-	public AccountingProviderAdapter() {
-	}
+    /**
+     * 
+     */
+    public AccountingProviderAdapter()
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.accounting.AccountingProvider#messageReceived(org.apache.mina.common.IoSession, rtspproxy.rtsp.RtspMessage)
-	 */
-	public void messageReceived(IoSession session, RtspMessage message) {
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.accounting.AccountingProvider#messageReceived(org.apache.mina.common.IoSession,
+     *      rtspproxy.rtsp.RtspMessage)
+     */
+    public void messageReceived( IoSession session, RtspMessage message )
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.accounting.AccountingProvider#messageSent(org.apache.mina.common.IoSession, rtspproxy.rtsp.RtspMessage)
-	 */
-	public void messageSent(IoSession session, RtspMessage message) {
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.accounting.AccountingProvider#messageSent(org.apache.mina.common.IoSession,
+     *      rtspproxy.rtsp.RtspMessage)
+     */
+    public void messageSent( IoSession session, RtspMessage message )
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.accounting.AccountingProvider#sessionCreated(org.apache.mina.common.IoSession)
-	 */
-	public void sessionCreated(IoSession session) {
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.accounting.AccountingProvider#sessionCreated(org.apache.mina.common.IoSession)
+     */
+    public void sessionCreated( IoSession session )
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.accounting.AccountingProvider#sessionOpened(org.apache.mina.common.IoSession)
-	 */
-	public void sessionOpened(IoSession session) {
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.accounting.AccountingProvider#sessionOpened(org.apache.mina.common.IoSession)
+     */
+    public void sessionOpened( IoSession session )
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.accounting.AccountingProvider#sessionClosed(org.apache.mina.common.IoSession)
-	 */
-	public void sessionClosed(IoSession session) {
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.accounting.AccountingProvider#sessionClosed(org.apache.mina.common.IoSession)
+     */
+    public void sessionClosed( IoSession session )
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.accounting.AccountingProvider#sessionIdle(org.apache.mina.common.IoSession, org.apache.mina.common.IdleStatus)
-	 */
-	public void sessionIdle(IoSession session, IdleStatus status) {
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.accounting.AccountingProvider#sessionIdle(org.apache.mina.common.IoSession,
+     *      org.apache.mina.common.IdleStatus)
+     */
+    public void sessionIdle( IoSession session, IdleStatus status )
+    {
+    }
 
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/accounting/AccountingProviderAdapter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/AuthenticationFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -18,17 +18,15 @@
 
 package rtspproxy.filter.authentication;
 
-import java.util.Arrays;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import rtspproxy.Reactor;
+import rtspproxy.config.Config;
 import rtspproxy.filter.FilterBase;
 import rtspproxy.filter.authentication.scheme.AuthenticationScheme;
 import rtspproxy.filter.authentication.scheme.BasicAuthentication;
@@ -42,14 +40,14 @@
 /**
  * @author Matteo Merli
  */
-public class AuthenticationFilter extends FilterBase
+public class AuthenticationFilter extends FilterBase<AuthenticationProvider>
 {
 
     private static Logger log = LoggerFactory.getLogger( AuthenticationFilter.class );
 
-    public static final String FilterNAME = "authenticationFilter";
+    private static final String FilterNAME = "authenticationFilter";
 
-    public static final String ATTR = AuthenticationFilter.class.getName() + "Attr";
+    private static final String ATTR = AuthenticationFilter.class.getName() + "Attr";
 
     private static final Map<String, Class> schemeRegistry = new HashMap<String, Class>();
 
@@ -59,33 +57,30 @@
         schemeRegistry.put( "digest", DigestAuthentication.class );
     }
 
-    /**
-     * Backend provider.
-     */
+    /** Backend provider. */
     private AuthenticationProvider provider;
 
     /** Different authentication schemes implementation */
     private AuthenticationScheme scheme = null;
 
+	public static String getAttrName()
+	{
+		return ATTR;
+	}
+
     /**
      * Construct a new AuthenticationFilter. Looks at the configuration to load
      * the choseen backend implementation.
      */
-    public AuthenticationFilter( String className, String schemeName,
-            List<Element> configElements )
+    public AuthenticationFilter()
     {
-        super( FilterNAME, className, "authentication" );
-
-        this.provider = (AuthenticationProvider) loadConfigInitProvider( className,
-                AuthenticationProvider.class, configElements );
-
         // Validate the choosen authentication scheme
+        String schemeName = Config.filtersAuthenticationScheme.getValue();
         Class schemeClass = schemeRegistry.get( schemeName.toLowerCase() );
         if ( schemeClass == null ) {
             // scheme not found
-            log.error( "Authentication Scheme not found: " + schemeName
-                    + ". Valid values are: "
-                    + Arrays.toString( schemeRegistry.keySet().toArray() ) );
+            log.error( "Authentication Scheme not found: {}. Valid values are: {}",
+                    schemeName, schemeRegistry.keySet() );
             Reactor.stop();
             return;
         }
@@ -94,85 +89,129 @@
         try {
             scheme = (AuthenticationScheme) schemeClass.newInstance();
         } catch ( Exception e ) {
+            log.error( "Error instanciating class: {}", schemeClass );
         }
+    }
 
-        log.info( "Using AuthenticationFilter " + scheme.getName() + " (" + className
-                + ")" );
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getName()
+     */
+    @Override
+    public String getName()
+    {
+        return FilterNAME;
     }
 
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getProviderClassName()
+     */
     @Override
-    public void messageReceived( final NextFilter nextFilter, final IoSession session,
-            final Object message ) throws Exception
+    public String getProviderClassName()
     {
+        return Config.filtersAuthenticationImplClass.getValue();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getProviderInterface()
+     */
+    @Override
+    protected Class<AuthenticationProvider> getProviderInterface()
+    {
+        return AuthenticationProvider.class;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#setProvider(rtspproxy.filter.GenericProvider)
+     */
+    @Override
+    protected void setProvider( AuthenticationProvider provider )
+    {
+        this.provider = provider;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#messageReceived(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession, java.lang.Object)
+     */
+    @Override
+    public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
         if ( !(message instanceof RtspRequest) ) {
             // Shouldn't happen
-            log.warn( "Object message is not a RTSP message" );
+            log.warn( "Object message is not a RTSP request" );
             return;
         }
 
-        if ( isRunning() ) {
-            if ( session.getAttribute( ATTR ) != null ) {
-                // Client already autheticated
-                log.debug( "Already authenticaed: {}", session.getAttribute( ATTR ) );
-                nextFilter.messageReceived( session, message );
-            }
+        if ( session.getAttribute( ATTR ) != null ) {
+            // Client already autheticated
+            log.debug( "Already authenticaed: {}", session.getAttribute( ATTR ) );
+            nextFilter.messageReceived( session, message );
+        }
 
-            final String authString = ((RtspMessage) message)
-                    .getHeader( "Proxy-Authorization" );
-            if ( authString == null ) {
-                log.debug( "RTSP message: \n{}", message );
-                final RtspResponse response = RtspResponse
-                        .errorResponse( RtspCode.ProxyAuthenticationRequired );
-                
-                response.setHeader( "Proxy-Authenticate", scheme.getName() + " "
-                        + scheme.getChallenge() );
+        String authString = ((RtspMessage) message).getHeader( "Proxy-Authorization" );
 
-                log.debug( "Sending RTSP message: \n{}", response );
+        if ( authString == null ) {
+            log.debug( "RTSP message: \n{}", message );
+            final RtspResponse response = RtspResponse
+                    .errorResponse( RtspCode.ProxyAuthenticationRequired );
 
-                session.write( response );
-                return;
-            }
+            response.setHeader( "Proxy-Authenticate", scheme.getName() + " "
+                    + scheme.getChallenge() );
 
-            if ( !validateAuthenticationScheme( authString ) ) {
-                final RtspResponse response = RtspResponse
-                        .errorResponse( RtspCode.BadRequest );
+            log.debug( "Client MUST athenticate to Proxy: \n{}", response );
+            session.write( response );
+            return;
+        }
 
-                session.write( response );
-                return;
-            }
+        if ( !validateAuthenticationScheme( authString ) ) {
+            log.debug( "Authentication scheme not valid: {}", authString );
+            RtspResponse response = RtspResponse.errorResponse( RtspCode.BadRequest );
+            session.write( response );
+            return;
+        }
 
-            log.debug( "RTSP message: \n{}", message );
+        log.debug( "RTSP message: \n{}", message );
 
-            // Check the authentication credentials
-            final Credentials credentials = scheme.getCredentials( (RtspMessage) message );
+        // Check the authentication credentials
+        final Credentials credentials = scheme.getCredentials( (RtspMessage) message );
 
-            boolean authenticationOk = false;
-            if ( credentials != null ) {
-                final String password = provider.getPassword( credentials.getUserName() );
-                if ( password != null )
-                    if ( scheme.computeAuthentication( credentials, password ) == true )
-                        authenticationOk = true;
+        boolean authenticationOk = false;
+        if ( credentials != null ) {
+            String password = provider.getPassword( credentials.getUserName() );
+            if ( password != null && scheme.computeAuthentication( credentials, password ) ) {
+                authenticationOk = true;
             }
+        }
 
-            if ( !authenticationOk ) {
-                log.warn( "Authentication failed for user: {}", credentials );
-                final RtspResponse response = RtspResponse
-                        .errorResponse( RtspCode.ProxyAuthenticationRequired );
-                response.setHeader( "Proxy-Authenticate", scheme.getName() + " "
-                        + scheme.getChallenge() );
+        if ( !authenticationOk ) {
+            log.info( "Authentication failed for user: {}", credentials );
+            RtspResponse response = RtspResponse
+                    .errorResponse( RtspCode.ProxyAuthenticationRequired );
+            response.setHeader( "Proxy-Authenticate", scheme.getName() + " "
+                    + scheme.getChallenge() );
 
-                session.write( response );
-                return;
-            }
+            session.write( response );
+            return;
+        }
 
-            log.debug( "Authentication succesfull for user: {}", credentials );
+        log.debug( "Authentication successfull for user: {}", credentials );
 
-            /*
-             * Mark the session with an "authenticated" attribute. This will
-             * prevent the check for the credentials for every message received.
-             */
-            session.setAttribute( ATTR, credentials.getUserName() );
-        }
+        /*
+         * Mark the session with an "authenticated" attribute. This will prevent
+         * the check for the credentials for every message received.
+         */
+        session.setAttribute( ATTR, credentials.getUserName() );
 
         // Forward message
         nextFilter.messageReceived( session, message );
@@ -182,7 +221,7 @@
      * Gets the authentication scheme stated by the client.
      * 
      * @param authString
-     * @return
+     * @return true if the authentication scheme selected is valid
      */
     private boolean validateAuthenticationScheme( String authString )
     {

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/authentication/scheme/BasicAuthentication.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -36,8 +36,10 @@
 
 	private static Logger log = LoggerFactory.getLogger( BasicAuthentication.class );
 
-	private String realm;
+	private static final String NAME = "Basic";
 
+	private final String realm;
+
 	public BasicAuthentication()
 	{
 		// Initiazialize the realm string
@@ -47,7 +49,7 @@
 
 	public String getName()
 	{
-		return "Basic";
+		return NAME;
 	}
 
 	public Credentials getCredentials( RtspMessage message )

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ClientControlFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,67 +0,0 @@
-/**
- * 
- */
-package rtspproxy.filter.control;
-
-import java.util.List;
-
-import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import rtspproxy.rtsp.RtspRequest;
-import rtspproxy.rtsp.RtspResponse;
-
-/**
- * control filter to be applied on the client side.
- * 
- * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
- */
-public class ClientControlFilter extends ControlFilter {
-
-	private static Logger log = LoggerFactory.getLogger(ClientControlFilter.class);
-
-	/**
-	 * @param className
-	 * @param configElements
-	 * @param typeName
-	 */
-	public ClientControlFilter(String className, List<Element> configElements) {
-		super(className, configElements, "clientControl");
-	}
-
-	@Override
-	public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( provider != null && isRunning()) {
-			if ( message instanceof RtspRequest )
-				provider.processRequest(session, (RtspRequest)message);
-			else
-				log.error( "Expecting a RtspRequest. Received a "
-						+ message.getClass().getName() );
-		}
-
-		// Forward message
-		nextFilter.messageReceived( session, message );
-	}
-
-	@Override
-	public void messageSent( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if ( provider != null  && isRunning()) {
-			if(message instanceof RtspResponse)
-				provider.processResponse(session, (RtspResponse)message);
-			else
-				log.error( "Expecting a RtspResponse. Received a "
-						+ message.getClass().getName() );
-		}
-		
-		// Forward message
-		nextFilter.messageSent( session, message );
-	}
-
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -5,52 +5,98 @@
 
 import java.util.List;
 
+import org.apache.commons.configuration.Configuration;
 import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import rtspproxy.filter.FilterBase;
+import rtspproxy.lib.Side;
+import rtspproxy.rtsp.RtspRequest;
+import rtspproxy.rtsp.RtspResponse;
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public class ControlFilter extends FilterBase 
-{	
-	public static final String FilterNAME = "controlFilter";
+public class ControlFilter extends FilterBase<ControlProvider>
+{
 
-	protected ControlProvider provider;
-	
-	/**
-	 * @param filterName
-	 * @param className
-	 * @param typeName
-	 */
-	protected ControlFilter(String className, List<Element> configElements, String typeName) {
-		super(FilterNAME, className, typeName);
-		
-		this.provider = (ControlProvider)loadConfigInitProvider(className, ControlProvider.class, configElements);
-	}
+    private static Logger log = LoggerFactory.getLogger( ControlFilter.class );
 
-	/* (non-Javadoc)
-	 * @see org.apache.mina.common.IoFilterAdapter#sessionClosed(org.apache.mina.common.IoFilter.NextFilter, org.apache.mina.common.IoSession)
-	 */
-	@Override
-	public void sessionClosed(NextFilter nextFilter, IoSession session) throws Exception {
-		if ( provider != null  && isRunning())
-			provider.sessionClosed( session );
+    public static final String FilterNAME = "controlFilter";
 
-		nextFilter.sessionClosed(session);
-	}
+    private List<ControlProvider> providers;
 
-	/* (non-Javadoc)
-	 * @see org.apache.mina.common.IoFilterAdapter#sessionOpened(org.apache.mina.common.IoFilter.NextFilter, org.apache.mina.common.IoSession)
-	 */
-	@Override
-	public void sessionOpened(NextFilter nextFilter, IoSession session) throws Exception {
-		if ( provider != null && isRunning() )
-			provider.sessionOpened( session );
+    private Side side = Side.Client;
 
-		nextFilter.sessionOpened(session);
-	}
+    @Override
+    public String getName()
+    {
+        return FilterNAME;
+    }
 
+    public ControlFilter( Side side )
+    {
+        this.side = side;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#sessionClosed(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession)
+     */
+    @Override
+    public void sessionClosed( NextFilter nextFilter, IoSession session )
+            throws Exception
+    {
+        for ( ControlProvider provider : providers )
+            provider.sessionClosed( session );
+
+        nextFilter.sessionClosed( session );
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#sessionOpened(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession)
+     */
+    @Override
+    public void sessionOpened( NextFilter nextFilter, IoSession session )
+            throws Exception
+    {
+        for ( ControlProvider provider : providers )
+            provider.sessionOpened( session );
+
+        nextFilter.sessionOpened( session );
+    }
+
+    @Override
+    public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+        if ( message instanceof RtspRequest ) {
+            for ( ControlProvider provider : providers )
+                provider.receivedRequest( session, (RtspRequest) message );
+        } else if ( message instanceof RtspResponse ) {
+            for ( ControlProvider provider : providers )
+                provider.receivedResponse( session, (RtspResponse) message );
+        } else {
+            log.error( "Expecting a RtspRequest. Received a {}", message.getClass()
+                    .getName() );
+        }
+
+        // Forward message
+        nextFilter.messageReceived( session, message );
+    }
+
+    @Override
+    public void doConfigure( Configuration configuration )
+    {
+        log.debug( "Configuring control filter." );
+        // TODO: implement it!
+    }
+
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlFilter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProvider.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProvider.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProvider.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -26,20 +26,25 @@
 	/**
 	 * process a request
 	 */
-	public void processRequest(IoSession session, RtspRequest request);
+	public void receivedRequest( IoSession session, RtspRequest request );
+
+	public void sendRequest( IoSession session, RtspRequest request );
 	
 	/**
 	 * process a response
 	 */
-	public void processResponse(IoSession session, RtspResponse response);
+	public void receivedResponse( IoSession session, RtspResponse response );
+
+	public void sendResponse( IoSession session, RtspResponse response );
 	
 	/**
 	 * session gets opened
 	 */
-	public void sessionOpened(IoSession session);
+	public void sessionOpened( IoSession session );
 	
 	/**
 	 * session gets closed
 	 */
-	public void sessionClosed(IoSession session);
+	public void sessionClosed( IoSession session );
+	
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProvider.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProviderAdapter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProviderAdapter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProviderAdapter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -9,60 +9,69 @@
 import rtspproxy.rtsp.RtspResponse;
 
 /**
- * Default implementation of the ControlProvider interface. All method bodies are empty and
- * do nothing. 
+ * Default implementation of the ControlProvider interface. All method bodies
+ * are empty and do nothing.
  * 
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * 
  */
-public class ControlProviderAdapter implements ControlProvider {
+public abstract class ControlProviderAdapter implements ControlProvider
+{
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.control.ControlProvider#processRequest(org.apache.mina.common.IoSession, rtspproxy.rtsp.RtspRequest)
-	 */
-	public void processRequest(IoSession session, RtspRequest request) {
-		// TODO Auto-generated method stub
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.control.ControlProvider#processRequest(org.apache.mina.common.IoSession,
+     *      rtspproxy.rtsp.RtspRequest)
+     */
+    public void processRequest( IoSession session, RtspRequest request )
+    {
+    }
 
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.control.ControlProvider#processResponse(org.apache.mina.common.IoSession,
+     *      rtspproxy.rtsp.RtspResponse)
+     */
+    public void processResponse( IoSession session, RtspResponse response )
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.control.ControlProvider#processResponse(org.apache.mina.common.IoSession, rtspproxy.rtsp.RtspResponse)
-	 */
-	public void processResponse(IoSession session, RtspResponse response) {
-		// TODO Auto-generated method stub
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.control.ControlProvider#sessionOpened(org.apache.mina.common.IoSession)
+     */
+    public void sessionOpened( IoSession session )
+    {
+    }
 
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.control.ControlProvider#sessionClosed(org.apache.mina.common.IoSession)
+     */
+    public void sessionClosed( IoSession session )
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.control.ControlProvider#sessionOpened(org.apache.mina.common.IoSession)
-	 */
-	public void sessionOpened(IoSession session) {
-		// TODO Auto-generated method stub
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#init()
+     */
+    public void start() throws Exception
+    {
+    }
 
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.GenericProvider#shutdown()
+     */
+    public void stop()
+    {
+    }
 
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.control.ControlProvider#sessionClosed(org.apache.mina.common.IoSession)
-	 */
-	public void sessionClosed(IoSession session) {
-		// TODO Auto-generated method stub
-
-	}
-
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.GenericProvider#init()
-	 */
-	public void init() throws Exception {
-		// TODO Auto-generated method stub
-
-	}
-
-	/* (non-Javadoc)
-	 * @see rtspproxy.filter.GenericProvider#shutdown()
-	 */
-	public void shutdown() {
-		// TODO Auto-generated method stub
-
-	}
-
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ControlProviderAdapter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/control/ServerControlFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,67 +0,0 @@
-/**
- * 
- */
-package rtspproxy.filter.control;
-
-import java.util.List;
-
-import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import rtspproxy.rtsp.RtspRequest;
-import rtspproxy.rtsp.RtspResponse;
-
-/**
- * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- * 
- */
-public class ServerControlFilter extends ControlFilter
-{
-
-    private static Logger log = LoggerFactory.getLogger( ClientControlFilter.class );
-
-    /**
-     * @param className
-     * @param configElements
-     * @param typeName
-     */
-    public ServerControlFilter( String className, List<Element> configElements )
-    {
-        super( className, configElements, "serverControl" );
-    }
-
-    @Override
-    public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
-            throws Exception
-    {
-        if ( provider != null && isRunning() ) {
-            if ( message instanceof RtspResponse )
-                provider.processResponse( session, (RtspResponse) message );
-            else
-                log.error( "Expecting a RtspResponse. Received a {}", message.getClass()
-                        .getName() );
-        }
-
-        // Forward message
-        nextFilter.messageReceived( session, message );
-    }
-
-    @Override
-    public void messageSent( NextFilter nextFilter, IoSession session, Object message )
-            throws Exception
-    {
-        if ( provider != null && isRunning() ) {
-            if ( message instanceof RtspRequest )
-                provider.processRequest( session, (RtspRequest) message );
-            else
-                log.error( "Expecting a Rtsprequest. Received a {}",
-                        message.getClass().getName() );
-        }
-
-        // Forward message
-        nextFilter.messageSent( session, message );
-    }
-
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress/IpAddressFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress/IpAddressFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress/IpAddressFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -19,69 +19,126 @@
 package rtspproxy.filter.ipaddress;
 
 import java.net.InetSocketAddress;
-import java.util.List;
 
 import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import rtspproxy.config.Config;
 import rtspproxy.filter.FilterBase;
+import rtspproxy.lib.Side;
 
 /**
  * @author Matteo Merli
- *
+ * 
  */
-public class IpAddressFilter extends FilterBase
+public class IpAddressFilter extends FilterBase<IpAddressProvider>
 {
 
-	private static Logger log = LoggerFactory.getLogger( IpAddressFilter.class );
-	
-	public static final String FilterNAME = "ipAddressFilter";
+    private static Logger log = LoggerFactory.getLogger( IpAddressFilter.class );
 
-	private IpAddressProvider provider;
+    private static final String FilterNAME = "ipAddressFilter";
 
-	public IpAddressFilter(String className, List<Element> configElements)
-	{
-		super(FilterNAME, className, "ipaddress");
-		
-		this.provider = (IpAddressProvider)loadConfigInitProvider(className, IpAddressProvider.class,
-				configElements);
-	}
+    private IpAddressProvider provider = null;
 
-	@Override
-	public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
-			throws Exception
-	{
-		if(!isRunning()) {
-			// forward because filter is suspended
-			nextFilter.messageReceived( session, message );			
-		} else if ( !provider.isBlocked( ( (InetSocketAddress) session.getRemoteAddress() ).getAddress() ) ) {
-			// forward if not blocked
-			nextFilter.messageReceived( session, message );
-		} else {
-			blockSession( session );
-		}
-	}
+    private Side side = Side.Client;
 
-	@Override
-	public void sessionCreated( NextFilter nextFilter, IoSession session )
-			throws Exception
-	{
-		if(!isRunning()) {
-			// forward because filter is suspended
-			nextFilter.sessionCreated( session );
-		} else if ( !provider.isBlocked( ( (InetSocketAddress) session.getRemoteAddress() ).getAddress() ) ) {
-			// forward if not blocked
-			nextFilter.sessionCreated( session );
-		} else {
-			blockSession( session );
-		}
-	}
+    public IpAddressFilter( Side side )
+    {
+	this.side = side;
+    }
 
-	protected void blockSession( IoSession session )
-	{
-		log.info( "Blocked connection from : " + session.getRemoteAddress() );
-		session.close();
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getName()
+     */
+    @Override
+    public String getName()
+    {
+        return FilterNAME;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getProviderClassName()
+     */
+    @Override
+    public String getProviderClassName()
+    {
+        return Config.filtersIpAddressImplClass.getValue();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getProviderInterface()
+     */
+    @Override
+    protected Class<IpAddressProvider> getProviderInterface()
+    {
+        return IpAddressProvider.class;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#setProvider(rtspproxy.filter.GenericProvider)
+     */
+    @Override
+    protected void setProvider( IpAddressProvider provider )
+    {
+        this.provider = provider;
+	this.provider.setSide( side );
+    }
+
+    @Override
+    public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+	log.debug( "Testing address: {}", session.getRemoteAddress() );
+
+        if ( !isRunning() ) {
+            // forward because filter is suspended
+            nextFilter.messageReceived( session, message );
+
+        } else if ( !provider.isBlocked( ((InetSocketAddress) session.getRemoteAddress())
+                .getAddress() ) ) {
+            // forward if not blocked
+            nextFilter.messageReceived( session, message );
+
+        } else {
+            blockSession( session );
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.mina.common.IoFilterAdapter#sessionCreated(org.apache.mina.common.IoFilter.NextFilter,
+     *      org.apache.mina.common.IoSession)
+     */
+    @Override
+    public void sessionCreated( NextFilter nextFilter, IoSession session )
+            throws Exception
+    {
+        if ( !isRunning() ) {
+            // forward because filter is suspended
+            nextFilter.sessionCreated( session );
+            
+        } else if ( !provider.isBlocked( ((InetSocketAddress) session.getRemoteAddress())
+                .getAddress() ) ) {
+            // forward if not blocked
+            nextFilter.sessionCreated( session );
+        } else {
+            blockSession( session );
+        }
+    }
+
+    protected void blockSession( IoSession session )
+    {
+        log.info( "Blocked connection from : {}", session.getRemoteAddress() );
+        session.close();
+    }
 }

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress/IpAddressProvider.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress/IpAddressProvider.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/ipaddress/IpAddressProvider.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -21,12 +21,15 @@
 import java.net.InetAddress;
 
 import rtspproxy.filter.GenericProvider;
+import rtspproxy.lib.Side;
 
 /**
  * @author Matteo Merli
  */
 public interface IpAddressProvider extends GenericProvider
 {
+    
+    public void setSide( Side side );
 
 	public boolean isBlocked( InetAddress address );
 	

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ClientUrlRewritingFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,64 +0,0 @@
-/**
- * 
- */
-package rtspproxy.filter.rewrite;
-
-import java.util.List;
-
-import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import rtspproxy.rtsp.RtspMessage;
-import rtspproxy.rtsp.RtspRequest;
-
-/**
- * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
- */
-public class ClientUrlRewritingFilter extends UrlRewritingFilter {
-
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory.getLogger(ClientUrlRewritingFilter.class);
-
-	public ClientUrlRewritingFilter(String className, List<Element> configElements) throws Exception {
-		super(className, configElements);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.mina.common.IoFilterAdapter#messageReceived(org.apache.mina.common.IoFilter.NextFilter,
-	 *      org.apache.mina.common.IoSession, java.lang.Object)
-	 */
-	@Override
-	public void messageReceived(NextFilter nextFilter, IoSession session,
-			Object message) throws Exception {
-		boolean passOn = true;
-		
-		logger.debug("Received (pre-rewriting) message:\n" + message);
-
-		if (isRunning()) {
-			if (message instanceof RtspMessage) {
-				RtspMessage rtspMessage = (RtspMessage) message;
-
-				if (rtspMessage.getType() == RtspMessage.Type.TypeRequest)
-					passOn = processRequest(session, (RtspRequest)rtspMessage);
-			} else {
-					logger.error("Expecting a RtspMessage. Received a "
-						+ message.getClass().getName());
-			}
-
-		}
-		if(passOn) {
-			logger.debug("Sent (post-rewriting) message:\n" + message);
-
-			nextFilter.messageReceived(session, message);
-		}
-	}
-
-
-}

Deleted: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/ServerUrlRewritingFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,61 +0,0 @@
-/**
- * 
- */
-package rtspproxy.filter.rewrite;
-
-import java.util.List;
-
-import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import rtspproxy.rtsp.RtspMessage;
-import rtspproxy.rtsp.RtspResponse;
-
-/**
- * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
- */
-public class ServerUrlRewritingFilter extends UrlRewritingFilter {
-
-	/**
-	 * Logger for this class
-	 */
-	private static final Logger logger = LoggerFactory.getLogger(ServerUrlRewritingFilter.class);
-
-	/**
-	 * 
-	 */
-	public ServerUrlRewritingFilter(String className, List<Element> configElements) throws Exception {
-		super(className, configElements);
-	}
-	
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.mina.common.IoFilterAdapter#messageReceived(org.apache.mina.common.IoFilter.NextFilter,
-	 *      org.apache.mina.common.IoSession, java.lang.Object)
-	 */
-	@Override
-	public void messageReceived(NextFilter nextFilter, IoSession session,
-			Object message) throws Exception {
-		logger.debug("Received (pre-rewriting) message:\n" + message);
-
-		if (isRunning()) {
-			if (message instanceof RtspMessage) {
-				RtspMessage rtspMessage = (RtspMessage) message;
-
-				if (rtspMessage.getType() == RtspMessage.Type.TypeResponse)
-					processResponse((RtspResponse) rtspMessage);
-			} else {
-					logger.error("Expecting a RtspMessage. Received a "
-						+ message.getClass().getName());
-			}
-			logger.debug("Sent (post-rewriting) message:\n" + message);
-
-		}
-		nextFilter.messageReceived(session, message);
-	}
-
-}

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -6,20 +6,22 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.HashMap;
-import java.util.List;
+import java.util.Map;
 
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
 import org.apache.mina.common.IoSession;
-import org.dom4j.Element;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import rtspproxy.config.Config;
 import rtspproxy.filter.FilterBase;
 import rtspproxy.jmx.JmxManageable;
 import rtspproxy.jmx.JmxManageable2;
+import rtspproxy.lib.Side;
 import rtspproxy.proxy.ProxyHandler;
+import rtspproxy.rtsp.RtspMessage;
 import rtspproxy.rtsp.RtspRequest;
 import rtspproxy.rtsp.RtspResponse;
 
@@ -27,43 +29,81 @@
  * @author bieniekr
  * 
  */
-public abstract class UrlRewritingFilter extends FilterBase implements JmxManageable
+public class UrlRewritingFilter extends FilterBase<UrlRewritingProvider>
 {
 
-    /**
-     * Logger for this class
-     */
+    /** Logger for this class */
     private static Logger log = LoggerFactory.getLogger( UrlRewritingFilter.class );
 
-    public static final String FilterNAME = "rewriting";
+    private static final String FilterNAME = "rewriting";
 
-    // the filter instance
-    protected UrlRewritingProvider provider;
+    /** the filter backend instance */
+    private UrlRewritingProvider provider;
 
     // list of exposed session attributes
     private String[] exposedAttributes;
 
+    private Side side;
+
     /**
      * construct the IoFilter around the filter class denoted by the clazz name
      * parameter.
      */
-    public UrlRewritingFilter( String className, List<Element> configElements )
-            throws Exception
+    public UrlRewritingFilter( Side side )
     {
-        super( FilterNAME, className, "rewriting" );
+        this.side = side;
+        // this.exposedAttributes = this.provider.getWantedSessionAttributes();
+        // if ( this.exposedAttributes == null )
+        this.exposedAttributes = new String[0];
+    }
 
-        this.provider = (UrlRewritingProvider) loadConfigInitProvider( className,
-                UrlRewritingProvider.class, configElements );
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getName()
+     */
+    @Override
+    public String getName()
+    {
+        return FilterNAME;
+    }
 
-        this.exposedAttributes = this.provider.getWantedSessionAttributes();
-        if ( this.exposedAttributes == null )
-            this.exposedAttributes = new String[0];
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#setProvider(rtspproxy.filter.GenericProvider)
+     */
+    @Override
+    public void setProvider( UrlRewritingProvider provider )
+    {
+        this.provider = provider;
+        exposedAttributes = provider.getWantedSessionAttributes();
+        if ( exposedAttributes == null )
+            exposedAttributes = new String[0];
     }
 
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getProviderInterface()
+     */
     @Override
-    public abstract void messageReceived( NextFilter nextFilter, IoSession session,
-            Object message ) throws Exception;
+    public Class<UrlRewritingProvider> getProviderInterface()
+    {
+        return UrlRewritingProvider.class;
+    }
 
+    /*
+     * (non-Javadoc)
+     * 
+     * @see rtspproxy.filter.FilterBase#getProviderClassName()
+     */
+    @Override
+    public String getProviderClassName()
+    {
+        return Config.filtersRewriteImplClass.getValue();
+    }
+
     /**
      * process a request message
      * 
@@ -75,7 +115,7 @@
         boolean passOn = true;
 
         if ( req.getUrl() != null ) {
-            HashMap<String, Object> exposedSessionAttributes = new HashMap<String, Object>();
+            Map<String, Object> exposedSessionAttributes = new HashMap<String, Object>();
 
             for ( String attr : this.exposedAttributes ) {
                 log.debug( "exposing session attribute: {}", attr );
@@ -141,6 +181,39 @@
         }
     }
 
+    @Override
+    public void messageReceived( NextFilter nextFilter, IoSession session, Object message )
+            throws Exception
+    {
+        boolean passOn = true;
+
+        log.debug( "Received (pre-rewriting) message:\n{}", message );
+
+        if ( isRunning() ) {
+            if ( message instanceof RtspMessage ) {
+                RtspMessage rtspMessage = (RtspMessage) message;
+
+                if ( side == Side.Client
+                        && rtspMessage.getType() == RtspMessage.Type.TypeRequest )
+                    passOn = processRequest( session, (RtspRequest) rtspMessage );
+
+                else if ( side == Side.Server
+                        && rtspMessage.getType() == RtspMessage.Type.TypeResponse )
+                    processResponse( (RtspResponse) rtspMessage );
+
+            } else {
+                log.error( "Expecting a RtspMessage. Received a {}", //
+                        message.getClass().getName() );
+            }
+
+        }
+
+        if ( passOn ) {
+            log.debug( "Sent (post-rewriting) message:\n{}", message );
+            nextFilter.messageReceived( session, message );
+        }
+    }
+
     /**
      * rewrite a header
      */


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingFilter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingProvider.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingProvider.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingProvider.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -10,9 +10,9 @@
  ***************************************************************************/
 
 /*
- * $Id: Handler.java 248 2005-10-23 18:47:41Z merlimat $
+ * $Id$
  * 
- * $URL: https://rbieniek at svn.berlios.de/svnroot/repos/rtspproxy/trunk/src/main/java/rtspproxy/rtsp/Handler.java $
+ * $URL$
  * 
  */
 package rtspproxy.filter.rewrite;
@@ -25,28 +25,35 @@
 import rtspproxy.rtsp.RtspRequest;
 
 /**
- * This filter is used to rewrite the requested URL before passing it
- * to the upstream server.
+ * This filter is used to rewrite the requested URL before passing it to the
+ * upstream server.
  * 
  * @author Rainer Bieniek
  */
-public interface UrlRewritingProvider extends GenericProvider {
-	/**
-	 * rewrite the request URL.
-	 * @return a result object which can contain a modified result URL or a response message
-	 * sent back to the client. If null is returned, the URL is passed on without modification.
-	 */
-	public UrlRewritingResult rewriteRequestUrl(URL request, RtspRequest.Verb verb, SocketAddress client,
-			Map<String, String> requestHeaders, Map<String, Object> sessionAttributes);
+public interface UrlRewritingProvider extends GenericProvider
+{
 
-	/**
-	 * rewrite an URL in a response header.
-	 * @return a replacement URL or null if the URL is not to be modified.
-	 */
-	public URL rewriteResponseHeaderUrl(URL request);
-	
-	/**
-	 * get a list of session attributes the filter wants to get exposed from the session
-	 */
-	public String[] getWantedSessionAttributes();
+    /**
+     * rewrite the request URL.
+     * 
+     * @return a result object which can contain a modified result URL or a
+     *         response message sent back to the client. If null is returned,
+     *         the URL is passed on without modification.
+     */
+    public UrlRewritingResult rewriteRequestUrl( URL request, RtspRequest.Verb verb,
+            SocketAddress client, Map<String, String> requestHeaders,
+            Map<String, Object> sessionAttributes );
+
+    /**
+     * rewrite an URL in a response header.
+     * 
+     * @return a replacement URL or null if the URL is not to be modified.
+     */
+    public URL rewriteResponseHeaderUrl( URL request );
+
+    /**
+     * get a list of session attributes the filter wants to get exposed from the
+     * session
+     */
+    public String[] getWantedSessionAttributes();
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingProvider.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/rewrite/UrlRewritingResult.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionClientTrackingFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -24,14 +24,6 @@
 	// session attribute
 	private static final String SessionAttribute = "lastSetupURL";
 
-	/**
-	 * @param filterName
-	 * @param typeName
-	 */
-	public RdtSessionClientTrackingFilter() {
-		super("client");
-	}
-
 	/*
 	 * (non-Javadoc)
 	 * 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/filter/tracking/RdtSessionTrackingFilter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -9,6 +9,7 @@
 
 import rtspproxy.config.Config;
 import rtspproxy.filter.FilterBase;
+import rtspproxy.filter.GenericProvider;
 import rtspproxy.rtsp.RtspRequest;
 import rtspproxy.rtsp.RtspResponse;
 import rtspproxy.rtsp.RtspTransport;
@@ -16,7 +17,7 @@
 
 /**
  * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
- *
+ * TODO: to be implemented
  */
 public abstract class RdtSessionTrackingFilter extends FilterBase {
 	
@@ -24,15 +25,27 @@
 
 	public static final String FilterNAME = "rdtTrackingFilter";
 
-	/**
-	 * @param filterName
-	 * @param className
-	 * @param typeName
-	 */
-	public RdtSessionTrackingFilter(String typeName) {
-		super(FilterNAME, typeName);
-	}
+	public String getName()
+        {
+                return FilterNAME;
+        }
 
+        public void setProvider( GenericProvider provider )
+        {
+              	// XXX
+        }
+
+        public Class getProviderInterface()
+        {
+                return null;
+        }
+
+        public String getProviderClassName()
+        {
+                // TODO: to be implemented
+                return ""; // Config.filtersImplClass.getValue();
+        }
+
 	/**
 	 * check the message for following conditions
 	 */

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxAgent.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -68,340 +68,310 @@
 public class JmxAgent extends Singleton
 {
 
-	private static Logger log = LoggerFactory.getLogger( JmxAgent.class );
+    private static Logger log = LoggerFactory.getLogger( JmxAgent.class );
 
-	public static final String DOMAIN = "RtspProxy";
-	public static final String SERVICES_DOMAIN = "RtspProxy.Services";
-	public static final String FILTERS_DOMAIN = "RtspProxy.Filters";
-	public static final String RTSP_SESSION_DOMAIN = "RtspProxy.Sessions.RTSP";
-	public static final String PROXY_SESSION_DOMAIN = "RtspProxy.Sessions.Proxy";
-	public static final String RTP_DYNAMIC_SESSION_DOMAIN = "RtspProxy.Sessions.RTP.dynamic";
+    public static final String DOMAIN = "RtspProxy";
 
-	private MBeanServer mbeanServer = null;
+    public static final String SERVICES_DOMAIN = "RtspProxy.Services";
 
-	/**
-	 * Creates a MBean server and attach all the MBeans to it. Also starts, if
-	 * needed, the web console and the JMX connector server.
-	 */
-	public JmxAgent()
-	{
-		// Silent mx4j info messages
-		System.setProperty( "mx4j.log.priority", "warn" );
+    public static final String FILTERS_DOMAIN = "RtspProxy.Filters";
 
-		// Redirect mx4j messages to our own logger
-		Log.redirectTo( new Slf4JLogger() );
+    public static final String RTSP_SESSION_DOMAIN = "RtspProxy.Sessions.RTSP";
 
-		mbeanServer = MBeanServerFactory.createMBeanServer();
+    public static final String PROXY_SESSION_DOMAIN = "RtspProxy.Sessions.Proxy";
 
-		try {
+    public static final String RTP_DYNAMIC_SESSION_DOMAIN = "RtspProxy.Sessions.RTP.dynamic";
 
-			// Basic Info
-			Object infoMBean = new Info();
-			ObjectName infoName = ObjectName.getInstance( DOMAIN + ":name=Info" );
-			mbeanServer.registerMBean( infoMBean, infoName );
+    private MBeanServer mbeanServer = null;
 
-			// Parameters
-			Object parametersMBean = mbeanServer.instantiate( ParametersMBean.class.getName() );
-			ObjectName parametersName = ObjectName.getInstance( DOMAIN
-					+ ":name=Parameters" );
-			mbeanServer.registerMBean( parametersMBean, parametersName );
+    /**
+     * Creates a MBean server and attach all the MBeans to it. Also starts, if
+     * needed, the web console and the JMX connector server.
+     */
+    public JmxAgent()
+    {
+        // Silent mx4j info messages
+        System.setProperty( "mx4j.log.priority", "warn" );
 
-			// Proxy Services
-			ProxyService[] proxyServices = { RtspService.getInstance(),
-					RdtClientService.getInstance(), RdtServerService.getInstance(),
-					RtcpClientService.getInstance(), RtcpServerService.getInstance(),
-					RtpClientService.getInstance(), RtpServerService.getInstance() };
-			ObjectName objectName;
-			for ( ProxyService proxyService : proxyServices ) {
-				objectName = ObjectName.getInstance( SERVICES_DOMAIN + ":name="
-						+ proxyService.getName() );
-				mbeanServer.registerMBean( new Service( proxyService ), objectName );
-			}
+        // Redirect mx4j messages to our own logger
+        Log.redirectTo( new Mx4jLoggerWrapper() );
 
-			startWebConsole();
-			startConnectorServer();
+        mbeanServer = MBeanServerFactory.createMBeanServer();
 
-		} catch ( Exception e ) {
-			log.error( "Exception: ", e );
-			Reactor.stop();
-		}
-	}
+        try {
 
-	public void stop()
-	{
-		// TODO: Handle the shutdown of the JMX agent
-	}
+            // Basic Info
+            Object infoMBean = new Info();
+            ObjectName infoName = ObjectName.getInstance( DOMAIN + ":name=Info" );
+            mbeanServer.registerMBean( infoMBean, infoName );
 
-	private void startWebConsole() throws Exception
-	{
-		boolean enabled = Config.jmxWebEnable.getValue();
-		if ( !enabled )
-			return;
+            // Parameters
+            Object parametersMBean = mbeanServer.instantiate( ParametersMBean.class
+                    .getName() );
+            ObjectName parametersName = ObjectName.getInstance( DOMAIN
+                    + ":name=Parameters" );
+            mbeanServer.registerMBean( parametersMBean, parametersName );
 
-		String host = Config.jmxAddress.getValue();
-		int port = Config.jmxWebPort.getValue();
-		String user = Config.jmxUser.getValue();
-		String password = Config.jmxPassword.getValue();
+            // Proxy Services
+            ProxyService[] proxyServices = { RtspService.getInstance(),
+                    RdtClientService.getInstance(), RdtServerService.getInstance(),
+                    RtcpClientService.getInstance(), RtcpServerService.getInstance(),
+                    RtpClientService.getInstance(), RtpServerService.getInstance() };
+            ObjectName objectName;
+            for ( ProxyService proxyService : proxyServices ) {
+                objectName = ObjectName.getInstance( SERVICES_DOMAIN + ":name="
+                        + proxyService.getName() );
+                mbeanServer.registerMBean( new Service( proxyService ), objectName );
+            }
 
-		HttpAdaptor adaptor = new HttpAdaptor();
-		ObjectName name = new ObjectName( "Server:name=HttpAdaptor" );
-		mbeanServer.registerMBean( adaptor, name );
-		adaptor.setHost( host );
-		adaptor.setPort( port );
-		// MX4J HTTP adaptor only supports Basic authentication
-		adaptor.setAuthenticationMethod( "basic" );
-		adaptor.addAuthorization( user, password );
-		adaptor.start();
+            startWebConsole();
+            startConnectorServer();
 
-		XSLTProcessor processor = new XSLTProcessor();
-		processor.setUseCache( true );
-		adaptor.setProcessor( processor );
+        } catch ( Exception e ) {
+            log.error( "Exception: ", e );
+            Reactor.stop();
+        }
+    }
 
-		String url = "http://" + host + ":" + port + "/";
-		log.info( "Started web console. Accepting connections on " + url );
-	}
+    public void stop()
+    {
+        // TODO: Handle the shutdown of the JMX agent
+    }
 
-	@SuppressWarnings("unchecked")
-	private void startConnectorServer() throws Exception
-	{
-		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
-		if ( !enabled )
-			return;
+    private void startWebConsole() throws Exception
+    {
+        boolean enabled = Config.jmxWebEnable.getValue();
+        if ( !enabled )
+            return;
 
-		// Register and start the rmiregistry MBean, needed by JSR 160
-		// RMIConnectorServer
-		ObjectName namingName = ObjectName.getInstance( "naming:type=rmiregistry" );
-		NamingService namingService = new NamingService();
-		mbeanServer.registerMBean( namingService, namingName );
-		namingService.start();
-		int namingPort = ( (Integer) mbeanServer.getAttribute( namingName, "Port" ) ).intValue();
+        String host = Config.jmxAddress.getValue();
+        int port = Config.jmxWebPort.getValue();
+        String user = Config.jmxUser.getValue();
+        String password = Config.jmxPassword.getValue();
 
-		String jndiPath = "/rtspproxy";
-		String host = Config.jmxAddress.getValue();
-		String uri = "service:jmx:rmi://" + host + "/jndi/rmi://" + host + ":"
-				+ namingPort + jndiPath;
+        HttpAdaptor adaptor = new HttpAdaptor();
+        ObjectName name = new ObjectName( "Server:name=HttpAdaptor" );
+        mbeanServer.registerMBean( adaptor, name );
+        adaptor.setHost( host );
+        adaptor.setPort( port );
+        // MX4J HTTP adaptor only supports Basic authentication
+        adaptor.setAuthenticationMethod( "basic" );
+        adaptor.addAuthorization( user, password );
+        adaptor.start();
 
-		JMXServiceURL url = new JMXServiceURL( uri );
+        XSLTProcessor processor = new XSLTProcessor();
+        processor.setUseCache( true );
+        adaptor.setProcessor( processor );
 
-		// Remote Authentication
-		JMXAuthenticator authenticator = new Authenticator();
-		Map<String, JMXAuthenticator> environment = new HashMap<String, JMXAuthenticator>();
-		environment.put( JMXConnectorServer.AUTHENTICATOR, authenticator );
+        String url = "http://" + host + ":" + port + "/";
+        log.info( "Started web console. Accepting connections on {}", url );
+    }
 
-		// Create and start the RMIConnectorServer
-		JMXConnectorServer connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(
-				url, environment, mbeanServer );
-		connectorServer.start();
+    @SuppressWarnings("unchecked")
+    private void startConnectorServer() throws Exception
+    {
+        boolean enabled = Config.jmxConnectorServiceEnable.getValue();
+        if ( !enabled )
+            return;
 
-		log.info( "Started JMX connector server. Service url: " + uri );
-	}
+        // Register and start the rmiregistry MBean, needed by JSR 160
+        // RMIConnectorServer
+        ObjectName namingName = ObjectName.getInstance( "naming:type=rmiregistry" );
+        NamingService namingService = new NamingService();
+        mbeanServer.registerMBean( namingService, namingName );
+        namingService.start();
+        int namingPort = ((Integer) mbeanServer.getAttribute( namingName, "Port" ))
+                .intValue();
 
-	/**
-	 * get the singleton instance
-	 */
-	public static JmxAgent getInstance() {
-		return (JmxAgent)Singleton.getInstance(JmxAgent.class);
-	}
-	
-	/**
-	 * register a MBean as a management facade to a filter implementation
-	 */
-	public void registerFilter(FilterBase filter) {
-		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
-		if ( !enabled )
-			return;
+        String jndiPath = "/rtspproxy";
+        String host = Config.jmxAddress.getValue();
+        String uri = "service:jmx:rmi://" + host + "/jndi/rmi://" + host + ":"
+                + namingPort + jndiPath;
 
-		try {
-			Filter mbean = new Filter(filter);
-			
-			mbeanServer.registerMBean(mbean, mbean.getName());
-			filter.setMbeanName(mbean.getName());
-			if(filter instanceof JmxManageable)
-				((JmxManageable)filter).setMBeanServer(mbeanServer);
-		} catch(Exception e) {
-			log.error( "failed to register filter MBean: filter=" + filter, e );			
-		}
-	}
-	
-	/**
-	 * simple wrapper to log mx4j logging info into slf4j subsystem
-	 * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
-	 *
-	 */
-	public static class Slf4JLogger extends mx4j.log.Logger {
+        JMXServiceURL url = new JMXServiceURL( uri );
 
-		private Logger m_logger;
-		
-		/**
-		 * default no-op constructor
-		 */
-		public Slf4JLogger() {}
-		
-		/* (non-Javadoc)
-		 * @see mx4j.log.Logger#log(int, java.lang.Object, java.lang.Throwable)
-		 */
-		@Override
-		protected void log(int level, Object msg, Throwable t) {
-			switch(level) {
-			case mx4j.log.Logger.DEBUG:
-				this.m_logger.debug(msg.toString(), t);
-				break;
-			case mx4j.log.Logger.ERROR:
-				this.m_logger.error(msg.toString(), t);
-				break;
-			case mx4j.log.Logger.FATAL:
-				this.m_logger.error(msg.toString(), t);
-				break;
-			case mx4j.log.Logger.INFO:
-				this.m_logger.info(msg.toString(), t);
-				break;
-			case mx4j.log.Logger.TRACE:
-				this.m_logger.debug(msg.toString(), t);
-				break;
-			case mx4j.log.Logger.WARN:
-				this.m_logger.warn(msg.toString(), t);
-				break;
-			}
-		}
+        // Remote Authentication
+        JMXAuthenticator authenticator = new Authenticator();
+        Map<String, JMXAuthenticator> environment = new HashMap<String, JMXAuthenticator>();
+        environment.put( JMXConnectorServer.AUTHENTICATOR, authenticator );
 
-		/* (non-Javadoc)
-		 * @see mx4j.log.Logger#setCategory(java.lang.String)
-		 */
-		@Override
-		protected void setCategory(String arg0) {
-			super.setCategory(arg0);
-			
-			this.m_logger = LoggerFactory.getLogger(arg0);
-		}		
-	}
+        // Create and start the RMIConnectorServer
+        JMXConnectorServer connectorServer = JMXConnectorServerFactory
+                .newJMXConnectorServer( url, environment, mbeanServer );
+        connectorServer.start();
 
-	/**
-	 * @return Returns the mbeanServer.
-	 */
-	public MBeanServer getMbeanServer() {
-		return mbeanServer;
-	}
-	
-	/**
-	 * register a proxy session
-	 * 
-	 */
-	public void registerProxySession(ProxySession session) {
-		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
-		if ( !enabled )
-			return;
+        log.info( "Started JMX connector server. Service url: {}", uri );
+    }
 
-		try {
-			ProxySessionFacade mbean = new ProxySessionFacade(session);
-			ObjectName name = mbean.buildName();
-		
-			mbeanServer.registerMBean(mbean, name);
-			session.setObjectName(name);
-		} catch(Exception e) {
-			log.error( "failed to register proxy session MBean: session=" + session, e );
-		}
-	}
-	
-	/**
-	 * unregister a proxy session
-	 */
-	public void unregisterProxySession(ProxySession session) {
-		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
-		if ( !enabled )
-			return;
+    /**
+     * get the singleton instance
+     */
+    public static JmxAgent getInstance()
+    {
+        return (JmxAgent) Singleton.getInstance( JmxAgent.class );
+    }
 
-		try {
-			ObjectName name = session.getObjectName();
-		
-			if(name != null) {
-				mbeanServer.unregisterMBean(name);
-				session.setObjectName(null);
-			}
-		} catch(InstanceNotFoundException infe) {
-			log.debug("internal problem: MBean not found, name={}", session.getObjectName(), infe);
-		} catch(Exception e) {
-			log.error( "failed to register proxy session MBean: session={}", session, e );
-		}
-		
-	}
-	
-	/**
-	 * register a proxy session
-	 * 
-	 */
-	public void registerPortRangeRtpServerSessionfactory(PortrangeRtpServerSessionFactory sessionFactory) {
-		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
-		if ( !enabled )
-			return;
+    /**
+     * register a MBean as a management facade to a filter implementation
+     */
+    public void registerFilter( FilterBase filter )
+    {
+        boolean enabled = Config.jmxConnectorServiceEnable.getValue();
+        if ( !enabled )
+            return;
 
-		try {
-			ObjectName objectName = ObjectName.getInstance( SERVICES_DOMAIN + ":name=PortrangeRtpServerSessionFactory");
-		
-			mbeanServer.registerMBean( new PortrangeRtpServerFactory(sessionFactory), objectName );
-		} catch(Exception e) {
-			log.info("failed to register PortrangeRtpServerFactory MBean", e);
-		}
-	}
-	
-	/**
-	 * register a proxy session
-	 * 
-	 */
-	public void unregisterPortRangeRtpServerSessionfactory() {
-		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
-		if ( !enabled )
-			return;
+        try {
+            Filter mbean = new Filter( filter );
 
-		try {
-			ObjectName objectName = ObjectName.getInstance( SERVICES_DOMAIN + ":name=PortrangeRtpServerSessionFactory");
-		
-			mbeanServer.unregisterMBean(  objectName );
-		} catch(InstanceNotFoundException infe) {
-			log.debug("PortrangeRtpServerFactory MBean not found", infe);
-		} catch(Exception e) {
-			log.info("failed to register PortrangeRtpServerFactory MBean", e);
-		}
-	}
-	
-	/**
-	 * register a generated RTP server session in the portrange case
-	 */
-	public void registerPortrangeRtpServerSession(PortrangeRtpServerSession session) {
-		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
-		if ( !enabled )
-			return;
-		
-		try {
-			PortrangeRtpSession mbean = new PortrangeRtpSession(session);
-			ObjectName name = mbean.buildName();
-		
-			mbeanServer.registerMBean(mbean, name);
-			session.setObjectName(name);
-		} catch(Exception e) {
-			log.error( "failed to register proxy session MBean: session={}", session, e );
-		}
-	}
-	
-	/**
-	 * register a generated RTP server session in the portrange case
-	 */
-	public void unregisterPortrangeRtpServerSession(PortrangeRtpServerSession session) {
-		boolean enabled = Config.jmxConnectorServiceEnable.getValue();
-		if ( !enabled )
-			return;
-		
-		try {
-			ObjectName name = session.getObjectName();
-		
-			if(name != null) {
-				mbeanServer.unregisterMBean(name);
-				session.setObjectName(null);
-			}
-		} catch(InstanceNotFoundException infe) {
-			log.debug("internal problem: MBean not found, name=" + session.getObjectName(), infe);
-		} catch(Exception e) {
-			log.error( "failed to register proxy session MBean: session={}", session, e );
-		}		
-	}
+            mbeanServer.registerMBean( mbean, mbean.getName() );
+            filter.setMbeanName( mbean.getName() );
+            if ( filter instanceof JmxManageable )
+                ((JmxManageable) filter).setMBeanServer( mbeanServer );
+        } catch ( Exception e ) {
+            log.error( "failed to register filter MBean: filter=" + filter, e );
+        }
+    }
 
+    /**
+     * @return Returns the mbeanServer.
+     */
+    public MBeanServer getMbeanServer()
+    {
+        return mbeanServer;
+    }
+
+    /**
+     * register a proxy session
+     * 
+     */
+    public void registerProxySession( ProxySession session )
+    {
+        boolean enabled = Config.jmxEnable.getValue();
+        if ( !enabled )
+            return;
+
+        try {
+            ProxySessionFacade mbean = new ProxySessionFacade( session );
+            ObjectName name = mbean.buildName();
+
+            mbeanServer.registerMBean( mbean, name );
+            session.setObjectName( name );
+        } catch ( Exception e ) {
+            log.error( "failed to register proxy session MBean: session=" + session, e );
+        }
+    }
+
+    /**
+     * unregister a proxy session
+     */
+    public void unregisterProxySession( ProxySession session )
+    {
+        boolean enabled = Config.jmxConnectorServiceEnable.getValue();
+        if ( !enabled )
+            return;
+
+        try {
+            ObjectName name = session.getObjectName();
+
+            if ( name != null ) {
+                mbeanServer.unregisterMBean( name );
+                session.setObjectName( null );
+            }
+        } catch ( InstanceNotFoundException infe ) {
+            log.debug( "internal problem: MBean not found, name={}", session
+                    .getObjectName(), infe );
+        } catch ( Exception e ) {
+            log.error( "failed to register proxy session MBean: session={}", session, e );
+        }
+
+    }
+
+    /**
+     * register a proxy session
+     * 
+     */
+    public void registerPortRangeRtpServerSessionfactory(
+            PortrangeRtpServerSessionFactory sessionFactory )
+    {
+        boolean enabled = Config.jmxConnectorServiceEnable.getValue();
+        if ( !enabled )
+            return;
+
+        try {
+            ObjectName objectName = ObjectName.getInstance( SERVICES_DOMAIN
+                    + ":name=PortrangeRtpServerSessionFactory" );
+
+            mbeanServer.registerMBean( new PortrangeRtpServerFactory( sessionFactory ),
+                    objectName );
+        } catch ( Exception e ) {
+            log.info( "failed to register PortrangeRtpServerFactory MBean", e );
+        }
+    }
+
+    /**
+     * register a proxy session
+     * 
+     */
+    public void unregisterPortRangeRtpServerSessionfactory()
+    {
+        boolean enabled = Config.jmxConnectorServiceEnable.getValue();
+        if ( !enabled )
+            return;
+
+        try {
+            ObjectName objectName = ObjectName.getInstance( SERVICES_DOMAIN
+                    + ":name=PortrangeRtpServerSessionFactory" );
+
+            mbeanServer.unregisterMBean( objectName );
+        } catch ( InstanceNotFoundException infe ) {
+            log.debug( "PortrangeRtpServerFactory MBean not found", infe );
+        } catch ( Exception e ) {
+            log.info( "failed to register PortrangeRtpServerFactory MBean", e );
+        }
+    }
+
+    /**
+     * register a generated RTP server session in the portrange case
+     */
+    public void registerPortrangeRtpServerSession( PortrangeRtpServerSession session )
+    {
+        boolean enabled = Config.jmxConnectorServiceEnable.getValue();
+        if ( !enabled )
+            return;
+
+        try {
+            PortrangeRtpSession mbean = new PortrangeRtpSession( session );
+            ObjectName name = mbean.buildName();
+
+            mbeanServer.registerMBean( mbean, name );
+            session.setObjectName( name );
+        } catch ( Exception e ) {
+            log.error( "failed to register proxy session MBean: session={}", session, e );
+        }
+    }
+
+    /**
+     * register a generated RTP server session in the portrange case
+     */
+    public void unregisterPortrangeRtpServerSession( PortrangeRtpServerSession session )
+    {
+        boolean enabled = Config.jmxConnectorServiceEnable.getValue();
+        if ( !enabled )
+            return;
+
+        try {
+            ObjectName name = session.getObjectName();
+
+            if ( name != null ) {
+                mbeanServer.unregisterMBean( name );
+                session.setObjectName( null );
+            }
+        } catch ( InstanceNotFoundException infe ) {
+            log.debug( "internal problem: MBean not found, name="
+                    + session.getObjectName(), infe );
+        } catch ( Exception e ) {
+            log.error( "failed to register proxy session MBean: session={}", session, e );
+        }
+    }
+
 }


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/JmxManageable2.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Added: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Mx4jLoggerWrapper.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Mx4jLoggerWrapper.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Mx4jLoggerWrapper.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -0,0 +1,59 @@
+package rtspproxy.jmx;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Simple wrapper to log mx4j logging info into slf4j subsystem
+ * 
+ * @author Rainer Bieniek (Rainer.Bieniek at vodafone.com)
+ * 
+ */
+public class Mx4jLoggerWrapper extends mx4j.log.Logger
+{
+
+    private Logger logger;
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see mx4j.log.Logger#log(int, java.lang.Object, java.lang.Throwable)
+     */
+    @Override
+    protected void log( int level, Object msg, Throwable t )
+    {
+        switch ( level )
+        {
+        case mx4j.log.Logger.DEBUG:
+            logger.debug( msg.toString(), t );
+            break;
+        case mx4j.log.Logger.ERROR:
+            logger.error( msg.toString(), t );
+            break;
+        case mx4j.log.Logger.FATAL:
+            logger.error( msg.toString(), t );
+            break;
+        case mx4j.log.Logger.INFO:
+            logger.info( msg.toString(), t );
+            break;
+        case mx4j.log.Logger.TRACE:
+            logger.debug( msg.toString(), t );
+            break;
+        case mx4j.log.Logger.WARN:
+            logger.warn( msg.toString(), t );
+            break;
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see mx4j.log.Logger#setCategory(java.lang.String)
+     */
+    @Override
+    protected void setCategory( String category )
+    {
+        super.setCategory( category );
+        logger = LoggerFactory.getLogger( category );
+    }
+}


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/Mx4jLoggerWrapper.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/Filter.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/Filter.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/Filter.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -29,15 +29,16 @@
 	 * @throws MalformedObjectNameException 
 	 * 
 	 */
-	public Filter(FilterBase filter) throws MalformedObjectNameException, NullPointerException {
+	public Filter( FilterBase filter ) 
+		throws MalformedObjectNameException, NullPointerException 
+	{
 		this.filter = filter;
 		
 		// build the MBean name
 		Hashtable<String, String> keys = new Hashtable<String, String>();
 		
-		keys.put("filter", filter.getTypeName());
-		keys.put("side", filter.getSide().toString());
-		keys.put("classname", filter.getClassName());
+		keys.put("filter", filter.getName());
+		keys.put("classname", filter.getProviderClassName());
 		keys.put("id", Long.toHexString(System.identityHashCode(filter)));
 		
 		this.name = new ObjectName(JmxAgent.FILTERS_DOMAIN, keys);


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/Filter.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/FilterMBean.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/PortrangeRtpServerFactory.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/PortrangeRtpServerFactoryMBean.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/PortrangeRtpSession.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/PortrangeRtpSessionMBean.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/ProxySessionFacade.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/jmx/mbeans/ProxySessionFacadeMBean.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Base64.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/Side.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedByte.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedInt.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedLong.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedNumber.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/lib/number/UnsignedShort.java
___________________________________________________________________
Name: svn:executable
   - *

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ClientRtcpPacketHandler.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -58,11 +58,13 @@
 
         if ( track == null ) {
             // drop packet
-            log.debug( "Invalid address: {} - Class: {}", session.getRemoteAddress(),
-                    ((InetSocketAddress) session.getRemoteAddress()).getAddress()
-                            .getClass() );
-            
-            log.debug( "Known Client Addresses: {}", Track.clientAddressMap.keySet() );
+            if ( log.isDebugEnabled() ) {
+                log.debug( "Invalid address: {} - Class: {}", session.getRemoteAddress(),
+                        ((InetSocketAddress) session.getRemoteAddress()).getAddress()
+                                .getClass() );
+
+                log.debug( "Known Client Addresses: {}", Track.getClientAddresses() );
+            }
             return;
         }
 


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyConstants.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/ProxyHandler.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -24,12 +24,14 @@
 import java.net.InetSocketAddress;
 import java.net.URL;
 import java.net.UnknownHostException;
-import java.nio.channels.UnresolvedAddressException;
 import java.util.HashMap;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.mina.common.ConnectFuture;
+import org.apache.mina.common.IoFuture;
 import org.apache.mina.common.IoSession;
+import org.apache.mina.common.TrafficMask;
+import org.apache.mina.common.IoFuture.Callback;
 import org.apache.mina.transport.socket.nio.SocketConnector;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -58,7 +60,7 @@
 /**
  * @author Matteo Merli
  */
-public class ProxyHandler
+public class ProxyHandler implements Callback
 {
 
     private static Logger log = LoggerFactory.getLogger( ProxyHandler.class );
@@ -246,7 +248,7 @@
 
         RtspTransportList rtspTransportList = new RtspTransportList( request
                 .getHeader( "Transport" ) );
-        log.debug( "Parsed: {}", rtspTransportList );
+        log.debug( "Parsed: [{}]", rtspTransportList );
 
         if ( rtspTransportList.count() == 0 ) {
             /**
@@ -255,6 +257,7 @@
              * client will have the chance to reformule the request with another
              * transports set.
              */
+            log.debug( "No supported transport was found." );
             sendResponse( clientSession, RtspResponse
                     .errorResponse( RtspCode.UnsupportedTransport ) );
             return;
@@ -497,24 +500,32 @@
         connector.setFilterChainBuilder( new RtspServerFilters() );
 
         // Start communication.
+        InetSocketAddress addr = new InetSocketAddress( host, port );
         log.debug( "Trying to connect to '{}' {}", host, port );
-        try {
+        if ( addr.isUnresolved() ) {
+            log.warn( "Cannot resolve hostname: {}", host );
+            sendResponse( clientSession, RtspResponse
+                    .errorResponse( RtspCode.DestinationUnreachable ) );
+            clientSession.close();
+            return;
+        }
 
-            /*
-             * TODO: Current implementation wait (future.join()) until the
-             * connection with server is completed. This could block the thread
-             * for a long time. Check how to do it in asyncronous way.
-             */
-            ConnectFuture future = connector.connect(
-                    new InetSocketAddress( host, port ), new ServerSide() );
-            future.join();
-            serverSession = future.getSession();
+        // Set the traffic mask to none to avoid reception of
+        // messages from the client.
+        clientSession.setTrafficMask( TrafficMask.NONE );
 
-            // TODO: Rtsp Keep Alive
-            // if (Config.proxyRtspKeepAlive.getValue())
-            // ((SocketSession) serverSession).setKeepAlive(true);
-        } catch ( UnresolvedAddressException e ) {
-            log.warn( "Destination unreachable: " + host + ":" + port );
+        ConnectFuture future = connector.connect( addr, new ServerSide() );
+        future.setCallback( this );
+    }
+
+    public void operationComplete( IoFuture future )
+    {
+        ConnectFuture connectFuture = (ConnectFuture) future;
+        log.debug( "operation completed" );
+        clientSession.setTrafficMask( TrafficMask.ALL );
+
+        if ( !connectFuture.isConnected() ) {
+            log.warn( "Destination unreachable" );
             sendResponse( clientSession, RtspResponse
                     .errorResponse( RtspCode.DestinationUnreachable ) );
             clientSession.close();
@@ -523,6 +534,17 @@
 
         log.debug( "Connected!" );
 
+        try {
+            serverSession = connectFuture.getSession();
+        } catch ( IOException e ) {
+            log.error( "Error getting connection session: " + e );
+            clientSession.close();
+        }
+
+        // TODO: Rtsp Keep Alive
+        // if (Config.proxyRtspKeepAlive.getValue())
+        // ((SocketSession) serverSession).setKeepAlive(true);
+
         // Save current ProxyHandler into the ProtocolSession
         serverSession.setAttribute( ProxyHandler.ATTR, this );
 

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/proxy/track/Track.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -21,6 +21,7 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -84,7 +85,7 @@
 
     /** Maps a client address to a Track */
     // TODO: bring back to protected
-    public static Map<InetSocketAddress, Track> clientAddressMap = new ConcurrentHashMap<InetSocketAddress, Track>();
+    protected static Map<InetSocketAddress, Track> clientAddressMap = new ConcurrentHashMap<InetSocketAddress, Track>();
 
     /** Maps a server address to a Track */
     protected static Map<InetSocketAddress, Track> serverAddressMap = new ConcurrentHashMap<InetSocketAddress, Track>();
@@ -142,6 +143,11 @@
     {
         return serverAddressMap.get( serverAddress );
     }
+    
+    public static Set<InetSocketAddress> getClientAddresses()
+    {
+        return clientAddressMap.keySet();
+    }
 
     /**
      * Get the track by looking at server socket address.


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtAckPacket.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtControlPacket.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtDataPacket.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtFilterChainBuilder.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtLatencyReportPacket.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacket.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtPacketDecoder.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtProtocolCodecFactory.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtProtocolDecoder.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtProtocolEncoder.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtRttRequestPacket.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtRttResponsePacket.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rdt/RdtStreamEndPacket.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSession.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/PortrangeRtpServerSessionFactory.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpRtcpFilterChainBuilder.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtp/range/RtpServerSessionFactory.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java
===================================================================
--- trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/main/java/rtspproxy/rtsp/RtspTransportList.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -65,13 +65,13 @@
 	@Override
     public String toString()
 	{
-		final StringBuilder buf = new StringBuilder();
+		final StringBuilder sb = new StringBuilder();
 		int i = 0;
 		for ( RtspTransport transport : transportList ) {
 			if ( i++ != 0 )
-				buf.append( ',' );
-			buf.append( transport.toString() );
+				sb.append( ',' );
+			sb.append( transport.toString() );
 		}
-		return buf.toString();
+		return sb.toString();
 	}
 }


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/lib/number/UnsignedByteTest.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/lib/number/UnsignedIntTest.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/lib/number/UnsignedLongTest.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/lib/number/UnsignedShortTest.java
___________________________________________________________________
Name: svn:executable
   - *


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/BufferUtils.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtAckPacketTest.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtDataPacketTest.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtLatencyRepostPacketTest.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtRttRequestPacketTest.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtRttResponsePacketTest.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/java/rtspproxy/rdt/RdtStreamEndPacketTest.java
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-Core/src/test/java/rtspproxy/rtsp/RtspTransportTest.java
===================================================================
--- trunk/RTSPProxy-Core/src/test/java/rtspproxy/rtsp/RtspTransportTest.java	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-Core/src/test/java/rtspproxy/rtsp/RtspTransportTest.java	2006-04-25 21:47:58 UTC (rev 416)
@@ -41,6 +41,7 @@
 	String test5 = "x-pn-tng/tcp;mode=play";
 	String test6 = "x-real-rdt/tcp;mode=play";
 	String test7 = "RTP/AVP/TCP;unicast;mode=play";
+    String test8 = "RTP/AVP/TCP;UNICAST;mode=play";
 
 	RtspTransport transport1;
 	RtspTransport transport2;
@@ -49,6 +50,7 @@
 	RtspTransport transport5;
 	RtspTransport transport6;
 	RtspTransport transport7;
+    RtspTransport transport8;
 
 	@Override
 	protected void setUp() throws Exception
@@ -60,6 +62,7 @@
 		transport5 = new RtspTransport( test5 );
 		transport6 = new RtspTransport( test6 );
 		transport7 = new RtspTransport( test7 );
+        transport8 = new RtspTransport( test8 );
 	}
 
 	public void testIsSupportedByProxy()
@@ -71,6 +74,7 @@
 		assertEquals( false, transport5.isSupportedByProxy() );
 		assertEquals( false, transport6.isSupportedByProxy() );
 		assertEquals( false, transport7.isSupportedByProxy() );
+        assertEquals( false, transport8.isSupportedByProxy() );
 	}
 
 	/*
@@ -93,6 +97,7 @@
 		assertEquals( false, transport5.isAppend() );
 		assertEquals( false, transport6.isAppend() );
 		assertEquals( false, transport7.isAppend() );
+        assertEquals( false, transport8.isAppend() );
 	}
 
 	/*
@@ -107,6 +112,7 @@
 		assertTrue( Arrays.equals( new int[] { 0, 0 }, transport5.getClientPort() ) );
 		assertTrue( Arrays.equals( new int[] { 0, 0 }, transport6.getClientPort() ) );
 		assertTrue( Arrays.equals( new int[] { 0, 0 }, transport7.getClientPort() ) );
+        assertTrue( Arrays.equals( new int[] { 0, 0 }, transport8.getClientPort() ) );
 	}
 
 	/*
@@ -121,6 +127,7 @@
 		assertEquals( DeliveryType.None, transport5.getDeliveryType() );
 		assertEquals( DeliveryType.unicast, transport6.getDeliveryType() );
 		assertEquals( DeliveryType.unicast, transport7.getDeliveryType() );
+        assertEquals( DeliveryType.unicast, transport8.getDeliveryType() );
 	}
 
 	/*


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtAckPacket.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtDataPacketDataPacket.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtDataPacketStream0.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtDataPacketStream1.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtLatencyReportWithDataPacket.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtRttRequestPacket.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtRttResponsePacket.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtStreamEndPacketStream0.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev


Property changes on: trunk/RTSPProxy-Core/src/test/resources/rtspproxy/rdt/RdtStreamEndPacketStream1.txt
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/RTSPProxy-OSGi/pom.xml
===================================================================
--- trunk/RTSPProxy-OSGi/pom.xml	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/RTSPProxy-OSGi/pom.xml	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,90 +1,67 @@
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <parent>
-    <groupId>net.merlimat</groupId>
-    <artifactId>rtspproxy</artifactId>
-    <version>3.0-ALPHA5-SNAPSHOT</version>
-  </parent>
-  
-  <modelVersion>4.0.0</modelVersion>
-  <groupId>net.merlimat</groupId>
-  <artifactId>RTSPProxy-OSGi</artifactId>
-  <packaging>osgi-bundle</packaging>
-  <version>3.0-ALPHA5-SNAPSHOT</version>
-  <name>RTSP Proxy OSGi bundle</name>
-  <url>http://rtspproxy.berlios.de</url>
-  <inceptionYear>2003</inceptionYear>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+		
+	<!-- $Id$
+	     $URL$
+	 -->
+	
+	<parent>
+		<groupId>net.merlimat</groupId>
+		<artifactId>rtspproxy</artifactId>
+		<version>3.0-ALPHA5-SNAPSHOT</version>
+		<relativePath>../pom.xml</relativePath>
+	</parent>
 
-  <dependencies>
+	<modelVersion>4.0.0</modelVersion>
 
-    <dependency>
-      <groupId>net.merlimat</groupId>
-      <artifactId>RTSPProxy-Core</artifactId>
-      <version>3.0-ALPHA5-SNAPSHOT</version>
-    </dependency>
+	<artifactId>RTSPProxy-OSGi</artifactId>
+	<packaging>osgi-bundle</packaging>
+	<name>RTSP Proxy OSGi bundle</name>
 
-    <dependency>
-      <groupId>org.osgi</groupId>
-      <artifactId>org.osgi</artifactId>
-      <version>3.0</version>
-      <scope>provided</scope>
-    </dependency>
+	<dependencies>
+		<dependency>
+			<groupId>net.merlimat</groupId>
+			<artifactId>RTSPProxy-Core</artifactId>
+			<version>3.0-ALPHA5-SNAPSHOT</version>
+		</dependency>
 
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <version>3.8.1</version>
-      <scope>test</scope>
-    </dependency>
+		<dependency>
+			<groupId>org.osgi</groupId>
+			<artifactId>org.osgi</artifactId>
+			<version>3.0</version>
+			<scope>provided</scope>
+		</dependency>
+	</dependencies>
 
-  </dependencies>
+	<build>
+		<defaultGoal>package</defaultGoal>
 
-  <build>
-    <defaultGoal>assembly:directory</defaultGoal>
-    
-    <resources>
-      <resource>
-	<directory>src/main/resources</directory>
-	<filtering>true</filtering>
-      </resource>
-    </resources>
-    
-    <plugins>
-      <plugin>
-	<groupId>org.apache.maven.plugins</groupId>
-	<artifactId>maven-compiler-plugin</artifactId>
-	<configuration>
-	  <source>1.5</source>
-	  <target>1.5</target>
-	  <showWarnings>true</showWarnings>
-	</configuration>
-      </plugin>
+		<plugins>
 
-      <!-- see http://docs.safehaus.org/display/OSGI/OSGi+Plugin+for+Maven+2.0 for further instructions -->
-      <plugin>
-        <groupId>org.apache.felix.plugins</groupId>
-        <artifactId>maven-osgi-plugin</artifactId>
-        <extensions>true</extensions>
-        <version>0.3.0</version>
-        <configuration>
-          <osgiManifest>
-            <bundleActivator>rtspproxy.bundle.Activator</bundleActivator>
-            <bundleName>RTSP Proxy bundle</bundleName>
-            <bundleDescription>RTSP Proxy bundle</bundleDescription>
-            <bundleVendor>rbieniek</bundleVendor>
-	    <importPackage>org.osgi.service.log</importPackage>
-          </osgiManifest>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+			<!-- see http://docs.safehaus.org/display/OSGI/OSGi+Plugin+for+Maven+2.0 for further instructions -->
+			<plugin>
+				<groupId>org.apache.felix.plugins</groupId>
+				<artifactId>maven-osgi-plugin</artifactId>
+				<extensions>true</extensions>
+				<version>0.3.0</version>
+				<configuration>
+					<osgiManifest>
+						<bundleActivator>
+							rtspproxy.bundle.Activator
+						</bundleActivator>
+						<bundleName>RTSP Proxy bundle</bundleName>
+						<bundleDescription>
+							RTSP Proxy bundle
+						</bundleDescription>
+						<bundleVendor>rbieniek</bundleVendor>
+						<importPackage>
+							org.osgi.service.log
+						</importPackage>
+					</osgiManifest>
+				</configuration>
+			</plugin>
+		</plugins>
+	</build>
 
-  <repositories>
-    <repository>
-      <id>safehaus-repository</id>
-      <name>Safehaus Repository</name>
-      <url>http://m2.safehaus.org</url>
-    </repository>
-  </repositories>
-
 </project>


Property changes on: trunk/RTSPProxy-OSGi/pom.xml
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Modified: trunk/pom.xml
===================================================================
--- trunk/pom.xml	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/pom.xml	2006-04-25 21:47:58 UTC (rev 416)
@@ -95,6 +95,107 @@
     <module>RTSPProxy-App</module>
     <module>RTSPProxy-OSGi</module>
   </modules>
+
+
+<dependencies>
+	<dependency>
+		<groupId>org.apache.directory.mina</groupId>
+		<artifactId>mina-core</artifactId>
+		<version>0.9.3</version>
+	</dependency>
+
+	<dependency>
+		<groupId>mx4j</groupId>
+		<artifactId>mx4j-tools</artifactId>
+		<version>2.1.1</version>
+	</dependency>
+
+	<dependency>
+		<groupId>org.slf4j</groupId>
+		<artifactId>slf4j-log4j12</artifactId>
+		<version>1.0</version>
+	</dependency>
+
+	<dependency>
+		<groupId>log4j</groupId>
+		<artifactId>log4j</artifactId>
+		<version>1.2.13</version>
+	</dependency>
+
+	<dependency>
+		<groupId>commons-pool</groupId>
+		<artifactId>commons-pool</artifactId>
+		<version>1.3</version>
+	</dependency>
+
+	<dependency>
+		<groupId>commons-configuration</groupId>
+		<artifactId>commons-configuration</artifactId>
+		<version>1.2</version>
+	</dependency>
+	
+	<!-- Included here to disambiguate the version number -->
+	<dependency>
+		<groupId>commons-collections</groupId>
+		<artifactId>commons-collections</artifactId>
+		<version>3.1</version>
+	</dependency>
+
+	<dependency>
+		<groupId>junit</groupId>
+		<artifactId>junit</artifactId>
+		<version>3.8.1</version>
+		<scope>test</scope>
+	</dependency>
+
+	<!-- These are dependencies inherited which are not really
+	     necessaries, so we prevent them from being included
+	     in the final binary package.
+	  -->
+	<dependency>
+		<groupId>xalan</groupId>
+		<artifactId>xalan</artifactId>
+		<version>2.7.0</version>
+		<scope>provided</scope>
+	</dependency>
+	
+	<dependency>
+		<groupId>xerces</groupId>
+		<artifactId>xercesImpl</artifactId>
+		<version>2.2.1</version>
+		<scope>provided</scope>
+	</dependency>
+	<dependency>
+		<groupId>xml-apis</groupId>
+		<artifactId>xml-apis</artifactId>
+		<version>1.0.b2</version>
+		<scope>provided</scope>
+	</dependency>
+        <dependency>
+		<groupId>dom4j</groupId>
+		<artifactId>dom4j</artifactId>
+		<version>1.4</version>
+		<scope>provided</scope>
+	</dependency>
+	<dependency>
+		<groupId>msv</groupId>
+		<artifactId>msv</artifactId>
+		<version>20020414</version>
+		<scope>provided</scope>
+	</dependency>
+	<dependency>
+		<groupId>javax.servlet</groupId>
+		<artifactId>servlet-api</artifactId>
+		<version>2.3</version>
+		<scope>provided</scope>
+	</dependency>
+	<dependency>
+		<groupId>jaxen</groupId>
+		<artifactId>jaxen</artifactId>
+		<version>1.0-FCS</version>
+		<scope>provided</scope>
+	</dependency>
+</dependencies>
     
   <build>
     <defaultGoal>package</defaultGoal>
@@ -107,6 +208,19 @@
     </resources>
     
     <plugins>
+		<plugin>
+			<groupId>org.apache.maven.plugins</groupId>
+			<artifactId>maven-compiler-plugin</artifactId>
+			<configuration>
+				<source>1.5</source>
+				<target>1.5</target>
+				<optimize>true</optimize>
+				<debug>true</debug>
+				<showWarnings>true</showWarnings>
+				<showDeprecations>true</showDeprecations>
+			</configuration>
+		</plugin>
+	
 <!--
       <plugin>
 	<groupId>org.apache.maven.plugins</groupId>
@@ -189,5 +303,28 @@
       -->
     </plugins>
   </reporting>
+
+	<repositories>
+
+		<repository>
+			<id>Apache repository</id>
+			<url>http://svn.apache.org/repository/</url>
+		</repository>
+
+		<!-- For snapshots (no release jars or non-apache jars)           -->
+		<repository>
+			<id>apache.snapshots</id>
+			<name>Apache Snapshot Repository</name>
+			<url>http://cvs.apache.org/maven-snapshot-repository</url>
+		</repository>
+
+		<!--
+			<repository>
+			<id>ibilio maven2</id>
+			<url>http://www.ibiblio.org/maven2/</url>
+			</repository>
+		-->
+	</repositories>
+
   
 </project>

Modified: trunk/src/changes/changes.xml
===================================================================
--- trunk/src/changes/changes.xml	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/src/changes/changes.xml	2006-04-25 21:47:58 UTC (rev 416)
@@ -1,19 +1,143 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <document>
-  <properties>
-    <title>Changes History</title>
-    <author email="Rainer.Bieniek at vodafone.com">Rainer Bieniek</author>
-  </properties>
-  <body>
-    
-    <release version="3.0-ALPHA4-SNAPSHOT" date="in SVN">
-      <action dev="rbieniek" type="change">
-	Restructured project for multi-module project.
-      </action>
+	<properties>
+		<title>Changes History</title>
+		<author email="matteo.merli at gmail.com">Matteo Merli</author>
+	</properties>
+	<body>
 
-      <action dev="rbieniek" type="add">
-	Added OSGi bundle skeleton.
-      </action>
-    </release>
-  </body>
+		<release version="3.0-ALPHA5-SNAPSHOT" date="in SVN">
+
+			<action dev="rbieniek" type="update">
+				Restructured project for multi-module project.
+			</action>
+
+			<action dev="rbieniek" type="add">
+				Added OSGi bundle skeleton.
+			</action>
+
+			<action dev="rbieniek" type="add">
+				Added support for XML based comfiguration files.
+			</action>
+
+			<action dev="rbieniek" type="update">
+				Configuration has been changed from property-file to XML
+				config file. The configuration has been changed to allow
+				multiple filters per type and each filter may take its
+				configuration information from a central configuration
+				file.
+			</action>
+
+			<action dev="rbieniek" type="update">
+				Changed logging framework from log4j to slf4j (Simple
+				Logging Facade for Java). This change streamlines the
+				logging framework with the underlying mina logging
+				approach. This changes also allows an easier integration
+				into containers which provide their own logging
+				mechanisms (like OSGi).
+			</action>
+
+			<action dev="rbieniek" type="add">
+				Added a concept of filters being applied to the upstream
+				(remote server) connection and the downstream client
+				connection. This allows for example IP addess based
+				filters which might constrain access to either the
+				streaming proxy, to remote streaming servers or both.
+			</action>
+
+			<action dev="rbieniek" type="add">
+				Made installed filters manageable through JMX. An
+				individual filter can be suspended or resumed via JMX
+				and may provide addtional management capabilites by
+				exposing an linked MBean.
+			</action>
+
+			<action dev="rbieniek" type="add">
+				All RTSP filters are now managed through a central
+				filter registry. This will allow the dynamic
+				reconfiguration of the applied filter chain per new
+				session.
+			</action>
+
+			<action dev="rbieniek" type="update">
+				Made URL rewriting working again. This filter is
+				actually applied to both the client and the server
+				connection because it needs to modify both request and
+				response. The response filter currently honours the
+				Content-base header, the RTP-Info header is not
+				processed yet.
+			</action>
+
+		</release>
+
+		<release version="3.0-ALPHA4" date="not released" />
+
+		<release version="3.0-ALPHA3" date="not released">
+			<action dev="merlimat" type="add">
+				Added support for RDT transport and RealVideo streams.
+			</action>
+			<action dev="merlimat" type="change">
+				Refactored the configuration subsystem.
+			</action>
+			<action dev="merlimat" type="add">
+				Added JMX complaint remote management capabilities.
+			</action>
+			<action dev="merlimat" type="add">
+				Added accounting filter to log accesses to the proxy
+				service.
+			</action>
+		</release>
+
+		<release version="3.0-ALPHA2" date="2005-12-08">
+			<action dev="merlimat" type="add">
+				Added preliminary implementation of the IP address and
+				host name filter.
+			</action>
+			<action dev="merlimat" type="fix">
+				Fixed Windows startup script.
+			</action>
+			<action dev="merlimat" type="update">
+				Using only a UDP port pair for all RTP/RTCP packet
+				handling and sending for all the connected clients.
+			</action>
+			<action dev="merlimat" type="fix">
+				Properly clear session data when a session is closed.
+			</action>
+			<action dev="merlimat" type="fix">
+				Fixed several NullPointerException.
+			</action>
+			<action dev="merlimat" type="update">
+				Faster parsing of RTSP messages.
+			</action>
+			<action dev="merlimat" type="add">
+				Handling proper shutdown of the service.
+			</action>
+		</release>
+
+		<release version="3.0-ALPHA1" date="2005-10-24">
+			<action dev="merlimat" type="add">
+				Completely rewritten the proxy from scratch in Java
+			</action>
+		</release>
+
+		<release version="2.4.1" date="2005-02-28">
+			<action dev="merlimat" type="fix">
+				Fixed a compilation bug.
+			</action>
+		</release>
+
+		<release version="2.4" date="2005-02-09">
+			<action type="fix" dev="merlimat">
+				In this release there are many important bug fixes that
+				make the proxy works with major RTSP streaming servers
+				and video players.
+			</action>
+			<action type="update" dev="merlimat">
+				The proxy was ported to MacOsX and now it can be
+				compiled using a various Gcc versions (2.95, 3.1, 3.3,
+				3.4).
+			</action>
+		</release>
+	</body>
 </document>
+

Modified: trunk/src/site/site.xml
===================================================================
--- trunk/src/site/site.xml	2006-04-14 15:41:06 UTC (rev 415)
+++ trunk/src/site/site.xml	2006-04-25 21:47:58 UTC (rev 416)
@@ -17,6 +17,10 @@
 		</links>
 
 		<menu name="Rtsp Proxy">
+			<item name="FALSE" href="">
+				<item name="test1" href="test1.html" />
+				<item name="test2" href="" />
+			</item>
 			<item
 				name="Home"
 				href="index.html" />
@@ -92,4 +96,4 @@
 
                ${modules}
 	</body>
-</project>
\ No newline at end of file
+</project>



From merlimat at berlios.de  Wed Apr 26 00:26:00 2006
From: merlimat at berlios.de (merlimat at berlios.de)
Date: Wed, 26 Apr 2006 00:26:00 +0200
Subject: [Rtspproxy-devel] r417 - in trunk: . JainSDP JainSDP/src JainSDP/src/main JainSDP/src/main/java JainSDP/src/main/java/javax RTSPProxy-Core/src/main/java RTSPProxy-Core/src/main/java/javax RTSPProxy-OSGi
Message-ID: <200604252226.k3PMQ0V0006436@sheep.berlios.de>

Author: merlimat
Date: 2006-04-26 00:25:50 +0200 (Wed, 26 Apr 2006)
New Revision: 417

Added:
   trunk/JainSDP/
   trunk/JainSDP/pom.xml
   trunk/JainSDP/src/
   trunk/JainSDP/src/main/
   trunk/JainSDP/src/main/java/
   trunk/JainSDP/src/main/java/gov/
   trunk/JainSDP/src/main/java/javax/
   trunk/JainSDP/src/main/java/javax/sdp/
Removed:
   trunk/RTSPProxy-Core/src/main/java/gov/
   trunk/RTSPProxy-Core/src/main/java/javax/sdp/
Modified:
   trunk/RTSPProxy-OSGi/
   trunk/pom.xml
Log:
Moved Jain SDP into a separate module.



Property changes on: trunk/JainSDP
___________________________________________________________________
Name: svn:ignore
   + 
target


Added: trunk/JainSDP/pom.xml
===================================================================
--- trunk/JainSDP/pom.xml	2006-04-25 21:47:58 UTC (rev 416)
+++ trunk/JainSDP/pom.xml	2006-04-25 22:25:50 UTC (rev 417)
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project
+	xsi:noNamespaceSchemaLocation="http://maven.apache.org/maven-v4_0_0.xsd">
+
+	<!-- 
+		$Id$
+		$URL$
+	-->
+
+	<parent>
+		<groupId>net.merlimat</groupId>
+		<artifactId>rtspproxy</artifactId>
+		<version>3.0-ALPHA5-SNAPSHOT</version>
+		<relativePath>../pom.xml</relativePath>
+	</parent>
+
+	<modelVersion>4.0.0</modelVersion>
+
+	<name>JAIN SDP</name>
+	<artifactId>JainSDP</artifactId>	
+
+</project>


Property changes on: trunk/JainSDP/pom.xml
___________________________________________________________________
Name: svn:keywords
   + Id URL Rev

Copied: trunk/JainSDP/src/main/java/gov (from rev 416, trunk/RTSPProxy-Core/src/main/java/gov)

Copied: trunk/JainSDP/src/main/java/javax/sdp (from rev 416, trunk/RTSPProxy-Core/src/main/java/javax/sdp)


Property changes on: trunk/RTSPProxy-OSGi
___________________________________________________________________
Name: svn:ignore
   + 
target


Modified: trunk/pom.xml
===================================================================
--- trunk/pom.xml	2006-04-25 21:47:58 UTC (rev 416)
+++ trunk/pom.xml	2006-04-25 22:25:50 UTC (rev 417)
@@ -94,6 +94,7 @@
     <module>RTSPProxy-Core</module>
     <module>RTSPProxy-App</module>
     <module>RTSPProxy-OSGi</module>
+    <module>JainSDP</module>
   </modules>
 
 



